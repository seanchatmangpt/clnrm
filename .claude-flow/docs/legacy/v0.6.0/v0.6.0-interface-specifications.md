# CLNRM v0.6.0 Interface Specifications

**Version**: 0.6.0
**Date**: 2025-10-16
**Status**: APPROVED

## Overview

This document defines all public interfaces, APIs, and contracts for CLNRM v0.6.0. All interfaces maintain backward compatibility with v0.4.x while adding new capabilities.

## Template System Interfaces

### 1. TemplateRenderer API

**Module**: `clnrm_core::template`

```rust
/// Template renderer with Tera engine
pub struct TemplateRenderer {
    tera: Tera,
    context: TemplateContext,
}

impl TemplateRenderer {
    /// Create new template renderer with custom functions
    ///
    /// # Returns
    /// - `Ok(TemplateRenderer)` - Successfully created renderer
    /// - `Err(CleanroomError)` - Failed to initialize Tera engine
    ///
    /// # Examples
    /// ```rust
    /// use clnrm_core::template::TemplateRenderer;
    ///
    /// let renderer = TemplateRenderer::new()?;
    /// ```
    pub fn new() -> Result<Self>;

    /// Set template context variables
    ///
    /// # Arguments
    /// - `context` - Template context with variables
    ///
    /// # Returns
    /// - Self with context applied
    ///
    /// # Examples
    /// ```rust
    /// let mut context = TemplateContext::new();
    /// context.vars.insert("name".to_string(), json!("value"));
    /// let renderer = TemplateRenderer::new()?.with_context(context);
    /// ```
    pub fn with_context(self, context: TemplateContext) -> Self;

    /// Render template file to TOML string
    ///
    /// # Arguments
    /// - `path` - Path to template file
    ///
    /// # Returns
    /// - `Ok(String)` - Rendered TOML content
    /// - `Err(CleanroomError)` - Template rendering failed
    ///
    /// # Errors
    /// - `ErrorKind::IoError` - Failed to read file
    /// - `ErrorKind::TemplateError` - Template syntax error
    ///
    /// # Examples
    /// ```rust
    /// let renderer = TemplateRenderer::new()?;
    /// let rendered = renderer.render_file(Path::new("test.toml"))?;
    /// ```
    pub fn render_file(&mut self, path: &Path) -> Result<String>;

    /// Render template string to TOML
    ///
    /// # Arguments
    /// - `template` - Template content
    /// - `name` - Template name (for error messages)
    ///
    /// # Returns
    /// - `Ok(String)` - Rendered TOML content
    /// - `Err(CleanroomError)` - Template rendering failed
    ///
    /// # Examples
    /// ```rust
    /// let renderer = TemplateRenderer::new()?;
    /// let rendered = renderer.render_str("{{ fake_uuid() }}", "test")?;
    /// ```
    pub fn render_str(&mut self, template: &str, name: &str) -> Result<String>;
}

impl Default for TemplateRenderer {
    fn default() -> Self;
}
```

**Design Constraints**:
- **No `.unwrap()` or `.expect()`** - All methods return `Result<T, CleanroomError>`
- **Sync methods** - No async (maintains trait compatibility)
- **Thread-safe** - Can be shared via `Arc<Mutex<TemplateRenderer>>`

### 2. Template Functions Interface

**Module**: `clnrm_core::template::functions`

```rust
/// Register all custom functions with Tera
///
/// Registers the following functions:
/// - `env(name)` - Get environment variable
/// - `now_rfc3339()` - Current timestamp (deterministic)
/// - `sha256(s)` - SHA-256 hex digest
/// - `toml_encode(value)` - Encode as TOML literal
/// - `fake_uuid()` - Generate UUID v4
/// - `fake_name()` - Generate random name
/// - `fake_email()` - Generate email address
/// - `fake_ipv4()` - Generate IPv4 address
/// - `fake_int(min, max)` - Random integer
/// - `fake_string(length)` - Random alphanumeric string
/// - `fake_bool()` - Random boolean
/// - `property_range(start, end)` - Range of integers
/// - `random_choice(items)` - Random item from list
///
/// # Arguments
/// - `tera` - Tera instance to register functions with
///
/// # Returns
/// - `Ok(())` - Functions registered successfully
/// - `Err(CleanroomError)` - Registration failed
///
/// # Examples
/// ```rust
/// use tera::Tera;
/// use clnrm_core::template::functions;
///
/// let mut tera = Tera::default();
/// functions::register_functions(&mut tera)?;
/// ```
pub fn register_functions(tera: &mut Tera) -> Result<()>;
```

**Function Signatures** (Tera callable):

```rust
// Environment and Time
env(name: String) -> String
now_rfc3339() -> String

// Hashing and Encoding
sha256(s: String) -> String
toml_encode(value: Value) -> String

// NEW in v0.6.0: Fake Data Generators
fake_uuid() -> String
fake_name() -> String
fake_email() -> String
fake_ipv4() -> String

// NEW in v0.6.0: Random Generators
fake_int(min: i64, max: i64) -> i64
fake_string(length: usize) -> String
fake_bool() -> bool

// NEW in v0.6.0: Property Testing Helpers
property_range(start: i64, end: i64) -> Vec<i64>
random_choice(items: Vec<String>) -> String
```

**Template Usage Examples**:
```toml
# Environment variables
service_name = "{{ env(name='SERVICE_NAME') }}"

# Timestamps
created_at = "{{ now_rfc3339() }}"

# Hashing
password_hash = "{{ sha256(s='my_password') }}"

# Fake data
user_id = "{{ fake_uuid() }}"
user_name = "{{ fake_name() }}"
user_email = "{{ fake_email() }}"

# Random data
port = {{ fake_int(min=8000, max=9000) }}
token = "{{ fake_string(length=32) }}"

# Property testing
{% for i in property_range(start=0, end=100) %}
[[steps]]
name = "test_{{ i }}"
command = ["test", "{{ i }}"]
{% endfor %}
```

### 3. Template Detection Interface

**Module**: `clnrm_core::template`

```rust
/// Check if file content should be treated as a template
///
/// Detects Tera template syntax:
/// - `{{ variable }}` - variable substitution
/// - `{% for x in list %}` - control structures
/// - `{# comment #}` - comments
///
/// # Arguments
/// - `content` - File content to check
///
/// # Returns
/// - `true` - Content contains template syntax
/// - `false` - Content is plain TOML
///
/// # Examples
/// ```rust
/// use clnrm_core::template::is_template;
///
/// assert!(is_template("{{ var }}"));
/// assert!(is_template("{% for x in list %}"));
/// assert!(!is_template("plain toml"));
/// ```
pub fn is_template(content: &str) -> bool;
```

**Performance**: O(n) single scan of content

## OTEL Validation Interfaces

### 1. OtelValidator API

**Module**: `clnrm_core::validation::otel`

```rust
/// OpenTelemetry validator
#[derive(Debug, Clone)]
pub struct OtelValidator {
    config: OtelValidationConfig,
    span_collector: Arc<InMemorySpanCollector>,
}

impl OtelValidator {
    /// Create a new OTel validator with default configuration
    ///
    /// # Returns
    /// - New validator instance
    ///
    /// # Examples
    /// ```rust
    /// use clnrm_core::validation::otel::OtelValidator;
    ///
    /// let validator = OtelValidator::new();
    /// ```
    pub fn new() -> Self;

    /// Create validator with custom configuration
    ///
    /// # Arguments
    /// - `config` - Validation configuration
    ///
    /// # Returns
    /// - New validator with configuration
    ///
    /// # Examples
    /// ```rust
    /// let config = OtelValidationConfig {
    ///     validate_spans: true,
    ///     max_overhead_ms: 50.0,
    ///     ..Default::default()
    /// };
    /// let validator = OtelValidator::with_config(config);
    /// ```
    pub fn with_config(config: OtelValidationConfig) -> Self;

    /// Create validator with span collector (for testing)
    ///
    /// # Arguments
    /// - `collector` - In-memory span collector
    ///
    /// # Returns
    /// - New validator with collector
    ///
    /// # Examples
    /// ```rust
    /// let collector = Arc::new(InMemorySpanCollector::new());
    /// let validator = OtelValidator::with_collector(collector);
    /// ```
    pub fn with_collector(collector: Arc<InMemorySpanCollector>) -> Self;

    /// Validate a span assertion
    ///
    /// # Arguments
    /// - `assertion` - Span assertion to validate
    ///
    /// # Returns
    /// - `Ok(SpanValidationResult)` - Validation result
    /// - `Err(CleanroomError)` - Validation failed or disabled
    ///
    /// # Errors
    /// - `ErrorKind::ValidationError` - Validation disabled or failed
    ///
    /// # Examples
    /// ```rust
    /// let assertion = SpanAssertion {
    ///     name: "user.login".to_string(),
    ///     attributes: [("user.id", "123")].into_iter()
    ///         .map(|(k, v)| (k.to_string(), v.to_string()))
    ///         .collect(),
    ///     required: true,
    ///     min_duration_ms: None,
    ///     max_duration_ms: Some(1000.0),
    /// };
    ///
    /// let result = validator.validate_span(&assertion)?;
    /// assert!(result.passed);
    /// ```
    pub fn validate_span(&self, assertion: &SpanAssertion) -> Result<SpanValidationResult>;

    /// Validate a trace assertion
    ///
    /// # Arguments
    /// - `assertion` - Trace assertion to validate
    ///
    /// # Returns
    /// - `Ok(TraceValidationResult)` - Validation result
    /// - `Err(CleanroomError)` - Validation failed or disabled
    ///
    /// # Examples
    /// ```rust
    /// let assertion = TraceAssertion {
    ///     trace_id: Some("trace-123".to_string()),
    ///     expected_spans: vec![/* ... */],
    ///     complete: true,
    ///     parent_child_relationships: vec![
    ///         ("parent".to_string(), "child".to_string())
    ///     ],
    /// };
    ///
    /// let result = validator.validate_trace(&assertion)?;
    /// assert!(result.passed);
    /// ```
    pub fn validate_trace(&self, assertion: &TraceAssertion) -> Result<TraceValidationResult>;

    /// Validate telemetry export
    ///
    /// # Arguments
    /// - `endpoint` - OTLP endpoint to validate
    ///
    /// # Returns
    /// - `Ok(true)` - Export successful
    /// - `Err(CleanroomError)` - Export failed or disabled
    ///
    /// # Examples
    /// ```rust
    /// let success = validator.validate_export("http://localhost:4318")?;
    /// assert!(success);
    /// ```
    pub fn validate_export(&self, endpoint: &str) -> Result<bool>;

    /// Validate performance overhead
    ///
    /// # Arguments
    /// - `baseline_duration_ms` - Duration without telemetry
    /// - `with_telemetry_duration_ms` - Duration with telemetry
    ///
    /// # Returns
    /// - `Ok(true)` - Overhead within acceptable limits
    /// - `Err(CleanroomError)` - Overhead exceeded or validation disabled
    ///
    /// # Examples
    /// ```rust
    /// let baseline = 100.0;
    /// let with_telemetry = 120.0; // 20ms overhead
    /// let success = validator.validate_performance_overhead(baseline, with_telemetry)?;
    /// assert!(success);
    /// ```
    pub fn validate_performance_overhead(
        &self,
        baseline_duration_ms: f64,
        with_telemetry_duration_ms: f64,
    ) -> Result<bool>;
}

impl Default for OtelValidator {
    fn default() -> Self;
}
```

### 2. Validation Configuration

**Module**: `clnrm_core::validation::otel`

```rust
/// OpenTelemetry validation configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OtelValidationConfig {
    /// Enable span validation
    pub validate_spans: bool,
    /// Enable trace completeness validation
    pub validate_traces: bool,
    /// Enable export validation
    pub validate_exports: bool,
    /// Enable performance overhead validation
    pub validate_performance: bool,
    /// Maximum allowed performance overhead in milliseconds
    pub max_overhead_ms: f64,
    /// Expected span attributes
    pub expected_attributes: HashMap<String, String>,
}

impl Default for OtelValidationConfig {
    fn default() -> Self {
        Self {
            validate_spans: true,
            validate_traces: true,
            validate_exports: false, // Requires external collector
            validate_performance: true,
            max_overhead_ms: 100.0,
            expected_attributes: HashMap::new(),
        }
    }
}
```

### 3. Assertion Types

**Module**: `clnrm_core::validation::otel`

```rust
/// Span assertion configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpanAssertion {
    /// Expected span name (operation name)
    pub name: String,
    /// Expected span attributes
    pub attributes: HashMap<String, String>,
    /// Whether span must exist
    pub required: bool,
    /// Minimum span duration in milliseconds
    pub min_duration_ms: Option<f64>,
    /// Maximum span duration in milliseconds
    pub max_duration_ms: Option<f64>,
}

/// Trace assertion configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceAssertion {
    /// Expected trace ID (optional)
    pub trace_id: Option<String>,
    /// Expected spans in the trace
    pub expected_spans: Vec<SpanAssertion>,
    /// Whether all spans must be present
    pub complete: bool,
    /// Expected parent-child relationships
    pub parent_child_relationships: Vec<(String, String)>,
}
```

### 4. Validation Results

**Module**: `clnrm_core::validation::otel`

```rust
/// Span validation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpanValidationResult {
    /// Whether validation passed
    pub passed: bool,
    /// Span name that was validated
    pub span_name: String,
    /// Validation errors (if any)
    pub errors: Vec<String>,
    /// Actual span attributes found
    pub actual_attributes: HashMap<String, String>,
    /// Actual span duration in milliseconds
    pub actual_duration_ms: Option<f64>,
}

/// Trace validation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceValidationResult {
    /// Whether validation passed
    pub passed: bool,
    /// Trace ID that was validated
    pub trace_id: Option<String>,
    /// Number of expected spans
    pub expected_span_count: usize,
    /// Number of actual spans found
    pub actual_span_count: usize,
    /// Individual span validation results
    pub span_results: Vec<SpanValidationResult>,
    /// Validation errors (if any)
    pub errors: Vec<String>,
}
```

### 5. Test Utilities

**Module**: `clnrm_core::validation::otel`

```rust
/// Setup OTEL with in-memory span collector for testing
///
/// # Returns
/// - `Ok((OtelGuard, Arc<InMemorySpanCollector>))` - OTEL guard and collector
/// - `Err(CleanroomError)` - Setup failed
///
/// # Examples
/// ```rust
/// use clnrm_core::validation::otel::{setup_otel_for_testing, OtelValidator};
///
/// let (guard, collector) = setup_otel_for_testing()?;
/// let validator = OtelValidator::with_collector(collector);
///
/// // Run traced code
/// traced_function().await;
///
/// // Validate
/// let result = validator.validate_span(&assertion)?;
/// assert!(result.passed);
/// ```
pub fn setup_otel_for_testing() -> Result<(OtelGuard, Arc<InMemorySpanCollector>)>;
```

## Config Loading Interface (Enhanced)

**Module**: `clnrm_core::config`

```rust
/// Load configuration from file (template-aware)
///
/// Automatically detects and renders Tera templates before parsing TOML.
///
/// # Arguments
/// - `path` - Path to configuration file
///
/// # Returns
/// - `Ok(TestConfig)` - Parsed and validated configuration
/// - `Err(CleanroomError)` - Failed to load or parse
///
/// # Errors
/// - `ErrorKind::IoError` - Failed to read file
/// - `ErrorKind::TemplateError` - Template rendering failed
/// - `ErrorKind::ConfigurationError` - TOML parsing failed
/// - `ErrorKind::ValidationError` - Config validation failed
///
/// # Examples
/// ```rust
/// use clnrm_core::config::load_config_from_file;
/// use std::path::Path;
///
/// // Works with static TOML
/// let config = load_config_from_file(Path::new("test.toml"))?;
///
/// // Works with template TOML (auto-detected)
/// let config = load_config_from_file(Path::new("templated.toml"))?;
/// ```
pub fn load_config_from_file(path: &Path) -> Result<TestConfig>;
```

**Backward Compatibility Guarantee**:
- Static TOML files: Parse directly (no changes)
- Template TOML files: Render then parse (new behavior)
- Detection: Automatic via content scanning

## Error Interface (Enhanced)

**Module**: `clnrm_core::error`

```rust
/// Cleanroom error with rich context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleanroomError {
    pub kind: ErrorKind,
    pub message: String,
    pub context: Option<String>,
    pub source: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

impl CleanroomError {
    /// Create a template error
    ///
    /// # Arguments
    /// - `message` - Error message
    ///
    /// # Returns
    /// - Template error instance
    ///
    /// # Examples
    /// ```rust
    /// use clnrm_core::error::CleanroomError;
    ///
    /// return Err(CleanroomError::template_error(
    ///     "Unknown function 'fake_invalid'"
    /// ));
    /// ```
    pub fn template_error(message: impl Into<String>) -> Self;

    /// Create a validation error
    ///
    /// # Arguments
    /// - `message` - Error message
    ///
    /// # Returns
    /// - Validation error instance
    ///
    /// # Examples
    /// ```rust
    /// return Err(CleanroomError::validation_error(
    ///     "Span 'user.login' not found"
    /// ));
    /// ```
    pub fn validation_error(message: impl Into<String>) -> Self;

    // ... other error constructors
}
```

## Plugin Interface (Unchanged)

**Module**: `clnrm_core::cleanroom`

```rust
/// Service plugin trait (UNCHANGED in v0.6.0)
pub trait ServicePlugin: Send + Sync {
    /// Start the service
    fn start(&self) -> Result<ServiceHandle>;

    /// Stop the service
    fn stop(&self, handle: &ServiceHandle) -> Result<()>;

    /// Check service health
    fn health_check(&self, handle: &ServiceHandle) -> Result<HealthStatus>;

    /// Get service type identifier
    fn service_type(&self) -> &str;
}
```

**Backward Compatibility**: 100% compatible with v0.4.x plugins

## Type Aliases and Re-exports

**Module**: `clnrm_core::lib`

```rust
// Template system (NEW exports in v0.6.0)
pub use template::{
    DeterminismConfig,
    TemplateContext,
    TemplateRenderer,
    is_template,  // NEW
    functions,    // NEW
};

// OTEL validation (ENHANCED exports in v0.6.0)
pub use validation::otel::{
    OtelValidationConfig,
    OtelValidator,
    SpanAssertion,
    TraceAssertion,
    SpanValidationResult,      // NEW
    TraceValidationResult,     // NEW
    setup_otel_for_testing,    // NEW
};

// Core types (unchanged)
pub use error::{CleanroomError, Result};
pub use cleanroom::{
    CleanroomEnvironment,
    ServicePlugin,
    ServiceHandle,
    ExecutionResult,
};
```

## Semantic Versioning Compliance

**Version**: 0.6.0 (MINOR bump)

### Added (New Features)
- Template functions: `fake_uuid()`, `fake_name()`, `fake_email()`, etc.
- OTEL validation: `validate_span()`, `validate_trace()`, `validate_export()`
- Test utilities: `setup_otel_for_testing()`
- Enhanced error messages with context

### Changed (Non-breaking)
- `load_config_from_file()` now auto-detects and renders templates
- Error types have richer context (backward compatible)
- OTEL validator fully implemented (was stubs)

### Deprecated
- None

### Removed
- None

### Fixed
- OTEL validation methods now work (were `unimplemented!()`)

### Security
- No security-related changes

## Interface Stability Guarantees

### Stable Interfaces (Will NOT change in v0.x)
- `ServicePlugin` trait
- `CleanroomEnvironment` API
- `load_config_from_file()` signature
- `CleanroomError` structure
- `TestConfig` structure

### Evolving Interfaces (May add methods in v0.x)
- `TemplateRenderer` - May add new render methods
- `OtelValidator` - May add new validation methods
- Template functions - May add new functions

### Experimental Interfaces (May change in v0.x)
- None in v0.6.0

## Testing Interface Compliance

All interfaces must pass:

### Type Safety
- [ ] No `unsafe` code
- [ ] No raw pointers
- [ ] All public types are `Send + Sync` (where applicable)

### Error Handling
- [ ] No `.unwrap()` or `.expect()` in public methods
- [ ] All fallible operations return `Result<T, CleanroomError>`
- [ ] Error messages provide actionable context

### Documentation
- [ ] All public items have doc comments
- [ ] All methods have examples in doc tests
- [ ] All errors documented in `# Errors` section

### Backward Compatibility
- [ ] All v0.4.x code compiles against v0.6.0
- [ ] All v0.4.x tests pass against v0.6.0
- [ ] No deprecation warnings for v0.4.x usage

## Appendix: Full API Surface

### Template Module
```rust
mod template {
    pub struct TemplateRenderer;
    pub struct TemplateContext;
    pub struct DeterminismConfig;

    pub fn is_template(content: &str) -> bool;

    pub mod functions {
        pub fn register_functions(tera: &mut Tera) -> Result<()>;
    }
}
```

### Validation Module
```rust
mod validation {
    pub mod otel {
        pub struct OtelValidator;
        pub struct OtelValidationConfig;
        pub struct SpanAssertion;
        pub struct TraceAssertion;
        pub struct SpanValidationResult;
        pub struct TraceValidationResult;
        pub struct InMemorySpanCollector;

        pub fn setup_otel_for_testing() -> Result<(OtelGuard, Arc<InMemorySpanCollector>)>;
    }
}
```

### Error Module
```rust
mod error {
    pub struct CleanroomError;
    pub enum ErrorKind;
    pub type Result<T> = std::result::Result<T, CleanroomError>;
}
```

### Config Module
```rust
mod config {
    pub struct TestConfig;
    pub struct StepConfig;
    pub struct ServiceConfig;

    pub fn load_config_from_file(path: &Path) -> Result<TestConfig>;
    pub fn parse_toml_config(content: &str) -> Result<TestConfig>;
}
```

## Compliance Checklist

- [x] All interfaces documented with examples
- [x] All methods have `# Returns`, `# Errors`, `# Examples` sections
- [x] No breaking changes from v0.4.x
- [x] All public types implement appropriate traits (Debug, Clone, etc.)
- [x] Error handling follows core team standards
- [x] Sync methods only (no async in traits)
- [x] Thread-safe where applicable (Send + Sync)
