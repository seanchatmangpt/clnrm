# v0.7.0 DX Agent Instructions

**Version**: v0.7.0
**Date**: 2025-10-17
**Coordination Plan**: `/Users/sac/clnrm/docs/architecture/v0.7.0-dx-swarm-coordination-plan.md`

---

## All Agents: Read This First

### Project Context

You are working on **clnrm v0.7.0** - a DX-first release for the Cleanroom Testing Framework. Your mission is to implement developer experience features that enable a fast author→run→debug loop.

**Core Principles**:
- **80/20 Focus**: Prioritize features that deliver maximum value
- **London TDD**: Write tests first, implement minimum code, refactor
- **No `.unwrap()`**: Proper error handling with `Result<T, CleanroomError>`
- **OTEL Integration**: Use existing telemetry infrastructure
- **Tera Templates**: Build on existing template system

**Current State**:
- Workspace root: `/Users/sac/clnrm`
- Current version: `0.6.0` (workspace-level)
- Tera templates: **Partially implemented** (see `src/template/`)
- OTEL: **Production-ready** (see `src/telemetry/`)
- Determinism: **Implemented** (see `src/template/determinism.rs`)

### Mandatory Reading

Before starting, read these files:
1. `/Users/sac/clnrm/CLAUDE.md` - Project standards and architecture
2. `/Users/sac/clnrm/docs/architecture/v0.7.0-dx-swarm-coordination-plan.md` - Your coordination plan
3. `/Users/sac/clnrm/crates/clnrm-core/src/lib.rs` - Core library structure

### London TDD Protocol (MANDATORY)

Every feature MUST follow this cycle:

1. **Red**: Write failing test
2. **Green**: Implement minimum code to pass
3. **Refactor**: Improve without changing behavior
4. **Repeat**: Next test

**Example**:
```rust
// 1. RED - Test first
#[tokio::test]
async fn test_file_watcher_detects_changes() -> Result<()> {
    let watcher = FileWatcher::new()?;
    watcher.watch("test.toml")?;
    modify_file("test.toml")?;
    assert!(watcher.has_events());
    Ok(())
}

// 2. GREEN - Minimum implementation
pub struct FileWatcher {
    // Just enough to pass test
}

// 3. REFACTOR - Improve code quality
pub struct FileWatcher {
    watcher: notify::RecommendedWatcher,
    events: Arc<Mutex<Vec<Event>>>,
}
```

### Coordination Protocol

**Before starting work**:
```bash
npx claude-flow@alpha hooks pre-task --description "Your task description"
```

**After completing work**:
```bash
npx claude-flow@alpha hooks post-edit --file "path/to/file.rs" --memory-key "swarm/your-namespace/key"
npx claude-flow@alpha hooks post-task --task-id "your-task-id"
```

**Store shared artifacts**:
```bash
npx claude-flow@alpha memory store "swarm/shared/your-artifact" --value "{ ... }"
```

---

## Sub-Coordinator Alpha: Hot Reload Team

### Team Members

1. **Dev Watch Worker** (Agent ID: alpha-dev-watch)
2. **Reload Test Worker** (Agent ID: alpha-reload-test)
3. **Watch Doc Worker** (Agent ID: alpha-watch-doc)

### Mission

Implement `clnrm dev --watch` with <3s hot reload latency

---

## Agent: Dev Watch Worker (alpha-dev-watch)

**Type**: `coder`
**Priority**: CRITICAL
**Estimated Time**: 2-3 days

### Your Task

Implement file watcher system that detects changes to `.clnrm.toml` and `.clnrm.toml.tera` files, triggers incremental reloads with <3s latency.

### Deliverables

1. **`/Users/sac/clnrm/crates/clnrm-core/src/watcher/mod.rs`**
   - File watcher abstraction using `notify` crate
   - Cross-platform compatibility (macOS, Linux, Windows)
   - Event filtering and debouncing

2. **`/Users/sac/clnrm/crates/clnrm-core/src/watcher/reload_manager.rs`**
   - Hot reload orchestration
   - Incremental template re-rendering
   - Error recovery during reload

3. **`/Users/sac/clnrm/crates/clnrm/src/cli/commands/dev.rs`**
   - `clnrm dev --watch` CLI command
   - Integration with watcher and reload manager
   - Graceful shutdown on Ctrl+C

### Implementation Plan

#### Phase 1: File Watcher (Day 1)

**Test First** (London TDD):
```rust
// tests/watcher/file_watcher_test.rs
#[tokio::test]
async fn test_watcher_detects_toml_changes() -> Result<()> {
    // Arrange
    let (tx, mut rx) = tokio::sync::mpsc::channel(100);
    let watcher = FileWatcher::new(tx)?;
    let temp_file = create_temp_toml_file()?;

    // Act
    watcher.watch(temp_file.path())?;
    modify_file(temp_file.path())?;

    // Assert
    let event = tokio::time::timeout(
        Duration::from_secs(1),
        rx.recv()
    ).await??;
    assert_matches!(event, WatchEvent::Modified(_));
    Ok(())
}
```

**Implementation**:
```rust
// src/watcher/mod.rs
use notify::{Watcher, RecommendedWatcher, RecursiveMode, Result as NotifyResult};
use tokio::sync::mpsc::Sender;
use std::path::Path;

pub enum WatchEvent {
    Created(PathBuf),
    Modified(PathBuf),
    Deleted(PathBuf),
}

pub struct FileWatcher {
    watcher: RecommendedWatcher,
    tx: Sender<WatchEvent>,
}

impl FileWatcher {
    pub fn new(tx: Sender<WatchEvent>) -> Result<Self> {
        let tx_clone = tx.clone();
        let watcher = notify::recommended_watcher(move |res: NotifyResult<notify::Event>| {
            if let Ok(event) = res {
                // Convert notify::Event to WatchEvent
                if let Some(watch_event) = Self::convert_event(event) {
                    let _ = tx_clone.try_send(watch_event);
                }
            }
        })?;

        Ok(Self { watcher, tx })
    }

    pub fn watch(&mut self, path: &Path) -> Result<()> {
        self.watcher.watch(path, RecursiveMode::NonRecursive)
            .map_err(|e| CleanroomError::internal_error(format!("Watch failed: {}", e)))
    }

    fn convert_event(event: notify::Event) -> Option<WatchEvent> {
        // Filter for .clnrm.toml and .clnrm.toml.tera files
        // Debounce rapid-fire events
        todo!("Implement event conversion with debouncing")
    }
}
```

#### Phase 2: Reload Manager (Day 2)

**Test First**:
```rust
#[tokio::test]
async fn test_reload_manager_triggers_on_change() -> Result<()> {
    let manager = ReloadManager::new("test.toml")?;
    let result = manager.reload_on_change().await?;
    assert!(result.success);
    assert!(result.duration_ms < 3000); // <3s latency
    Ok(())
}
```

**Implementation**:
```rust
// src/watcher/reload_manager.rs
use crate::template::TemplateRenderer;
use crate::config::load_config_from_file;
use std::time::Instant;

pub struct ReloadManager {
    config_path: PathBuf,
    last_hash: Option<String>,
}

impl ReloadManager {
    pub async fn reload_on_change(&mut self) -> Result<ReloadResult> {
        let start = Instant::now();

        // 1. Check if file actually changed (hash comparison)
        if !self.file_changed()? {
            return Ok(ReloadResult::no_change());
        }

        // 2. Re-render template if .tera file
        let rendered = if self.is_template_file() {
            self.render_template()?
        } else {
            std::fs::read_to_string(&self.config_path)?
        };

        // 3. Parse and validate TOML
        let config = parse_toml_config(&rendered)?;
        config.validate()?;

        // 4. Return result with timing
        let duration = start.elapsed();
        Ok(ReloadResult {
            success: true,
            duration_ms: duration.as_millis() as u64,
            message: format!("Reloaded in {}ms", duration.as_millis()),
        })
    }
}
```

#### Phase 3: CLI Integration (Day 3)

**Test First**:
```rust
#[tokio::test]
async fn test_dev_watch_command_runs() -> Result<()> {
    let output = Command::new("cargo")
        .args(&["run", "--", "dev", "--watch", "test.toml"])
        .output()?;
    assert!(output.status.success());
    Ok(())
}
```

**Implementation**:
```rust
// src/cli/commands/dev.rs
use clap::Args;

#[derive(Args, Debug)]
pub struct DevArgs {
    /// Path to test configuration file
    path: PathBuf,

    /// Watch for file changes and hot reload
    #[arg(long, short)]
    watch: bool,
}

pub async fn dev_command(args: DevArgs) -> Result<()> {
    if !args.watch {
        return Err(CleanroomError::invalid_input(
            "dev command requires --watch flag"
        ));
    }

    info!("Starting dev mode with hot reload for {:?}", args.path);

    let (tx, mut rx) = tokio::sync::mpsc::channel(100);
    let mut watcher = FileWatcher::new(tx)?;
    watcher.watch(&args.path)?;

    let mut reload_manager = ReloadManager::new(args.path.clone())?;

    // Initial load
    reload_manager.reload_on_change().await?;

    // Watch loop
    loop {
        tokio::select! {
            Some(event) = rx.recv() => {
                match event {
                    WatchEvent::Modified(path) => {
                        info!("File changed: {:?}, reloading...", path);
                        match reload_manager.reload_on_change().await {
                            Ok(result) => {
                                info!("✅ {}", result.message);
                            }
                            Err(e) => {
                                error!("❌ Reload failed: {}", e);
                            }
                        }
                    }
                    _ => {}
                }
            }
            _ = tokio::signal::ctrl_c() => {
                info!("Shutting down watch mode...");
                break;
            }
        }
    }

    Ok(())
}
```

### Testing Strategy

1. **Unit tests**: File watcher event handling
2. **Integration tests**: Full reload cycle
3. **Benchmarks**: Latency measurement (<3s target)
4. **Property tests**: Random file modifications

### Performance Requirements

- **Debounce window**: <100ms
- **Reload latency**: <3000ms (target: <2000ms)
- **Memory overhead**: <10MB for watcher

### Coordination

**Store artifacts**:
```bash
npx claude-flow@alpha memory store "swarm/alpha/file-watcher-api" --value '{
  "watch": "fn watch(&mut self, path: &Path) -> Result<()>",
  "events": "channel<WatchEvent>"
}'
```

**Notify completion**:
```bash
npx claude-flow@alpha hooks notify --message "✅ Dev Watch Worker: File watcher implemented, <3s reload achieved"
```

---

## Agent: Reload Test Worker (alpha-reload-test)

**Type**: `tester`
**Priority**: CRITICAL
**Estimated Time**: 1 day

### Your Task

Create comprehensive test suite for hot reload system with property-based tests and benchmarks.

### Deliverables

1. **`/Users/sac/clnrm/crates/clnrm-core/tests/watcher/file_watcher_test.rs`**
2. **`/Users/sac/clnrm/crates/clnrm-core/tests/integration/hot_reload_test.rs`**
3. **`/Users/sac/clnrm/crates/clnrm-core/benches/reload_latency_bench.rs`**

### Test Categories

#### 1. Unit Tests (file_watcher_test.rs)

```rust
#[tokio::test]
async fn test_debouncing_prevents_duplicate_events() -> Result<()> {
    // Arrange
    let (tx, mut rx) = channel(100);
    let mut watcher = FileWatcher::new(tx)?;
    let file = create_temp_file()?;

    // Act - Rapid modifications
    watcher.watch(file.path())?;
    for _ in 0..10 {
        modify_file(file.path())?;
        tokio::time::sleep(Duration::from_millis(10)).await;
    }

    // Assert - Should receive 1 debounced event
    let events = collect_events(&mut rx, Duration::from_millis(500)).await;
    assert_eq!(events.len(), 1);
    Ok(())
}
```

#### 2. Integration Tests (hot_reload_test.rs)

```rust
#[tokio::test]
async fn test_full_reload_cycle_with_template() -> Result<()> {
    // Arrange
    let template = r#"
[test.metadata]
name = "hot_reload_test_{{ fake_uuid() }}"

[[steps]]
name = "step1"
command = ["echo", "test"]
"#;
    let file = create_temp_tera_file(template)?;
    let mut manager = ReloadManager::new(file.path())?;

    // Act
    let result = manager.reload_on_change().await?;

    // Assert
    assert!(result.success);
    assert!(result.duration_ms < 3000);
    Ok(())
}
```

#### 3. Benchmarks (reload_latency_bench.rs)

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_reload_simple_toml(c: &mut Criterion) {
    c.bench_function("reload_simple_toml", |b| {
        let manager = ReloadManager::new("simple.toml").unwrap();
        b.iter(|| {
            black_box(manager.reload_on_change())
        });
    });
}

fn bench_reload_template_100_steps(c: &mut Criterion) {
    c.bench_function("reload_template_100_steps", |b| {
        let manager = ReloadManager::new("template_100.toml.tera").unwrap();
        b.iter(|| {
            black_box(manager.reload_on_change())
        });
    });
}
```

### Coordination

**Retrieve API from Dev Watch Worker**:
```bash
npx claude-flow@alpha memory retrieve "swarm/alpha/file-watcher-api"
```

---

## Agent: Watch Doc Worker (alpha-watch-doc)

**Type**: `api-docs`
**Priority**: HIGH
**Estimated Time**: 0.5 day

### Your Task

Document `clnrm dev --watch` usage and create quick start guide.

### Deliverables

1. **`/Users/sac/clnrm/docs/CLI_GUIDE.md`** - Update with dev command
2. **`/Users/sac/clnrm/docs/quickstart/hot-reload-tutorial.md`** - New tutorial

### Content Template

```markdown
## clnrm dev --watch

**Purpose**: Fast author→run→debug loop with automatic hot reload

**Usage**:
\`\`\`bash
clnrm dev --watch tests/my-test.clnrm.toml
\`\`\`

**Features**:
- Automatic reload on file changes
- <3s reload latency
- Template re-rendering on .tera file changes
- Clear error messages in watch mode
- Graceful Ctrl+C shutdown

**Example Session**:
\`\`\`bash
$ clnrm dev --watch tests/api-test.toml
[INFO] Starting dev mode with hot reload...
[INFO] Watching: tests/api-test.toml
✅ Initial load successful (1.2s)

# Edit file in another terminal
# Save changes

[INFO] File changed, reloading...
✅ Reloaded in 850ms
\`\`\`
```

---

## Sub-Coordinator Beta: DX Tooling Team

*(Similar detailed instructions for Dry-Run, Fmt, and Lint workers)*

---

## Sub-Coordinator Gamma: Diff & Macros Team

*(Similar detailed instructions for Diff, Macro Pack, and Integration workers)*

---

## Coordination Checklist

Before submitting your work, ensure:

- [ ] All tests pass (`cargo test`)
- [ ] No `.unwrap()` in production code
- [ ] `cargo clippy -- -D warnings` passes
- [ ] Documentation updated
- [ ] Artifacts stored in shared memory
- [ ] Notification sent to coordinator

---

**Document Status**: ✅ AGENT INSTRUCTIONS READY
**Version**: v0.7.0-alpha
**Last Updated**: 2025-10-17
