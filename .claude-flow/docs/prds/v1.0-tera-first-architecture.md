You implement precedence and no-prefix vars in **Rust** and render with **Tera**. ENV is ingested in Rust, then injected into the template context. Templates reference plain `{{ svc }}`, `{{ endpoint }}`, etc. No prelude file needed.

## Cargo

```toml
# Cargo.toml
[dependencies]
tera = "1.19"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
chrono = { version = "0.4", features = ["serde"] }
toml = "0.8"
```

## Resolver + Tera setup (happy path)

```rust
use std::{collections::HashMap, env};
use tera::{Context, Tera, Value, Result as TeraResult, Function};

// -------- precedence helpers: template vars > ENV > default --------
fn pick(vars: &HashMap<String,String>, key: &str, env_key: &str, default_: &str) -> String {
    vars.get(key)
        .cloned()
        .or_else(|| env::var(env_key).ok())
        .unwrap_or_else(|| default_.to_string())
}

fn resolve(vars: HashMap<String,String>) -> HashMap<String,String> {
    let mut out = HashMap::new();
    out.insert("svc".into(),          pick(&vars, "svc",          "SERVICE_NAME",        "clnrm"));
    out.insert("env".into(),          pick(&vars, "env",          "ENV",                 "ci"));
    out.insert("endpoint".into(),     pick(&vars, "endpoint",     "OTEL_ENDPOINT",       "http://localhost:4318"));
    out.insert("exporter".into(),     pick(&vars, "exporter",     "OTEL_TRACES_EXPORTER","otlp"));
    out.insert("image".into(),        pick(&vars, "image",        "CLNRM_IMAGE",         "registry/clnrm:1.0.0"));
    out.insert("freeze_clock".into(), pick(&vars, "freeze_clock", "FREEZE_CLOCK",        "2025-01-01T00:00:00Z"));
    out.insert("token".into(),        pick(&vars, "token",        "OTEL_TOKEN",          ""));
    out
}

// -------- optional: tera function env(name) --------
struct EnvFn;
impl Function for EnvFn {
    fn call(&self, args: &HashMap<String, Value>) -> TeraResult<Value> {
        let k = args.get("name").and_then(|v| v.as_str()).unwrap_or("");
        Ok(Value::String(env::var(k).unwrap_or_default()))
    }
}

// -------- render entrypoint --------
fn render_template(template_glob: &str, template_name: &str, user_vars: HashMap<String,String>) -> String {
    let resolved = resolve(user_vars);

    // Tera with built-ins
    let mut tera = Tera::new(template_glob).unwrap();
    tera.register_function("env", EnvFn); // optional; precedence is already handled in Rust

    // Context: top-level keys (no prefix) + nested [vars] for authoring
    let mut ctx = Context::new();
    for (k, v) in &resolved { ctx.insert(k, v); }    // svc, env, endpoint, exporter, image, freeze_clock, token
    ctx.insert("vars", &resolved);                   // will render a [vars] block if template emits it

    tera.render(template_name, &ctx).unwrap()
}

// -------- example usage --------
fn main() {
    // e.g., collected from CLI flags or a small file; empty means ENV/defaults win
    let user_vars: HashMap<String,String> = HashMap::new();

    let rendered = render_template("tests/**/*.clnrm.toml.tera",
                                   "tests/otel.clnrm.toml.tera",
                                   user_vars);

    // rendered now contains flat TOML; pass to your TOML parser next
    println!("{}", rendered);
}
```

## Template (no prefixes, ENV already ingested in Rust)

```toml
# tests/otel.clnrm.toml.tera
[meta]
name="{{ svc }}_otel_proof"
version="1.0"
description="Telemetry-only"

[vars]                # authoring-only; runtime ignores this table
svc="{{ svc }}"
env="{{ env }}"
endpoint="{{ endpoint }}"
exporter="{{ exporter }}"
freeze_clock="{{ freeze_clock }}"
image="{{ image }}"

[otel]
exporter="{{ exporter }}"
endpoint="{{ endpoint }}"
protocol="http/protobuf"
sample_ratio=1.0
resources={ "service.name"="{{ svc }}","env"="{{ env }}" }

[otel.headers]
{% if token != "" %}Authorization="Bearer {{ token }}"{% endif %}

[service.clnrm]
plugin="generic_container"
image="{{ image }}"
args=["self-test","--otel-exporter","{{ exporter }}","--otel-endpoint","{{ endpoint }}"]
env={ "OTEL_TRACES_EXPORTER"="{{ exporter }}","OTEL_EXPORTER_OTLP_ENDPOINT"="{{ endpoint }}" }
wait_for_span="clnrm.run"

[[scenario]]
name="otel_only_proof"
service="clnrm"
run="clnrm run --otel-exporter {{ exporter }} --otel-endpoint {{ endpoint }}"
artifacts.collect=["spans:default"]

[[expect.span]]
name="clnrm.run"
kind="internal"
attrs.all={ "result"="pass" }

[[expect.span]]
name="clnrm.step:hello_world"
parent="clnrm.run"
kind="internal"
events.any=["container.start","container.exec","container.stop"]

[expect.graph]
must_include=[["clnrm.run","clnrm.step:hello_world"]]
acyclic=true

[expect.status]
all="OK"

[expect.hermeticity]
no_external_services=true
resource_attrs.must_match={ "service.name"="{{ svc }}","env"="{{ env }}" }

[determinism]
seed=42
freeze_clock="{{ freeze_clock }}"

[report]
json="report.json"
digest="trace.sha256"
```

## Notes

* Precedence is resolved in Rust. Templates stay clean.
* ENV is available both via the resolver and, optionally, `{{ env(name="OTEL_ENDPOINT") }}`.
* The `[vars]` table renders for readability but is ignored at runtime.


v1.0 PRD — clnrm (Tera-first, flat TOML, OTEL-only) with no-prefix vars and ENV ingestion

## Summary

Render Tera → flat TOML → hermetic run → collect OTEL spans → normalize → analyze invariants → verdict + digest. DX first. Deterministic by default. `[vars]` exists for authors and tools, ignored at runtime. Template variables have no prefixes; Rust injects resolved values into the Tera context.

## Goals

* First green <60 s.
* Edit→rerun p95 ≤3 s (template).
* Stable schema, CLI, JSON for 1.x.
* macOS/Linux. Docker or Podman.
* Happy path. No error handling in templates or generators.

## Non-Goals

Enterprise policy, signatures, GUIs/TUIs, AI features, Windows polish.

## Architecture

1. **Resolve inputs (Rust):** precedence `template vars.* → ENV → default`.
2. **Render (Tera):** no prefixes, plain `{{ svc }}` etc.
3. **Parse TOML:** flat, may include `[vars]`.
4. **Execute:** fresh container per scenario.
5. **Collect spans:** stdout or OTLP.
6. **Normalize:** stable JSON.
7. **Analyze:** expectations → pass/fail.
8. **Report:** console + optional JSON/JUnit + digest.

## Tera + Rust variable model (no prefixes)

* **Resolved keys injected at top level:** `svc, env, endpoint, exporter, image, freeze_clock, token`.
* **Optional nested `vars` map** mirrors resolved keys for authoring.
* **Tera `env()` function** optional; precedence already handled in Rust.

### Rust (happy path)

```rust
use std::{collections::HashMap, env};
use tera::{Tera, Context, Function, Value, Result as TeraResult};

fn pick(v:&HashMap<String,String>, k:&str, e:&str, d:&str)->String{
    v.get(k).cloned().or_else(|| env::var(e).ok()).unwrap_or_else(|| d.to_string())
}
fn resolve(mut user:HashMap<String,String>)->HashMap<String,String>{
    let mut o=HashMap::new();
    o.insert("svc".into(),          pick(&user,"svc","SERVICE_NAME","clnrm"));
    o.insert("env".into(),          pick(&user,"env","ENV","ci"));
    o.insert("endpoint".into(),     pick(&user,"endpoint","OTEL_ENDPOINT","http://localhost:4318"));
    o.insert("exporter".into(),     pick(&user,"exporter","OTEL_TRACES_EXPORTER","otlp"));
    o.insert("image".into(),        pick(&user,"image","CLNRM_IMAGE","registry/clnrm:1.0.0"));
    o.insert("freeze_clock".into(), pick(&user,"freeze_clock","FREEZE_CLOCK","2025-01-01T00:00:00Z"));
    o.insert("token".into(),        pick(&user,"token","OTEL_TOKEN",""));
    o
}
struct EnvFn;
impl Function for EnvFn{
    fn call(&self, a:&HashMap<String,Value>)->TeraResult<Value>{
        Ok(Value::String(env::var(a.get("name").and_then(|v|v.as_str()).unwrap_or("")).unwrap_or_default()))
    }
}
fn render(glob:&str, name:&str, user_vars:HashMap<String,String>)->String{
    let r=resolve(user_vars);
    let mut t=Tera::new(glob).unwrap();
    t.register_function("env",EnvFn);
    let mut c=Context::new();
    for (k,v) in &r { c.insert(k,v); }
    c.insert("vars",&r);
    t.render(name,&c).unwrap()
}
```

## Rendered TOML schema (authoritative, flat)

**Required**

```toml
[meta]                  # name, version, description
[otel]                  # exporter("stdout"|"otlp"), endpoint?, protocol?, sample_ratio, resources={...}
[service.<id>]          # plugin="generic_container", image, args=[...], env={...}, wait_for_span="..."
[[scenario]]            # name, service, run, artifacts.collect=["spans:<handle>"]
```

**Optional**

```toml
[[expect.span]]         # name, parent?, kind, attrs.all={}, attrs.any=[], events.any=[], duration_ms={min,max}
[expect.graph]          # must_include=[["p","c"],...], must_not_cross=[["a","b"],...], acyclic=true
[expect.counts]         # spans_total={}, events_total={}, errors_total={}, by_name={ "span"={eq|gte|lte:N} }
[[expect.window]]       # outer="root", contains=["childA","childB"]
[expect.order]          # must_precede=[["A","B"]], must_follow=[["C","D"]]
[expect.status]         # all="OK", by_name={ "glob"="OK" }
[expect.hermeticity]    # no_external_services=true, resource_attrs.must_match={...}, span_attrs.forbid_keys=[...]
[otel.headers]          # k="v"
[otel.propagators]      # use=["tracecontext","baggage"]
[limits]                # cpu_millicores, memory_mb
[determinism]           # seed, freeze_clock
[report]                # json="report.json", junit?, digest="trace.sha256"
```

**Authoring-only**

```toml
[vars]                  # flat key→string; ignored at runtime
svc="clnrm" ; env="ci" ; endpoint="http://localhost:4318" ; exporter="otlp"
freeze_clock="2025-01-01T00:00:00Z" ; image="registry/clnrm:1.0.0"
```

Rules: flat tables only; inline arrays/tables; unknown keys ignored.

## Minimal template (no prefixes)

```toml
[meta]
name="{{ svc }}_otel_proof"
version="1.0"
description="Telemetry-only"

[vars]
svc="{{ svc }}" ; env="{{ env }}" ; endpoint="{{ endpoint }}" ; exporter="{{ exporter }}"
freeze_clock="{{ freeze_clock }}" ; image="{{ image }}"

[otel]
exporter="{{ exporter }}"
endpoint="{{ endpoint }}"
protocol="http/protobuf"
sample_ratio=1.0
resources={ "service.name"="{{ svc }}","env"="{{ env }}" }

[otel.headers]
{% if token != "" %}Authorization="Bearer {{ token }}"{% endif %}

[service.clnrm]
plugin="generic_container"
image="{{ image }}"
args=["self-test","--otel-exporter","{{ exporter }}","--otel-endpoint","{{ endpoint }}"]
env={ "OTEL_TRACES_EXPORTER"="{{ exporter }}","OTEL_EXPORTER_OTLP_ENDPOINT"="{{ endpoint }}" }
wait_for_span="clnrm.run"

[[scenario]]
name="otel_only_proof"
service="clnrm"
run="clnrm run --otel-exporter {{ exporter }} --otel-endpoint {{ endpoint }}"
artifacts.collect=["spans:default"]

[[expect.span]]
name="clnrm.run" ; kind="internal" ; attrs.all={ "result"="pass" }

[[expect.span]]
name="clnrm.step:hello_world" ; parent="clnrm.run" ; kind="internal"
events.any=["container.start","container.exec","container.stop"]

[expect.graph]
must_include=[["clnrm.run","clnrm.step:hello_world"]] ; acyclic=true

[expect.status]
all="OK"

[expect.hermeticity]
no_external_services=true
resource_attrs.must_match={ "service.name"="{{ svc }}","env"="{{ env }}" }

[determinism]
seed=42
freeze_clock="{{ freeze_clock }}"

[report]
json="report.json" ; digest="trace.sha256"
```

## CLI (happy path)

* `clnrm template otel`
* `clnrm dev --watch [--workers N] [--only <file>::<scenario>] [--timebox ms]`
* `clnrm dry-run`
* `clnrm run [--workers N]`  (change-aware by default)
* `clnrm pull`
* `clnrm diff [--json]`
* `clnrm graph --ascii`
* `clnrm record`
* `clnrm repro`
* `clnrm redgreen`
* `clnrm fmt`
* `clnrm lint`
* `clnrm render --map`
* `clnrm spans --grep '<expr>'`
* `clnrm up collector` / `clnrm down`

## Determinism + normalization

* Defaults: `seed=42`, `freeze_clock` from resolved inputs.
* Normalize: sort spans by `(trace_id, span_id)`; sort attributes/events; strip volatile fields.
* Digest: SHA-256 over normalized JSON; write to `report.digest` path if set.

## Change-aware runs

* Stable hash per scenario from rendered section.
* Only changed scenarios run; dependent scenarios may be re-run.

## Output

* PASS: `PASS in 1.42s (spans=23, digest=abc123…)`
* FAIL (focused):

  ```
  FAIL expect.graph.must_include [clnrm.run → clnrm.step:hello_world]
  ├─ found: clnrm.run
  └─ missing child span: clnrm.step:hello_world
  ```
* `--json`:

```json
{"spec_hash":"…","digest":"…","verdict":"fail","first_failure":{"rule":"expect.graph.must_include","spans":["clnrm.run","clnrm.step:hello_world"]},"counts":{"spans":23,"events":7}}
```

## Performance targets

* Template cold run ≤5 s.
* Edit→rerun p50 ≤1.5 s, p95 ≤3 s.
* Suite time ↓30–50% vs 0.6 (change-aware + workers).

## Acceptance criteria (DoD)

* Tera→TOML→exec→OTEL→normalize→analyze→report works for stdout and OTLP.
* No-prefix vars resolved in Rust; ENV ingested; `[vars]` present and ignored at runtime.
* `dev --watch` prints first failing invariant; hot loop stable.
* `dry-run` catches schema issues.
* `fmt` idempotent; sorts keys; preserves flatness; `[vars]` sorted.
* `lint` flags missing required keys, orphan services/scenarios, bad enums.
* `run` is change-aware; `--workers` parallelizes scenarios.
* `diff` one-screen deltas; `graph --ascii` highlights missing edges.
* `record/repro/redgreen` yield identical digests on repeat runs.
* Local collector `up/down` works with defaults.

## Metrics

Time to first green, edit→rerun latency, percent scenarios skipped, digest stability, image cache hit rate.

## Out of scope (post-v1)

`learn` from trace, coverage, graph TUI/SVG, export/import bundles, snapshot reuse v2, Windows polish.

