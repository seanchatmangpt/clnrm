# Cleanroom Testing Framework v0.7.0 - System Architecture Design

**Document Version:** 1.0
**Date:** 2025-10-16
**Status:** Draft
**Architect:** Claude Code System Architecture Designer

## Executive Summary

This document describes the comprehensive system architecture for Cleanroom Testing Framework v0.7.0, focusing on the Tera-first, OTEL-centric hermetic testing platform. The architecture follows FAANG-level core team standards with zero-tolerance error handling, sync-first trait design, and modular component boundaries.

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture Principles](#architecture-principles)
3. [Component Architecture](#component-architecture)
4. [Data Flow Architecture](#data-flow-architecture)
5. [Module Design](#module-design)
6. [Error Handling Strategy](#error-handling-strategy)
7. [Testing Strategy](#testing-strategy)
8. [Performance Targets](#performance-targets)
9. [Security & Hermeticity](#security--hermeticity)
10. [Technology Decisions](#technology-decisions)

---

## 1. System Overview

### 1.1 Purpose

Cleanroom Testing Framework provides hermetic, deterministic integration testing through container-based isolation with first-class OpenTelemetry observability. The framework tests itself using its own capabilities (dogfooding).

### 1.2 Quality Attributes (Priority Order)

1. **Correctness** - Zero false positives, deterministic execution
2. **Hermeticity** - Complete test isolation, reproducible results
3. **Observability** - Built-in OTEL tracing, metrics, logs
4. **Performance** - Sub-second hot reload, parallel execution
5. **Developer Experience** - Simple TOML DSL, comprehensive errors
6. **Maintainability** - Modular design, <500 lines per file

### 1.3 System Context

```
┌─────────────────────────────────────────────────────────────────┐
│                      Cleanroom Testing Framework                │
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐ │
│  │   CLI    │───▶│ Template │───▶│ Runtime  │───▶│  OTEL    │ │
│  │ Interface│    │ Renderer │    │ Executor │    │Collector │ │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘ │
│       │               │                │               │        │
│       ▼               ▼                ▼               ▼        │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │            Container Backend (Docker/Podman)             │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
         │                      │                      │
         ▼                      ▼                      ▼
    User Input             Test Services          OTEL Backends
    (TOML/Tera)           (SurrealDB, etc)      (Jaeger, DataDog)
```

---

## 2. Architecture Principles

### 2.1 Core Team Standards (MANDATORY)

#### Error Handling
- **NEVER** use `.unwrap()` or `.expect()` in production code
- All functions return `Result<T, CleanroomError>` with meaningful messages
- Error chaining with context using `.with_context()`
- Structured error types with timestamp, kind, message, context

```rust
// ❌ FORBIDDEN
let result = operation().unwrap();

// ✅ REQUIRED
let result = operation().map_err(|e| {
    CleanroomError::internal_error(format!("Operation failed: {}", e))
        .with_context("During template rendering")
})?;
```

#### Async/Sync Rules
- **NEVER** make trait methods async (breaks `dyn` compatibility)
- Traits use sync methods with internal `tokio::task::block_in_place`
- Async for I/O operations (containers, network, file system)
- Sync for computation (parsing, validation, formatting)

```rust
// ❌ FORBIDDEN - breaks dyn compatibility
pub trait ServicePlugin {
    async fn start(&self) -> Result<ServiceHandle>;
}

// ✅ REQUIRED - dyn compatible
pub trait ServicePlugin {
    fn start(&self) -> Result<ServiceHandle>; // Use block_in_place internally
}
```

#### Testing Standards
- AAA pattern: Arrange, Act, Assert
- Descriptive test names: `test_<component>_<scenario>_<expected_result>`
- No `println!` in production code (use `tracing` macros)
- No fake `Ok(())` - use `unimplemented!()` for incomplete features

### 2.2 Architectural Constraints

1. **Modular Design** - Files under 500 lines, clear module boundaries
2. **Workspace Isolation** - Experimental features (AI) isolated in separate crates
3. **Hermetic Execution** - Each test runs in fresh container environment
4. **Deterministic by Default** - Seeded RNG, frozen clock, stable ordering
5. **Observable by Default** - OTEL tracing/metrics/logs built-in

---

## 3. Component Architecture

### 3.1 High-Level Component Diagram

```
┌───────────────────────────────────────────────────────────────────────┐
│                          CLI Layer (clnrm crate)                      │
├───────────────────────────────────────────────────────────────────────┤
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐ │
│  │ template │  │   dev    │  │   run    │  │  record  │  │  fmt   │ │
│  │ command  │  │ command  │  │ command  │  │ command  │  │command │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  └────────┘ │
└────────────────────────────┬──────────────────────────────────────────┘
                             │
┌────────────────────────────▼──────────────────────────────────────────┐
│                     Core Library (clnrm-core crate)                   │
├───────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                    Template System                              │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │ │
│  │  │ Tera Engine  │  │   Context    │  │  Functions   │         │ │
│  │  │  Renderer    │  │  Resolver    │  │  (env, sha)  │         │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                   Configuration System                          │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │ │
│  │  │ TOML Parser  │  │   Schema     │  │  Validation  │         │ │
│  │  │  (v0.6/v0.7) │  │  Validator   │  │   Engine     │         │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                    Execution Engine                             │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │ │
│  │  │  Scenario    │  │   Service    │  │  Container   │         │ │
│  │  │  Orchestrator│  │   Manager    │  │   Backend    │         │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                  Validation & Reporting                         │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │ │
│  │  │    OTEL      │  │   Assertion  │  │   Report     │         │ │
│  │  │  Validator   │  │   Engine     │  │  Generator   │         │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                      Support Systems                            │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │ │
│  │  │    Cache     │  │    Watch     │  │  Telemetry   │         │ │
│  │  │   Manager    │  │   System     │  │   (OTEL)     │         │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘         │ │
│  └─────────────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────────┘
```

### 3.2 Component Responsibilities

#### Template System
**Purpose:** Render Tera templates to flat TOML with variable resolution

**Modules:**
- `template::mod` - Template renderer with Tera engine
- `template::context` - Context builder with precedence resolution
- `template::functions` - Custom Tera functions (env, sha256, toml)
- `template::determinism` - Deterministic seed and clock configuration

**Key Responsibilities:**
- Resolve variables with precedence: template vars → ENV → defaults
- Register custom Tera functions for ENV access, hashing, TOML encoding
- Load and apply macro library for common patterns
- Render templates to flat TOML without nested structures

**Error Handling:**
- `CleanroomError::template_error` for rendering failures
- Context errors with line numbers and template names
- No `.unwrap()` on Tera operations

#### Configuration System
**Purpose:** Parse and validate TOML test definitions

**Modules:**
- `config::mod` - Main configuration structures
- `validation::shape` - Schema validation for v0.6/v0.7 formats
- `validation::otel` - OTEL-specific configuration validation

**Key Responsibilities:**
- Parse flat TOML into strongly-typed structures
- Support multiple schema versions (v0.4, v0.6, v0.7)
- Validate required fields and value ranges
- Normalize configurations for execution

**Error Handling:**
- `CleanroomError::configuration_error` for parse failures
- Detailed field-level validation messages
- Type mismatch errors with expected vs actual

#### Execution Engine
**Purpose:** Orchestrate test execution in hermetic containers

**Modules:**
- `cleanroom::CleanroomEnvironment` - Main test execution context
- `scenario::scenario` - Scenario orchestration and step execution
- `services::factory` - Service plugin factory and registry
- `backend::testcontainer` - Container lifecycle management

**Key Responsibilities:**
- Create fresh container environment per test
- Manage service lifecycle (start, health check, stop)
- Execute test steps in deterministic order
- Collect OTEL telemetry during execution
- Enforce resource limits and timeouts

**Error Handling:**
- `CleanroomError::container_error` for Docker/Podman failures
- `CleanroomError::timeout_error` for exceeded limits
- Service startup errors with health check details

#### Validation & Reporting
**Purpose:** Analyze telemetry and generate test results

**Modules:**
- `validation::orchestrator` - Validation rule orchestration
- `validation::span_validator` - Span attribute validation
- `validation::graph_validator` - Trace topology validation
- `validation::hermeticity_validator` - Isolation verification
- `reporting::json` - JSON report generation
- `reporting::digest` - SHA-256 digest generation

**Key Responsibilities:**
- Validate span expectations (attributes, duration, events)
- Verify trace graph topology (parent-child, ordering)
- Check hermeticity (no external network, resource isolation)
- Generate normalized JSON for deterministic comparison
- Compute SHA-256 digest of normalized trace

**Error Handling:**
- `CleanroomError::validation_error` for assertion failures
- First-failure focus (stop at first failing invariant)
- Detailed error messages with actual vs expected

---

## 4. Data Flow Architecture

### 4.1 Template Rendering Flow

```
┌──────────────┐
│ .clnrm.toml  │
│ .tera file   │
└──────┬───────┘
       │
       ▼
┌─────────────────────────────────────┐
│ 1. Read Template File               │
│    - Check file extension (.tera)   │
│    - Detect Tera syntax ({{ }})     │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 2. Resolve Variables (Precedence)   │
│    - Template vars.*                │
│    - ENV variables                  │
│    - Default values                 │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 3. Build Tera Context                │
│    - Top-level keys (svc, env, etc) │
│    - Nested vars map for authoring  │
│    - Custom functions (env, sha256) │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 4. Render Template                   │
│    - Apply Tera substitutions       │
│    - Process control structures     │
│    - Apply macro imports            │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 5. Output Flat TOML                  │
│    - No nested structures           │
│    - [vars] preserved for authoring │
│    - Ready for TOML parser          │
└─────────┬───────────────────────────┘
          │
          ▼
   ┌────────────┐
   │ Flat TOML  │
   │ Config     │
   └────────────┘
```

### 4.2 Test Execution Flow

```
┌────────────┐
│ Flat TOML  │
│ Config     │
└─────┬──────┘
      │
      ▼
┌─────────────────────────────────────┐
│ 1. Parse TOML to TestConfig         │
│    - Deserialize with serde         │
│    - Validate schema version        │
│    - Check required fields          │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 2. Initialize Container Backend     │
│    - Connect to Docker/Podman       │
│    - Set up network isolation       │
│    - Apply resource limits          │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 3. Start Services                    │
│    - Pull required images           │
│    - Start containers in order      │
│    - Wait for health checks         │
│    - Inject ENV vars                │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 4. Execute Scenarios                 │
│    - Run commands in containers     │
│    - Collect stdout/stderr          │
│    - Capture OTEL telemetry         │
│    - Enforce timeouts               │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 5. Collect Telemetry                 │
│    - Gather spans from stdout       │
│    - Or query OTLP collector        │
│    - Normalize to stable JSON       │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 6. Validate Expectations             │
│    - Check span assertions          │
│    - Verify graph topology          │
│    - Validate hermeticity           │
│    - Compute digest                 │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 7. Generate Reports                  │
│    - Console output (PASS/FAIL)     │
│    - JSON report file               │
│    - JUnit XML (optional)           │
│    - Digest file                    │
└─────────┬───────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 8. Cleanup                           │
│    - Stop containers                │
│    - Remove volumes                 │
│    - Close connections              │
└─────────────────────────────────────┘
```

### 4.3 Change-Aware Execution Flow

```
┌────────────────┐
│ Scenario Hash  │  (computed from rendered TOML section)
└────────┬───────┘
         │
         ▼
┌───────────────────────────────────────────┐
│ Check Cache for Previous Hash             │
└────────┬──────────────────────────┬───────┘
         │                          │
    No Match                    Match Found
         │                          │
         ▼                          ▼
┌─────────────────┐        ┌─────────────────┐
│ Execute         │        │ Skip Scenario   │
│ Scenario        │        │ (use cached)    │
└────────┬────────┘        └─────────────────┘
         │
         ▼
┌─────────────────────────────────────┐
│ Store New Hash + Results in Cache   │
└─────────────────────────────────────┘
```

---

## 5. Module Design

### 5.1 Template Module (`crates/clnrm-core/src/template/`)

**Files:**
- `mod.rs` - Main renderer and template detection (150 lines)
- `context.rs` - Context builder with variable resolution (200 lines)
- `functions.rs` - Custom Tera functions registration (250 lines)
- `determinism.rs` - Deterministic config structures (100 lines)
- `_macros.toml.tera` - Reusable TOML macros (embedded at compile time)

**Public API:**
```rust
pub struct TemplateRenderer {
    tera: Tera,
    context: TemplateContext,
}

impl TemplateRenderer {
    pub fn new() -> Result<Self>;
    pub fn with_context(self, context: TemplateContext) -> Self;
    pub fn render_file(&mut self, path: &Path) -> Result<String>;
    pub fn render_str(&mut self, template: &str, name: &str) -> Result<String>;
}

pub struct TemplateContext {
    pub vars: HashMap<String, serde_json::Value>,
    pub matrix: Option<HashMap<String, Vec<String>>>,
    pub determinism: Option<DeterminismConfig>,
}

impl TemplateContext {
    pub fn new() -> Self;
    pub fn with_vars(mut self, vars: HashMap<String, serde_json::Value>) -> Self;
    pub fn resolve_with_precedence(&mut self) -> Result<()>;
    pub fn to_tera_context(&self) -> Result<tera::Context>;
}

pub fn is_template(content: &str) -> bool;
```

**Error Handling:**
- All methods return `Result<T, CleanroomError>`
- Template rendering errors include line numbers and context
- Variable resolution errors specify which variable failed

**Testing:**
- Unit tests for variable precedence resolution
- Integration tests for end-to-end rendering
- Property tests for deterministic output

### 5.2 Configuration Module (`crates/clnrm-core/src/config.rs`)

**File Structure:**
- Single file with multiple related structs (400 lines)
- Clear sections for v0.4, v0.6, v0.7 formats

**Public API:**
```rust
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TestConfig {
    pub meta: Option<MetaConfig>,
    pub otel: Option<OtelConfig>,
    pub service: Option<HashMap<String, ServiceConfig>>,
    pub scenario: Vec<ScenarioConfig>,
    pub expect: Option<ExpectationsConfig>,
    pub vars: Option<HashMap<String, serde_json::Value>>,
    pub determinism: Option<DeterminismConfig>,
    pub report: Option<ReportConfig>,
    // ... other fields
}

pub fn parse_toml_config(content: &str) -> Result<TestConfig>;
pub fn load_config_from_file(path: &Path) -> Result<TestConfig>;
pub fn load_cleanroom_config(dir: &Path) -> Result<Vec<TestConfig>>;
```

**Validation Rules:**
- Required fields: `[meta]`, at least one `[[scenario]]`
- Valid `otel.exporter` values: "stdout", "otlp"
- Service references in scenarios must exist
- Span expectations must reference defined services

### 5.3 Validation Module (`crates/clnrm-core/src/validation/`)

**Files:**
- `mod.rs` - Orchestrator and public API (150 lines)
- `otel.rs` - OTEL validator and configurations (250 lines)
- `span_validator.rs` - Span assertion validation (300 lines)
- `graph_validator.rs` - Trace topology validation (350 lines)
- `hermeticity_validator.rs` - Isolation verification (200 lines)
- `count_validator.rs` - Span/event count assertions (150 lines)
- `order_validator.rs` - Temporal ordering validation (200 lines)
- `window_validator.rs` - Parent-child containment (180 lines)
- `status_validator.rs` - Span status validation (120 lines)

**Public API:**
```rust
pub struct ValidationOrchestrator {
    config: OtelValidationConfig,
    validators: Vec<Box<dyn Validator>>,
}

impl ValidationOrchestrator {
    pub fn new(config: OtelValidationConfig) -> Self;
    pub fn validate(&self, spans: &[Span], expectations: &ExpectationsConfig) -> Result<ValidationReport>;
}

pub trait Validator: Send + Sync {
    fn name(&self) -> &str;
    fn validate(&self, spans: &[Span], expectations: &ExpectationsConfig) -> Result<Vec<ValidationError>>;
}

pub struct ValidationReport {
    pub passed: bool,
    pub errors: Vec<ValidationError>,
    pub warnings: Vec<String>,
    pub span_count: usize,
    pub digest: String,
}
```

**Validation Flow:**
1. Normalize spans (sort by trace_id/span_id, remove volatile fields)
2. Run all validators in parallel
3. Aggregate results (fail-fast on first error)
4. Generate report with focused error message
5. Compute SHA-256 digest of normalized JSON

### 5.4 Execution Module (`crates/clnrm-core/src/`)

**Files:**
- `cleanroom.rs` - Main environment and service registry (450 lines)
- `scenario.rs` - Scenario orchestration (300 lines)
- `services/factory.rs` - Service plugin factory (200 lines)
- `services/generic.rs` - Generic container plugin (250 lines)
- `backend/testcontainer.rs` - Testcontainers backend (400 lines)

**Public API:**
```rust
pub struct CleanroomEnvironment {
    registry: ServiceRegistry,
    backend: Box<dyn Backend>,
    telemetry_config: Option<OtelConfig>,
}

impl CleanroomEnvironment {
    pub fn new() -> Result<Self>;
    pub fn with_backend(backend: Box<dyn Backend>) -> Result<Self>;
    pub fn register_service(&mut self, plugin: Box<dyn ServicePlugin>) -> Result<()>;
    pub fn start_service(&mut self, name: &str) -> Result<ServiceHandle>;
    pub fn execute_scenario(&mut self, scenario: &ScenarioConfig) -> Result<ScenarioResult>;
}

pub trait ServicePlugin: Send + Sync {
    fn start(&self) -> Result<ServiceHandle>;  // Sync, not async
    fn stop(&self, handle: &ServiceHandle) -> Result<()>;
    fn health_check(&self, handle: &ServiceHandle) -> Result<HealthStatus>;
    fn service_type(&self) -> &str;
}

pub trait Backend: Send + Sync {
    fn create_container(&self, config: &ContainerConfig) -> Result<ContainerId>;
    fn start_container(&self, id: &ContainerId) -> Result<()>;
    fn stop_container(&self, id: &ContainerId) -> Result<()>;
    fn execute_command(&self, id: &ContainerId, cmd: &[String]) -> Result<ExecutionResult>;
}
```

**Execution Guarantees:**
- Each test gets fresh `CleanroomEnvironment`
- Containers cleaned up on `Drop` (even on panic)
- Services started in dependency order
- Health checks with exponential backoff
- Timeout enforcement at scenario level

---

## 6. Error Handling Strategy

### 6.1 Error Type Hierarchy

```
CleanroomError
├── ConfigurationError   (TOML parse, schema validation)
├── TemplateError        (Tera rendering, variable resolution)
├── ContainerError       (Docker/Podman operations)
├── ServiceError         (Service startup, health checks)
├── ValidationError      (Assertion failures, expectation mismatches)
├── TimeoutError         (Exceeded time limits)
├── NetworkError         (Connection failures)
├── IoError             (File system operations)
├── SerializationError  (JSON/TOML serialization)
└── InternalError       (Framework bugs)
```

### 6.2 Error Context Pattern

Every error should have:
1. **Kind** - Structured error type
2. **Message** - Human-readable description
3. **Context** - Operation being performed
4. **Source** - Underlying error (if any)
5. **Timestamp** - When error occurred

```rust
// Example usage
let config = parse_toml_config(&content)
    .map_err(|e|
        CleanroomError::configuration_error(format!("Failed to parse TOML: {}", e))
            .with_context(format!("File: {}", path.display()))
    )?;
```

### 6.3 Error Recovery

**No Recovery:**
- Configuration errors (fail early, fail fast)
- Template rendering errors
- Container backend unavailable

**Graceful Degradation:**
- OTEL collector unreachable → fallback to stdout
- Service health check timeouts → retry with backoff
- Validation warnings → log but continue

**Cleanup on Error:**
- Always stop containers in `Drop` impl
- Close file handles and network connections
- Release resource locks

---

## 7. Testing Strategy

### 7.1 Test Pyramid

```
           ┌─────────────────┐
           │  Property Tests │  (160K+ cases, proptest)
           └─────────────────┘
          ┌───────────────────┐
          │ Integration Tests │  (100+ scenarios, testcontainers)
          └───────────────────┘
        ┌──────────────────────┐
        │    Self-Tests        │  (dogfooding, framework tests itself)
        └──────────────────────┘
      ┌─────────────────────────┐
      │     Unit Tests          │  (1000+ assertions, inline modules)
      └─────────────────────────┘
```

### 7.2 Test Organization

**Unit Tests** (`#[cfg(test)]` modules)
- Inline with production code
- Test public API surface
- Mock external dependencies
- Fast execution (<100ms per test)

**Integration Tests** (`crates/clnrm-core/tests/`)
- Real container operations
- End-to-end flows
- OTEL collector integration
- TOML-based test cases

**Self-Tests** (`cargo run -- self-test`)
- Framework tests itself
- Validates dogfooding principle
- Checks all features work together

**Property Tests** (`#[cfg(feature = "proptest")]`)
- Determinism verification
- Cache hash stability
- Normalization idempotence

### 7.3 AAA Test Pattern (MANDATORY)

```rust
#[tokio::test]
async fn test_template_renders_with_env_vars() -> Result<()> {
    // Arrange
    std::env::set_var("TEST_VAR", "test_value");
    let template = "{{ env(name=\"TEST_VAR\") }}";
    let mut renderer = TemplateRenderer::new()?;

    // Act
    let result = renderer.render_str(template, "test")?;

    // Assert
    assert_eq!(result, "test_value");

    // Cleanup
    std::env::remove_var("TEST_VAR");
    Ok(())
}
```

---

## 8. Performance Targets

### 8.1 Latency Targets

| Operation | Target | Measured | Status |
|-----------|--------|----------|--------|
| Template cold run | ≤5s | TBD | ⚠️ Not measured |
| Template hot reload | ≤3s (p95) | TBD | ⚠️ Not measured |
| Container startup | ≤2s | TBD | ⚠️ Not measured |
| OTEL span collection | ≤500ms | TBD | ⚠️ Not measured |
| Validation suite | ≤1s | TBD | ⚠️ Not measured |
| Report generation | ≤200ms | TBD | ⚠️ Not measured |

### 8.2 Throughput Targets

- **Parallel Scenarios:** 10+ scenarios in parallel (CPU-bound)
- **Suite Execution:** 30-50% faster than v0.6 (change-aware)
- **Cache Hit Rate:** >80% on repeated runs

### 8.3 Resource Targets

- **Memory:** <500MB baseline, <100MB per container
- **CPU:** <10% idle, <80% during parallel execution
- **Disk:** <50MB cache, <10MB per report

### 8.4 Performance Monitoring

```rust
#[cfg(feature = "otel-metrics")]
use clnrm_core::telemetry::metrics;

// Record operation duration
let start = std::time::Instant::now();
let result = execute_operation()?;
metrics::record_operation_duration("template_render", start.elapsed().as_millis() as f64);

// Track cache hits
metrics::increment_counter("cache_hits", 1.0);
```

---

## 9. Security & Hermeticity

### 9.1 Hermeticity Guarantees

**Network Isolation:**
- Each test uses isolated Docker network
- No access to host network by default
- DNS resolution limited to container network

**File System Isolation:**
- Fresh volumes per test
- No shared mounts between tests
- Cleanup on test completion

**Process Isolation:**
- Separate PID namespace
- Resource limits (CPU, memory)
- User namespace isolation

### 9.2 Security Boundaries

```
┌──────────────────────────────────────────────┐
│              Host System                     │
│                                              │
│  ┌────────────────────────────────────────┐ │
│  │       Docker/Podman Daemon             │ │
│  │                                        │ │
│  │  ┌──────────────────────────────────┐ │ │
│  │  │   Test Network (Isolated)        │ │ │
│  │  │                                  │ │ │
│  │  │  ┌────────┐      ┌────────┐     │ │ │
│  │  │  │ SUT    │      │Service │     │ │ │
│  │  │  │Container│─────▶│Container│     │ │ │
│  │  │  └────────┘      └────────┘     │ │ │
│  │  │       ▲              ▲           │ │ │
│  │  │       │              │           │ │ │
│  │  │       └──────────────┘           │ │ │
│  │  │      No External Access          │ │ │
│  │  └──────────────────────────────────┘ │ │
│  └────────────────────────────────────────┘ │
│                                              │
└──────────────────────────────────────────────┘
```

### 9.3 Validation Rules

**Hermeticity Validator checks:**
- No outbound network connections
- No access to host file system
- Resource attributes match expectations
- Span attributes don't contain host info

```rust
pub struct HermeticityValidator;

impl Validator for HermeticityValidator {
    fn validate(&self, spans: &[Span], expectations: &ExpectationsConfig) -> Result<Vec<ValidationError>> {
        let mut errors = vec![];

        // Check for external network spans
        if expectations.hermeticity.no_external_services {
            for span in spans {
                if is_external_service_span(span) {
                    errors.push(ValidationError::hermeticity_violation(
                        format!("Span '{}' accessed external service", span.name)
                    ));
                }
            }
        }

        // Check resource attributes
        if let Some(required_attrs) = &expectations.hermeticity.resource_attrs.must_match {
            // ... validation logic
        }

        Ok(errors)
    }
}
```

---

## 10. Technology Decisions

### 10.1 Technology Stack

| Component | Technology | Rationale | Alternatives |
|-----------|-----------|-----------|--------------|
| Language | Rust 2021 | Memory safety, performance, async | Go, Java |
| Templates | Tera 1.19 | Jinja2-like syntax, Rust native | Handlebars, Liquid |
| Containers | testcontainers-rs 0.25 | Rust bindings, Docker/Podman support | Bollard, direct API |
| OTEL | opentelemetry 0.31 | Official SDK, full feature support | Custom implementation |
| Config | TOML (via toml 0.9) | Human-readable, flat structure | YAML, JSON |
| CLI | clap 4.5 | Derive macros, validation | structopt, argh |
| Async | tokio 1.0 | De facto standard, full ecosystem | async-std, smol |

### 10.2 Architecture Decision Records (ADRs)

#### ADR-001: Sync Trait Methods for dyn Compatibility

**Status:** Accepted
**Date:** 2024-01-15

**Context:**
Rust trait objects (`dyn Trait`) cannot have async methods because async methods desugar to associated types that violate object safety.

**Decision:**
All trait methods (ServicePlugin, Backend, Validator) are synchronous. Internal implementations use `tokio::task::block_in_place` for async operations.

**Consequences:**
- ✅ Enables plugin system with dynamic dispatch
- ✅ Simplifies trait implementations
- ❌ Slight performance overhead from blocking
- ⚠️ Requires runtime available for `block_in_place`

**Code Example:**
```rust
pub trait ServicePlugin: Send + Sync {
    fn start(&self) -> Result<ServiceHandle> {
        tokio::task::block_in_place(|| {
            let rt = tokio::runtime::Handle::current();
            rt.block_on(async {
                // async implementation
            })
        })
    }
}
```

#### ADR-002: Tera for Template Rendering

**Status:** Accepted
**Date:** 2025-01-10

**Context:**
Need template engine for dynamic TOML generation with ENV vars, conditionals, and macros.

**Decision:**
Use Tera template engine with custom functions for ENV access, SHA-256, and TOML encoding.

**Consequences:**
- ✅ Jinja2-like syntax familiar to Python/web developers
- ✅ Pure Rust, no FFI overhead
- ✅ Extensible with custom functions
- ❌ Less mature than Jinja2
- ⚠️ Must carefully handle error messages

**Alternatives Considered:**
- Handlebars: Less powerful control structures
- Liquid: Rust port incomplete
- Custom DSL: Too much implementation effort

#### ADR-003: Flat TOML Schema

**Status:** Accepted
**Date:** 2025-01-12

**Context:**
v0.6 schema had deep nesting (`test.metadata`, `[[steps]]` in nested tables). This made templates verbose and error messages unclear.

**Decision:**
v0.7 uses flat TOML with top-level sections: `[meta]`, `[otel]`, `[service.<id>]`, `[[scenario]]`, `[expect]`.

**Consequences:**
- ✅ Simpler templates (shorter paths)
- ✅ Easier to read and write
- ✅ Better error messages (clearer paths)
- ❌ Breaking change from v0.6
- ⚠️ Must support both schemas during migration

#### ADR-004: Change-Aware Execution

**Status:** Accepted
**Date:** 2025-01-14

**Context:**
Running full test suite on every change is slow. Many scenarios haven't changed.

**Decision:**
Compute stable hash of each scenario's rendered TOML. Skip scenarios with matching hash in cache.

**Consequences:**
- ✅ 30-50% faster suite execution
- ✅ Deterministic hash from normalized TOML
- ❌ Must invalidate cache on framework changes
- ⚠️ Hash computation adds small overhead

**Implementation:**
```rust
pub fn scenario_hash(scenario: &ScenarioConfig) -> String {
    let normalized = normalize_scenario(scenario);
    let json = serde_json::to_string(&normalized).expect("serialize");
    sha256::digest(json)
}
```

#### ADR-005: OTEL-First Validation

**Status:** Accepted
**Date:** 2025-01-16

**Context:**
Need to validate that observability claims are backed by real telemetry data (TTBD philosophy).

**Decision:**
All validation is based on OpenTelemetry spans. No custom instrumentation or logs.

**Consequences:**
- ✅ Validates real observability, not test-only code
- ✅ Portable across OTEL backends
- ✅ Encourages good instrumentation practices
- ❌ Requires OTEL SDK in tested services
- ⚠️ Span collection adds latency

---

## Appendix A: File Size Budget

| Module | Target Lines | Current Lines | Status |
|--------|--------------|---------------|--------|
| `template/mod.rs` | 200 | TBD | ⚠️ To be measured |
| `template/context.rs` | 250 | TBD | ⚠️ To be measured |
| `template/functions.rs` | 300 | TBD | ⚠️ To be measured |
| `config.rs` | 500 | TBD | ⚠️ To be measured |
| `validation/orchestrator.rs` | 200 | TBD | ⚠️ To be measured |
| `validation/span_validator.rs` | 400 | TBD | ⚠️ To be measured |
| `cleanroom.rs` | 500 | TBD | ⚠️ To be measured |
| `scenario.rs` | 350 | TBD | ⚠️ To be measured |

**Rule:** Any file exceeding 500 lines MUST be refactored into multiple modules.

## Appendix B: Module Dependency Graph

```
┌─────────────┐
│     CLI     │
└──────┬──────┘
       │
       ▼
┌─────────────┐     ┌─────────────┐
│  Template   │────▶│   Config    │
└──────┬──────┘     └──────┬──────┘
       │                   │
       │                   ▼
       │            ┌─────────────┐
       │            │  Validation │
       │            └──────┬──────┘
       │                   │
       ▼                   │
┌─────────────┐           │
│  Execution  │◀──────────┘
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Backend   │
└─────────────┘
```

**Dependency Rules:**
- No circular dependencies
- Template depends only on Tera (external)
- Config depends only on serde (external)
- Execution depends on Template, Config, Validation, Backend
- Validation depends on Config
- Backend has no internal dependencies

## Appendix C: Key Interfaces

### Public API Surface (clnrm-core)

```rust
// Template rendering
pub struct TemplateRenderer;
pub struct TemplateContext;
pub fn is_template(content: &str) -> bool;

// Configuration
pub struct TestConfig;
pub fn parse_toml_config(content: &str) -> Result<TestConfig>;

// Execution
pub struct CleanroomEnvironment;
pub trait ServicePlugin;
pub trait Backend;

// Validation
pub struct ValidationOrchestrator;
pub struct ValidationReport;
pub trait Validator;

// Reporting
pub fn generate_reports(results: &[ScenarioResult], config: &ReportConfig) -> Result<()>;

// Error handling
pub struct CleanroomError;
pub type Result<T> = std::result::Result<T, CleanroomError>;
```

---

## Document Change History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-10-16 | Claude Code Architect | Initial architecture design for v0.7.0 |

---

**Next Steps:**

1. Review architecture with team
2. Create implementation plan with priorities
3. Set up performance benchmarking
4. Implement ADRs in order
5. Track file size budgets during implementation
