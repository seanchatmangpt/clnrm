# v0.7.0 Trait Hierarchy & Module Structure

**Architecture Pattern**: London School TDD with Trait-Based Abstraction

---

## Trait Hierarchy Diagram

```
                    ┌─────────────────────────────────────┐
                    │        Core Abstractions            │
                    │    (dyn-compatible traits)          │
                    └─────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │                               │
            ┌───────▼────────┐            ┌────────▼────────┐
            │  Cache Trait   │            │ FileWatcher     │
            │  (subsystem)   │            │   Trait         │
            └────────────────┘            └─────────────────┘
                    │                               │
        ┌───────────┴───────────┐       ┌──────────┴──────────┐
        │                       │       │                     │
┌───────▼─────┐        ┌────────▼──────┐   ┌──────▼────┐  ┌──▼────────┐
│ FileCache   │        │ MemoryCache   │   │  Notify   │  │   Mock    │
│(production) │        │  (testing)    │   │ Watcher   │  │  Watcher  │
└─────────────┘        └───────────────┘   └───────────┘  └───────────┘
     ▲                        ▲                  ▲              ▲
     │                        │                  │              │
     └────────────────────────┴──────────────────┴──────────────┘
                            Used by
                    ┌─────────────────────────────┐
                    │    CLI Commands             │
                    │  (run, dev, dry-run, fmt)   │
                    └─────────────────────────────┘
```

---

## Module Dependency Graph

```
┌──────────────────────────────────────────────────────────────┐
│                     CLI Layer                                │
│  ┌────────┐  ┌────────┐  ┌─────────┐  ┌──────┐             │
│  │  run   │  │  dev   │  │ dry-run │  │ fmt  │             │
│  └───┬────┘  └───┬────┘  └────┬────┘  └──┬───┘             │
└──────┼───────────┼────────────┼──────────┼──────────────────┘
       │           │            │          │
       │           │            │          │
┌──────▼───────────▼────────────▼──────────▼──────────────────┐
│                  Subsystem Layer                             │
│  ┌─────────┐  ┌────────┐  ┌──────────┐  ┌──────────┐       │
│  │  Cache  │  │ Watch  │  │Validation│  │Formatting│       │
│  │         │  │        │  │ (Shape)  │  │          │       │
│  └────┬────┘  └───┬────┘  └─────┬────┘  └────┬─────┘       │
└───────┼───────────┼─────────────┼────────────┼──────────────┘
        │           │             │            │
        │           │             │            │
┌───────▼───────────▼─────────────▼────────────▼──────────────┐
│                  Core Layer                                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │  Error   │  │ Template │  │  Config  │  │ Telemetry│    │
│  │ Handling │  │ Renderer │  │  Parser  │  │  (OTEL)  │    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└──────────────────────────────────────────────────────────────┘
```

---

## Cache Subsystem Trait Design

### Trait Definition
```rust
/// Cache abstraction for change detection
pub trait Cache: Send + Sync {
    /// Check if file content has changed
    fn has_changed(&self, path: &Path, content: &str) -> Result<bool>;

    /// Update cache with new content hash
    fn update(&self, path: &Path, content: &str) -> Result<()>;

    /// Persist cache to storage
    fn save(&self) -> Result<()>;

    /// Remove file from cache
    fn remove(&self, path: &Path) -> Result<()>;

    /// Get cache statistics
    fn stats(&self) -> Result<CacheStats>;

    /// Clear all entries
    fn clear(&self) -> Result<()>;
}

pub type BoxedCache = Box<dyn Cache>;
```

### Implementation Hierarchy
```
        Cache Trait (dyn)
              │
      ┌───────┴───────┐
      │               │
FileCache       MemoryCache
(Persistent)    (Ephemeral)
      │               │
      ▼               ▼
  JSON file      HashMap
  ~/.clnrm/      (in-memory)
```

### Usage Pattern (Dependency Injection)
```rust
// Production code uses FileCache
let cache: BoxedCache = Box::new(FileCache::new()?);

// Test code uses MemoryCache
#[cfg(test)]
let cache: BoxedCache = Box::new(MemoryCache::new());

// Consumer doesn't care about implementation
fn process_file(cache: &dyn Cache, path: &Path) -> Result<()> {
    let content = render_template(path)?;

    if !cache.has_changed(path, &content)? {
        return Ok(()); // Skip unchanged
    }

    execute_test(&content)?;
    cache.update(path, &content)?;
    cache.save()?;

    Ok(())
}
```

---

## Watch Subsystem Trait Design

### Trait Definition
```rust
/// File system watcher abstraction
///
/// CRITICAL: All methods are SYNC (no async) for dyn compatibility
pub trait FileWatcher: Send + Sync {
    /// Start watching a path (returns handle)
    fn watch(&self, path: &Path) -> Result<WatchHandle>;

    /// Stop watching by handle
    fn unwatch(&self, handle: WatchHandle) -> Result<()>;

    /// Get next event (blocking with timeout)
    fn next_event(&self, timeout: Duration) -> Result<Option<WatchEvent>>;

    /// Check watcher health
    fn is_healthy(&self) -> bool;
}

pub type BoxedWatcher = Box<dyn FileWatcher>;
```

### Implementation Hierarchy
```
    FileWatcher Trait (dyn)
              │
      ┌───────┴───────┐
      │               │
NotifyWatcher    MockWatcher
(Production)     (Testing)
      │               │
      ▼               ▼
notify crate     VecDeque
(cross-platform) (controllable)
```

### Integration with Debouncer
```rust
pub async fn dev_watch_loop(
    watcher: &dyn FileWatcher,
    debouncer: &mut FileDebouncer,
) -> Result<()> {
    loop {
        match watcher.next_event(Duration::from_millis(100))? {
            Some(_event) => {
                debouncer.record_event();
            }
            None => {
                if debouncer.should_trigger() {
                    debouncer.reset();
                    run_tests().await?;
                }
            }
        }
    }
}
```

---

## Validation Subsystem Design

### Validator Hierarchy
```
ValidationOrchestrator (entry point)
          │
          ├─→ ShapeValidator (structural)
          ├─→ OtelValidator (OTEL spans)
          ├─→ SpanValidator (span assertions)
          ├─→ OrderValidator (temporal ordering)
          ├─→ GraphValidator (dependency graph)
          ├─→ WindowValidator (time windows)
          ├─→ CountValidator (span counts)
          └─→ HermeticityValidator (isolation)
```

### ShapeValidator Enhanced (v0.7.0)
```rust
impl ShapeValidator {
    // Core validations (v0.6.0)
    fn validate_required_blocks(&mut self, config: &TestConfig);
    fn validate_otel_config(&mut self, config: &TestConfig);
    fn validate_service_references(&mut self, config: &TestConfig);
    fn validate_duration_constraints(&mut self, config: &TestConfig);
    fn validate_temporal_ordering(&mut self, config: &TestConfig);
    fn validate_glob_patterns(&mut self, config: &TestConfig);

    // Enhanced validations (v0.7.0) ✅
    fn validate_container_images(&mut self, config: &TestConfig);      // NEW
    fn validate_port_bindings(&mut self, config: &TestConfig);         // NEW
    fn validate_volume_mounts(&mut self, config: &TestConfig);         // NEW
    fn validate_environment_variables(&mut self, config: &TestConfig); // NEW
    fn validate_service_dependencies(&mut self, config: &TestConfig);  // NEW
}
```

---

## Formatting Subsystem Design

### Formatter Trait Pattern
```rust
/// Test output formatter abstraction
pub trait Formatter: Send + Sync {
    /// Format test suite results
    fn format(&self, suite: &TestSuite) -> Result<String>;
}

pub enum FormatterType {
    Human,   // Human-readable
    Json,    // JSON output
    Junit,   // JUnit XML
    Tap,     // TAP protocol
}
```

### Formatter Hierarchy
```
     Formatter Trait (dyn)
            │
    ┌───────┴───────┬───────┬──────┐
    │               │       │      │
HumanFormatter  JsonFormatter  JunitFormatter  TapFormatter
(colored)       (structured)   (CI/CD)         (TAP)
```

### TOML Formatting (Non-Trait)
```rust
// Stateless functions for TOML formatting
pub fn format_toml_content(content: &str) -> Result<String>;
pub fn format_toml_file(path: &Path) -> Result<String>;
pub fn needs_formatting(path: &Path) -> Result<bool>;
pub fn verify_idempotency(content: &str) -> Result<bool>;
```

---

## Error Handling Architecture

### Error Type Hierarchy
```
CleanroomError (root)
      │
      ├─→ ErrorKind (enum)
      │     ├─ ContainerError
      │     ├─ NetworkError
      │     ├─ ConfigurationError
      │     ├─ ValidationError
      │     ├─ IoError
      │     ├─ SerializationError
      │     ├─ InternalError
      │     └─ TemplateError
      │
      └─→ Context (optional chain)
```

### Error Propagation Pattern
```rust
// Each subsystem adds context
pub fn subsystem_operation() -> Result<T> {
    lower_level_operation()
        .map_err(|e| e.with_context("Subsystem-specific context"))?
}

// Pipeline error handling
pub fn pipeline() -> Result<()> {
    step1()
        .map_err(|e| e.with_context("Step 1 failed"))?;

    step2()
        .map_err(|e| e.with_context("Step 2 failed"))?;

    Ok(())
}
```

---

## Thread Safety Patterns

### Shared State Pattern
```rust
/// Arc<Mutex<T>> for shared mutable state
pub struct CacheManager {
    cache_path: PathBuf,
    cache: Arc<Mutex<CacheFile>>,  // Thread-safe shared state
}

impl Clone for CacheManager {
    fn clone(&self) -> Self {
        Self {
            cache_path: self.cache_path.clone(),
            cache: Arc::clone(&self.cache),  // Shallow clone (cheap)
        }
    }
}
```

### Lock Acquisition Pattern
```rust
// ✅ CORRECT: Proper lock handling with error propagation
fn operation(&self) -> Result<T> {
    let state = self.state.lock()
        .map_err(|e| CleanroomError::internal_error(
            format!("Lock acquisition failed: {}", e)
        ))?;

    // Use state...
    Ok(result)
}

// ❌ WRONG: Would panic on poisoned lock
fn operation(&self) -> T {
    let state = self.state.lock().unwrap();  // FORBIDDEN
    // ...
}
```

---

## Observable Pattern Architecture

### Tracing Integration
```rust
use tracing::{debug, info, warn, error, instrument, span, Level};

// Instrument functions automatically
#[instrument(skip(self, content))]
pub fn has_changed(&self, path: &Path, content: &str) -> Result<bool> {
    debug!("Checking cache for: {}", path.display());

    let hash = hash_content(content)?;
    info!("Computed hash: {}", &hash[..8]);

    // Tracing automatically captures function args and return value
    Ok(changed)
}

// Manual span creation for complex logic
pub fn complex_operation() -> Result<()> {
    let _span = span!(Level::INFO, "complex_op", operation_id = %Uuid::new_v4());

    debug!("Starting phase 1");
    phase1()?;

    debug!("Starting phase 2");
    phase2()?;

    info!("Operation completed successfully");
    Ok(())
}
```

### OTEL Metrics (Feature-Gated)
```rust
#[cfg(feature = "otel-metrics")]
use clnrm_core::telemetry::metrics;

pub fn record_metrics(&self, operation: &str, duration_ms: f64, success: bool) {
    #[cfg(feature = "otel-metrics")]
    {
        metrics::record_histogram(
            "subsystem.operation.duration_ms",
            duration_ms
        );

        metrics::increment_counter_with_labels(
            "subsystem.operation.total",
            1,
            &[
                ("operation", operation),
                ("outcome", if success { "success" } else { "failure" }),
            ],
        );
    }
}
```

---

## Testing Architecture (London TDD)

### Mock Strategy with Traits
```rust
// Production trait
pub trait Cache: Send + Sync {
    fn has_changed(&self, path: &Path, content: &str) -> Result<bool>;
    fn update(&self, path: &Path, content: &str) -> Result<()>;
}

// Mock implementation for testing
#[cfg(test)]
pub struct MockCache {
    expectations: Arc<Mutex<Vec<Expectation>>>,
}

#[cfg(test)]
impl MockCache {
    pub fn expect_has_changed(&self, path: PathBuf, result: bool) {
        self.expectations.lock().unwrap().push(
            Expectation::HasChanged { path, result }
        );
    }
}

#[cfg(test)]
impl Cache for MockCache {
    fn has_changed(&self, path: &Path, content: &str) -> Result<bool> {
        let mut exps = self.expectations.lock().unwrap();
        match exps.pop() {
            Some(Expectation::HasChanged { path: exp_path, result }) => {
                assert_eq!(path, exp_path);
                Ok(result)
            }
            _ => panic!("Unexpected method call"),
        }
    }

    // ... other methods
}
```

### Test Pattern Example
```rust
#[tokio::test]
async fn test_skip_unchanged_file_integration() -> Result<()> {
    // Arrange
    let mock_cache = MockCache::new();
    mock_cache.expect_has_changed(PathBuf::from("test.toml"), false);

    let cache: BoxedCache = Box::new(mock_cache);

    // Act
    let result = process_file(&*cache, Path::new("test.toml"))?;

    // Assert
    assert!(result.skipped);  // File was skipped due to cache hit

    Ok(())
}
```

---

## Subsystem Interaction Patterns

### 1. CLI → Subsystem Interaction
```
┌──────────┐
│ run CMD  │
└────┬─────┘
     │
     ├─→ TemplateRenderer::render()     [template subsystem]
     │        │
     │        ▼
     ├─→ Cache::has_changed()           [cache subsystem]
     │        │
     │        ▼
     ├─→ ShapeValidator::validate()     [validation subsystem]
     │        │
     │        ▼
     ├─→ execute_test()                 [execution]
     │        │
     │        ▼
     └─→ Cache::update() + save()       [cache subsystem]
```

### 2. dev --watch Interaction
```
┌──────────┐
│ dev CMD  │
└────┬─────┘
     │
     ├─→ FileWatcher::watch()           [watch subsystem]
     │        │
     │        ▼
     ├─→ FileWatcher::next_event()      [watch subsystem]
     │        │
     │        ▼
     ├─→ FileDebouncer::record_event()  [watch subsystem]
     │        │
     │        ▼
     ├─→ FileDebouncer::should_trigger() [watch subsystem]
     │        │
     │        ▼
     └─→ run_tests() [triggers run pipeline]
```

### 3. dry-run Interaction
```
┌──────────┐
│dry-run   │
│  CMD     │
└────┬─────┘
     │
     ├─→ find_test_files()              [filesystem]
     │        │
     │        ▼
     ├─→ TemplateRenderer::render()     [template subsystem]
     │        │
     │        ▼
     ├─→ ShapeValidator::validate()     [validation subsystem]
     │        │
     │        ▼
     └─→ report_results()               [reporting]
```

---

## Key Architectural Invariants

### 1. Trait Compatibility
**Invariant**: All subsystem traits are `dyn`-compatible

**Enforcement**:
- ✅ No async trait methods
- ✅ All methods return `Result<T>` or concrete types
- ✅ No generic associated types (GATs)
- ✅ Trait is `Send + Sync`

### 2. Error Handling
**Invariant**: No `.unwrap()` or `.expect()` in production code

**Enforcement**:
- ✅ Use `?` operator for error propagation
- ✅ Use `.map_err()` to add context
- ✅ Clippy lint: `#![deny(clippy::unwrap_used)]`
- ✅ CI check: `cargo clippy -- -D warnings`

### 3. Thread Safety
**Invariant**: Shared state is always `Arc<Mutex<T>>`

**Enforcement**:
- ✅ Lock acquisition uses `?` operator
- ✅ Lock scope is minimal (drop guard early)
- ✅ No cross-lock dependencies (deadlock prevention)

### 4. File Size Limit
**Invariant**: All source files <500 lines

**Enforcement**:
- ✅ Split large modules into submodules
- ✅ Use `mod.rs` for module organization
- ✅ CI check for line count

---

## Design Patterns Summary

### Creational Patterns
- **Factory**: `FormatterType` → `Box<dyn Formatter>`
- **Builder**: Not used (prefer simple constructors)

### Structural Patterns
- **Adapter**: `NotifyWatcher` adapts `notify` crate to `FileWatcher` trait
- **Facade**: `ValidationOrchestrator` provides unified validation interface

### Behavioral Patterns
- **Strategy**: `Cache` trait with multiple implementations
- **Observer**: `FileWatcher` notifies on file changes
- **Template Method**: `Formatter` trait defines formatting algorithm

### Concurrency Patterns
- **Shared State**: `Arc<Mutex<T>>` for thread-safe access
- **Message Passing**: Not used (prefer shared state for simplicity)

---

## Performance Optimization Strategies

### Cache Subsystem
```rust
// Optimization: In-memory cache reduces disk I/O
impl FileCache {
    fn new() -> Result<Self> {
        Ok(Self {
            cache_path,
            cache: Arc::new(Mutex::new(load_or_create()?)),  // Loaded once
        })
    }

    fn has_changed(&self) -> Result<bool> {
        // O(1) HashMap lookup (in-memory)
        let cache = self.cache.lock()?;
        Ok(cache.hashes.get(key) != Some(hash))
    }
}
```

### Watch Subsystem
```rust
// Optimization: Event batching with debouncer
impl FileDebouncer {
    fn should_trigger(&self) -> bool {
        // Batch events within 200ms window
        self.last_event
            .map(|t| t.elapsed() >= self.window)
            .unwrap_or(false)
    }
}
```

### Formatting Subsystem
```rust
// Optimization: Early exit if already formatted
pub fn needs_formatting(path: &Path) -> Result<bool> {
    let content = fs::read_to_string(path)?;
    let formatted = format_toml_content(&content)?;
    Ok(content != formatted)  // Skip if already formatted
}
```

### Validation Subsystem
```rust
// Optimization: Early termination on first error (optional)
impl ShapeValidator {
    fn validate_config(&mut self, config: &TestConfig) -> Result<()> {
        self.validate_required_blocks(config);

        if self.errors.len() > MAX_ERRORS {
            return Ok(());  // Stop early if too many errors
        }

        self.validate_service_references(config);
        // ...
        Ok(())
    }
}
```

---

## Conclusion

This trait hierarchy and module structure provides:

1. **Testability**: All subsystems are mockable via traits
2. **Flexibility**: Multiple implementations per trait
3. **Performance**: Optimized for <3s hot reload, <1s dry-run
4. **Maintainability**: Clear module boundaries, <500 lines per file
5. **Safety**: Thread-safe, proper error handling, no panics

**Key Innovation**: Trait-based abstraction enables London School TDD while maintaining production performance.

**Next Steps**: Implement remaining traits (`FileWatcher`) and integrate with CLI commands.
