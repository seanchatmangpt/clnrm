//! Integration tests for volume mounting functionality
//!
//! These tests verify that volume mounting works end-to-end with real containers.
//! Tests follow AAA pattern (Arrange, Act, Assert) and core team standards.
//!
//! Note: These tests require Docker to be running. If Docker is not available,
//! the tests will be skipped automatically.

use clnrm_core::backend::{Backend, Cmd, TestcontainerBackend};
use clnrm_core::error::{CleanroomError, Result};
use clnrm_core::policy::Policy;
use std::fs;
use std::path::Path;

/// Helper function to check if Docker is available
fn docker_available() -> bool {
    use std::process::Command;

    let output = Command::new("docker")
        .args(["ps", "--format", "table {{.Names}}\t{{.Status}}"])
        .output();

    match output {
        Ok(result) => result.status.success(),
        Err(_) => false,
    }
}

/// Macro to skip test if Docker is not available
macro_rules! skip_if_no_docker {
    () => {
        if !docker_available() {
            println!("Docker not available, skipping test. To run Docker tests:");
            println!("  1. Start Docker Desktop or Docker daemon");
            println!("  2. Run: docker ps (to verify Docker is working)");
            println!("  3. Re-run the tests");
            return Ok(());
        }
    };
}

/// Helper to create a temporary test directory
fn create_temp_test_dir(name: &str) -> Result<String> {
    let test_dir = format!("/tmp/clnrm-test-{}", name);
    fs::create_dir_all(&test_dir)?;
    Ok(test_dir)
}

/// Helper to cleanup test directory
fn cleanup_test_dir(path: &str) {
    let _ = fs::remove_dir_all(path);
}

// ============================================================================
// Basic Volume Mount Tests
// ============================================================================

#[test]
fn test_volume_mount_with_valid_path_succeeds() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("basic-mount")?;
    let test_file_content = "Hello from host filesystem!";
    fs::write(format!("{}/test.txt", test_dir), test_file_content)?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act
    let cmd = Cmd::new("cat")
        .arg("/data/test.txt")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert
    assert_eq!(result.exit_code, 0, "Command should succeed");
    assert!(
        result.stdout.contains(test_file_content),
        "Should read file from mounted volume"
    );

    cleanup_test_dir(&test_dir);
    Ok(())
}

#[test]
fn test_volume_mount_file_sharing_between_host_and_container() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("file-sharing")?;
    let output_file = format!("{}/output.txt", test_dir);

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act - Write file from container
    let write_cmd = Cmd::new("sh")
        .args(&["-c", "echo 'Written from container' > /data/output.txt"])
        .policy(Policy::default());

    let write_result = backend.run_cmd(write_cmd)?;

    // Assert - File should exist on host
    assert_eq!(write_result.exit_code, 0, "Write command should succeed");

    let content = fs::read_to_string(&output_file)?;
    assert!(
        content.contains("Written from container"),
        "File should be accessible on host filesystem"
    );

    cleanup_test_dir(&test_dir);
    Ok(())
}

#[test]
fn test_volume_mount_with_multiple_files() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("multiple-files")?;
    fs::write(format!("{}/file1.txt", test_dir), "Content 1")?;
    fs::write(format!("{}/file2.txt", test_dir), "Content 2")?;
    fs::write(format!("{}/file3.txt", test_dir), "Content 3")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act - List files in mounted directory
    let cmd = Cmd::new("ls")
        .arg("/data")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert
    assert_eq!(result.exit_code, 0);
    assert!(result.stdout.contains("file1.txt"));
    assert!(result.stdout.contains("file2.txt"));
    assert!(result.stdout.contains("file3.txt"));

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Multiple Volume Mount Tests
// ============================================================================

#[test]
fn test_multiple_volumes_mount_independently() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let data_dir = create_temp_test_dir("multi-data")?;
    let config_dir = create_temp_test_dir("multi-config")?;

    fs::write(format!("{}/data.txt", data_dir), "Data content")?;
    fs::write(format!("{}/config.txt", config_dir), "Config content")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&data_dir, "/data", false)?
        .with_volume(&config_dir, "/config", false)?;

    // Act - Read from both volumes
    let data_cmd = Cmd::new("cat")
        .arg("/data/data.txt")
        .policy(Policy::default());
    let data_result = backend.run_cmd(data_cmd)?;

    let config_cmd = Cmd::new("cat")
        .arg("/config/config.txt")
        .policy(Policy::default());
    let config_result = backend.run_cmd(config_cmd)?;

    // Assert
    assert!(data_result.stdout.contains("Data content"));
    assert!(config_result.stdout.contains("Config content"));

    cleanup_test_dir(&data_dir);
    cleanup_test_dir(&config_dir);
    Ok(())
}

#[test]
fn test_volume_with_nested_directory_structure() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("nested")?;
    fs::create_dir_all(format!("{}/subdir1/subdir2", test_dir))?;
    fs::write(format!("{}/subdir1/subdir2/deep.txt", test_dir), "Deep content")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act
    let cmd = Cmd::new("cat")
        .arg("/data/subdir1/subdir2/deep.txt")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert
    assert_eq!(result.exit_code, 0);
    assert!(result.stdout.contains("Deep content"));

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Read-Only Enforcement Tests (Note: current implementation doesn't support)
// ============================================================================

#[test]
#[ignore] // TODO: Enable when read-only support is implemented
fn test_read_only_volume_prevents_writes() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("readonly")?;
    fs::write(format!("{}/readonly.txt", test_dir), "Original content")?;

    // TODO: Implement with_volume_ro() method
    // let backend = TestcontainerBackend::new("alpine:latest")?
    //     .with_volume_ro(&test_dir, "/data");

    // Act - Attempt to write to read-only volume
    // let write_cmd = Cmd::new("sh")
    //     .args(&["-c", "echo 'Should fail' > /data/test.txt"])
    //     .policy(Policy::default());

    // let result = backend.run_cmd(write_cmd)?;

    // Assert
    // assert_ne!(result.exit_code, 0, "Write to read-only volume should fail");

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Error Handling Tests
// ============================================================================

#[test]
fn test_volume_mount_nonexistent_host_path_behavior() -> Result<()> {
    skip_if_no_docker!();

    // Arrange - Docker creates non-existent directories by default
    let nonexistent_path = "/tmp/clnrm-test-nonexistent-12345";

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(nonexistent_path, "/data");

    // Act - Try to list the mounted directory
    let cmd = Cmd::new("ls")
        .args(&["-la", "/data"])
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert - Docker creates empty directory if host path doesn't exist
    assert_eq!(result.exit_code, 0, "Command should succeed");

    // Cleanup
    let _ = fs::remove_dir(nonexistent_path);
    Ok(())
}

#[test]
fn test_volume_mount_with_permission_issues() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("permissions")?;
    fs::write(format!("{}/test.txt", test_dir), "Test content")?;

    // Set restrictive permissions on file
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(format!("{}/test.txt", test_dir))?.permissions();
        perms.set_mode(0o000); // No permissions
        fs::set_permissions(format!("{}/test.txt", test_dir), perms)?;
    }

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act - Attempt to read file with no permissions
    let cmd = Cmd::new("cat")
        .arg("/data/test.txt")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert - Container runs as root by default, might succeed
    // This test documents the behavior rather than asserting specific result
    println!("Permission test result: exit_code={}", result.exit_code);

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Hermetic Isolation Tests
// ============================================================================

#[test]
fn test_volumes_isolated_between_different_backend_instances() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let dir1 = create_temp_test_dir("isolated-1")?;
    let dir2 = create_temp_test_dir("isolated-2")?;

    fs::write(format!("{}/data.txt", dir1), "Instance 1 data")?;
    fs::write(format!("{}/data.txt", dir2), "Instance 2 data")?;

    let backend1 = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&dir1, "/data", false)?;
    let backend2 = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&dir2, "/data", false)?;

    // Act
    let cmd1 = Cmd::new("cat").arg("/data/data.txt").policy(Policy::default());
    let cmd2 = Cmd::new("cat").arg("/data/data.txt").policy(Policy::default());

    let result1 = backend1.run_cmd(cmd1)?;
    let result2 = backend2.run_cmd(cmd2)?;

    // Assert - Each backend reads from its own volume
    assert!(result1.stdout.contains("Instance 1 data"));
    assert!(result2.stdout.contains("Instance 2 data"));

    cleanup_test_dir(&dir1);
    cleanup_test_dir(&dir2);
    Ok(())
}

#[test]
fn test_volume_modifications_visible_across_container_restarts() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("persistence")?;
    fs::write(format!("{}/counter.txt", test_dir), "0")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act - First container increments counter
    let write_cmd = Cmd::new("sh")
        .args(&["-c", "echo '1' > /data/counter.txt"])
        .policy(Policy::default());
    backend.run_cmd(write_cmd)?;

    // Act - Second container reads counter (simulating container restart)
    let read_cmd = Cmd::new("cat")
        .arg("/data/counter.txt")
        .policy(Policy::default());
    let result = backend.run_cmd(read_cmd)?;

    // Assert - Changes persist
    assert!(result.stdout.contains('1'));

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Edge Cases and Boundary Tests
// ============================================================================

#[test]
fn test_volume_with_special_characters_in_filenames() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("special-chars")?;
    let special_filename = "test-file_v1.0 (copy).txt";
    fs::write(format!("{}/{}", test_dir, special_filename), "Special content")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act
    let cmd = Cmd::new("ls")
        .arg("/data")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert
    assert_eq!(result.exit_code, 0);
    assert!(result.stdout.contains("test-file_v1.0"));

    cleanup_test_dir(&test_dir);
    Ok(())
}

#[test]
fn test_volume_with_large_file() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("large-file")?;
    let large_content = "x".repeat(1024 * 1024); // 1MB file
    fs::write(format!("{}/large.txt", test_dir), &large_content)?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act - Get file size
    let cmd = Cmd::new("wc")
        .args(&["-c", "/data/large.txt"])
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert
    assert_eq!(result.exit_code, 0);
    assert!(result.stdout.contains("1048576")); // 1MB in bytes

    cleanup_test_dir(&test_dir);
    Ok(())
}

#[test]
fn test_volume_mount_at_root_directory() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("root-mount")?;
    fs::write(format!("{}/root-test.txt", test_dir), "Root mount test")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/test-root");

    // Act
    let cmd = Cmd::new("cat")
        .arg("/test-root/root-test.txt")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert
    assert_eq!(result.exit_code, 0);
    assert!(result.stdout.contains("Root mount test"));

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Performance Tests
// ============================================================================

#[test]
fn test_volume_mount_performance_overhead() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("performance")?;
    fs::write(format!("{}/perf.txt", test_dir), "Performance test")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;

    // Act
    let cmd = Cmd::new("cat")
        .arg("/data/perf.txt")
        .policy(Policy::default());

    let result = backend.run_cmd(cmd)?;

    // Assert - Command should complete quickly
    assert_eq!(result.exit_code, 0);
    assert!(
        result.duration_ms < 5000,
        "Volume mount should not add significant overhead (took {}ms)",
        result.duration_ms
    );

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Integration with Service Plugin Tests
// ============================================================================

#[test]
fn test_volume_with_different_container_images() -> Result<()> {
    skip_if_no_docker!();

    // Arrange
    let test_dir = create_temp_test_dir("multi-image")?;
    fs::write(format!("{}/test.txt", test_dir), "Multi-image test")?;

    // Act - Test with Alpine
    let alpine_backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&test_dir, "/data", false)?;
    let alpine_cmd = Cmd::new("cat")
        .arg("/data/test.txt")
        .policy(Policy::default());
    let alpine_result = alpine_backend.run_cmd(alpine_cmd)?;

    // Act - Test with Ubuntu
    let ubuntu_backend = TestcontainerBackend::new("ubuntu:20.04")?
        .with_volume(&test_dir, "/data", false)?;
    let ubuntu_cmd = Cmd::new("cat")
        .arg("/data/test.txt")
        .policy(Policy::default());
    let ubuntu_result = ubuntu_backend.run_cmd(ubuntu_cmd)?;

    // Assert - Both should work
    assert!(alpine_result.stdout.contains("Multi-image test"));
    assert!(ubuntu_result.stdout.contains("Multi-image test"));

    cleanup_test_dir(&test_dir);
    Ok(())
}

// ============================================================================
// Comprehensive Integration Test
// ============================================================================

#[test]
fn test_volume_comprehensive_workflow() -> Result<()> {
    skip_if_no_docker!();

    // Arrange - Create test environment with input and output directories
    let input_dir = create_temp_test_dir("workflow-input")?;
    let output_dir = create_temp_test_dir("workflow-output")?;

    // Create input files
    fs::write(format!("{}/input1.txt", input_dir), "Input data 1")?;
    fs::write(format!("{}/input2.txt", input_dir), "Input data 2")?;

    let backend = TestcontainerBackend::new("alpine:latest")?
        .with_volume(&input_dir, "/input", true)?
        .with_volume(&output_dir, "/output", false)?;

    // Act - Process input files and write output
    let process_cmd = Cmd::new("sh")
        .args(&[
            "-c",
            "cat /input/input1.txt /input/input2.txt > /output/combined.txt"
        ])
        .policy(Policy::default());

    let process_result = backend.run_cmd(process_cmd)?;

    // Assert - Processing succeeded
    assert_eq!(process_result.exit_code, 0);

    // Assert - Output file exists on host
    let output_content = fs::read_to_string(format!("{}/combined.txt", output_dir))?;
    assert!(output_content.contains("Input data 1"));
    assert!(output_content.contains("Input data 2"));

    // Verify file count
    let verify_cmd = Cmd::new("sh")
        .args(&["-c", "ls /input | wc -l"])
        .policy(Policy::default());
    let verify_result = backend.run_cmd(verify_cmd)?;
    assert!(verify_result.stdout.trim().contains('2'));

    cleanup_test_dir(&input_dir);
    cleanup_test_dir(&output_dir);
    Ok(())
}
