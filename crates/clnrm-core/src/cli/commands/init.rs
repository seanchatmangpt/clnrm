//! Init command implementation
//!
//! Handles project initialization with template generation and directory
//! structure creation.

use crate::error::{CleanroomError, Result};
use std::path::Path;
use tracing::{info, debug};

/// Initialize a new test project in the current directory
pub fn init_project(force: bool, with_config: bool) -> Result<()> {
    println!("🚀 Initializing cleanroom test project in current directory");
    
    // Check if already initialized
    let tests_dir = std::path::Path::new("tests");
    let scenarios_dir = std::path::Path::new("scenarios");
    let basic_test_file = tests_dir.join("basic.clnrm.toml");
    
    if tests_dir.exists() && scenarios_dir.exists() && basic_test_file.exists() {
        if !force {
            return Err(CleanroomError::validation_error("Project already initialized")
                .with_context("Use --force to reinitialize"));
        }
        println!("Reinitializing existing project (--force flag used)");
    }
    
    // Create directory structure
    std::fs::create_dir_all(tests_dir)?;
    std::fs::create_dir_all(scenarios_dir)?;
    
    // Create basic test file
    let test_content = r#"# Cleanroom Test Definition
# Generated by clnrm init

[test.metadata]
name = "basic_test"
description = "Basic integration test"
timeout = "120s"

[services.test_container]
type = "generic_container"
plugin = "alpine"
image = "alpine:latest"

[[steps]]
name = "hello_world"
command = ["echo", "Hello from cleanroom!"]
expected_output_regex = "Hello from cleanroom!"

[[steps]]
name = "verify_environment"
command = ["sh", "-c", "echo 'Test environment ready' && uname -a"]
expected_output_regex = "Test environment ready"
"#;
    
    std::fs::write(basic_test_file, test_content)?;
    
    // Create README
    let readme_content = r#"# Cleanroom Test Project

This project uses the cleanroom testing framework for hermetic integration testing.

## Quick Start

```bash
# Run tests
clnrm run tests/

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Project Structure

- `tests/` - Test definition files (.clnrm.toml)
- `scenarios/` - Test scenario definitions
- `cleanroom.toml` - Optional framework configuration
- `README.md` - This file

## Framework Self-Testing

This project demonstrates the cleanroom framework testing itself through the "eat your own dog food" principle.
"#;
    
    std::fs::write("README.md", readme_content)?;
    
    // Create cleanroom.toml if requested
    if with_config {
        let config_content = r#"# Cleanroom Framework Configuration (optional)
# The framework works without this file - only add when customizing

[project]
name = "my-project"
version = "0.1.0"

# Uncomment to enable parallel execution
# [cli]
# parallel = true
# jobs = 4

# Uncomment to enable container reuse (10-50x faster)
# [containers]
# reuse_enabled = true
# default_image = "alpine:latest"

# See docs for all options: https://docs.cleanroom.dev/config
"#;
        std::fs::write("cleanroom.toml", config_content)?;
        println!("✅ Project initialized successfully with configuration");
        println!("📁 Created: tests/basic.clnrm.toml, cleanroom.toml, README.md");
    } else {
        println!("✅ Project initialized successfully (zero-config)");
        println!("📁 Created: tests/basic.clnrm.toml, README.md");
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_init_project_default_name() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(false, false);
        
        // Assert
        assert!(result.is_ok());
        
        // Verify directory structure was created in current directory
        assert!(Path::new("tests").exists());
        assert!(Path::new("scenarios").exists());
        assert!(Path::new("README.md").exists());
        assert!(Path::new("tests/basic.clnrm.toml").exists());
        
        // Verify test file content
        let test_content = fs::read_to_string("tests/basic.clnrm.toml")
            .map_err(|e| CleanroomError::internal_error("Failed to read test file")
                .with_source(e.to_string()))?;
        assert!(test_content.contains("name = \"basic_test\""));
        assert!(test_content.contains("[test.metadata]"));
        
        // Verify README content
        let readme_content = fs::read_to_string("README.md")
            .map_err(|e| CleanroomError::internal_error("Failed to read README file")
                .with_source(e.to_string()))?;
        assert!(readme_content.contains("# Cleanroom Test Project"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_with_config() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(false, true);
        
        // Assert
        assert!(result.is_ok());
        
        // Verify directory structure was created
        assert!(Path::new("tests").exists());
        assert!(Path::new("scenarios").exists());
        assert!(Path::new("README.md").exists());
        assert!(Path::new("tests/basic.clnrm.toml").exists());
        assert!(Path::new("cleanroom.toml").exists());
        
        // Verify cleanroom.toml content
        let config_content = fs::read_to_string("cleanroom.toml")
            .map_err(|e| CleanroomError::internal_error("Failed to read config file")
                .with_source(e.to_string()))?;
        assert!(config_content.contains("[project]"));
        assert!(config_content.contains("name = \"my-project\""));
        
        Ok(())
    }

    #[test]
    fn test_init_project_already_initialized() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Initialize project first
        init_project(false, false)?;
        
        // Act - try to initialize again without force
        let result = init_project(false, false);
        
        // Assert
        assert!(result.is_err());
        assert!(result.unwrap_err().message.contains("Project already initialized"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_force_flag() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Initialize project first
        init_project(false, false)?;
        
        // Verify initial files exist
        assert!(Path::new("tests/basic.clnrm.toml").exists());
        assert!(Path::new("README.md").exists());
        
        // Act - try to initialize again with force flag
        let result = init_project(true, false);
        
        // Assert
        assert!(result.is_ok(), "Force flag should allow reinitialization");
        
        // Verify files still exist after force reinitialize
        assert!(Path::new("tests/basic.clnrm.toml").exists());
        assert!(Path::new("README.md").exists());
        
        Ok(())
    }

    #[test]
    fn test_init_project_creates_correct_directory_structure() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(false, false);
        
        // Assert
        assert!(result.is_ok());
        
        // Verify all expected directories exist
        let expected_dirs = vec![
            "tests",
            "scenarios",
        ];
        
        for dir in expected_dirs {
            assert!(Path::new(dir).exists(), "Directory '{}' should exist", dir);
            assert!(Path::new(dir).is_dir(), "Path '{}' should be a directory", dir);
        }
        
        // Verify all expected files exist
        let expected_files = vec![
            "README.md",
            "tests/basic.clnrm.toml",
        ];
        
        for file in expected_files {
            assert!(Path::new(file).exists(), "File '{}' should exist", file);
            assert!(Path::new(file).is_file(), "Path '{}' should be a file", file);
        }
        
        Ok(())
    }

    #[test]
    fn test_init_project_test_file_content() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(false, false);
        
        // Assert
        assert!(result.is_ok());
        
        // Read and verify test file content
        let test_content = fs::read_to_string("tests/basic.clnrm.toml")
            .map_err(|e| CleanroomError::internal_error("Failed to read test file")
                .with_source(e.to_string()))?;
        
        // Verify key content elements
        assert!(test_content.contains("name = \"basic_test\""));
        assert!(test_content.contains("[test.metadata]"));
        assert!(test_content.contains("hello_world"));
        assert!(test_content.contains("verify_environment"));
        assert!(test_content.contains("expected_output_regex"));
        assert!(test_content.contains("# Generated by clnrm init"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_readme_content() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(false, false);
        
        // Assert
        assert!(result.is_ok());
        
        // Read and verify README content
        let readme_content = fs::read_to_string("README.md")
            .map_err(|e| CleanroomError::internal_error("Failed to read README file")
                .with_source(e.to_string()))?;
        
        // Verify key content elements
        assert!(readme_content.contains("# Cleanroom Test Project"));
        assert!(readme_content.contains("clnrm run tests/"));
        assert!(readme_content.contains("clnrm validate tests/"));
        assert!(readme_content.contains("clnrm plugins"));
        assert!(readme_content.contains("tests/"));
        assert!(readme_content.contains("scenarios/"));
        assert!(readme_content.contains("eat your own dog food"));
        
        Ok(())
    }
}
