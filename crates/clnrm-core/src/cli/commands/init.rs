//! Init command implementation
//!
//! Handles project initialization with template generation and directory
//! structure creation.

use crate::error::{CleanroomError, Result};
use std::path::Path;
use tracing::{info, debug};

/// Initialize a new test project
pub fn init_project(name: Option<&str>, template: &str) -> Result<()> {
    let project_name = name.unwrap_or("cleanroom-test");
    
    info!("Initializing new cleanroom test project: {}", project_name);
    debug!("Template: {}", template);
    
    // Self-test: Create project structure
    let project_dir = std::path::Path::new(project_name);
    
    if project_dir.exists() {
        return Err(CleanroomError::validation_error("Project directory already exists")
            .with_context(format!("Directory: {}", project_name)));
    }
    
    // Create directory structure
    std::fs::create_dir_all(project_dir)?;
    std::fs::create_dir_all(project_dir.join("tests"))?;
    std::fs::create_dir_all(project_dir.join("scenarios"))?;
    
    // Create basic test file
    let test_content = format!(
        r#"# Cleanroom Test Configuration
# Generated by clnrm init

name = "{}"

[[scenarios]]
name = "basic_test"
steps = [
    {{ name = "setup", cmd = ["echo", "Setting up test environment"] }},
    {{ name = "test", cmd = ["echo", "Running test"] }},
    {{ name = "cleanup", cmd = ["echo", "Cleaning up"] }}
]

[policy]
security_level = "medium"
max_execution_time = 300

# Optional: Add services
# [[services]]
# name = "database"
# service_type = "database"
# image = "postgres:15"
# env = {{ POSTGRES_PASSWORD = "testpass" }}
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("tests").join("basic.toml"), test_content)?;
    
    // Create README
    let readme_content = format!(
        r#"# {} - Cleanroom Test Project

This project uses the cleanroom testing framework for hermetic integration testing.

## Quick Start

```bash
# Run tests
clnrm run tests/

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Project Structure

- `tests/` - Test configuration files
- `scenarios/` - Test scenario definitions
- `README.md` - This file

## Framework Self-Testing

This project demonstrates the cleanroom framework testing itself through the "eat your own dog food" principle.
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("README.md"), readme_content)?;
    
    info!("Project initialized successfully: {}", project_dir.display());
    debug!("Created test file: tests/basic.toml, Documentation: README.md");
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_init_project_default_name() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(None, "default");
        
        // Assert
        assert!(result.is_ok());
        
        // Verify directory structure was created
        assert!(Path::new("cleanroom-test").exists());
        assert!(Path::new("cleanroom-test/tests").exists());
        assert!(Path::new("cleanroom-test/scenarios").exists());
        assert!(Path::new("cleanroom-test/README.md").exists());
        assert!(Path::new("cleanroom-test/tests/basic.toml").exists());
        
        // Verify test file content
        let test_content = fs::read_to_string("cleanroom-test/tests/basic.toml")
            .map_err(|e| CleanroomError::internal_error("Failed to read test file")
                .with_source(e.to_string()))?;
        assert!(test_content.contains("name = \"cleanroom-test\""));
        assert!(test_content.contains("basic_test"));
        
        // Verify README content
        let readme_content = fs::read_to_string("cleanroom-test/README.md")
            .map_err(|e| CleanroomError::internal_error("Failed to read README file")
                .with_source(e.to_string()))?;
        assert!(readme_content.contains("# cleanroom-test - Cleanroom Test Project"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_custom_name() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(Some("my-custom-project"), "default");
        
        // Assert
        assert!(result.is_ok());
        
        // Verify directory structure was created with custom name
        assert!(Path::new("my-custom-project").exists());
        assert!(Path::new("my-custom-project/tests").exists());
        assert!(Path::new("my-custom-project/scenarios").exists());
        assert!(Path::new("my-custom-project/README.md").exists());
        assert!(Path::new("my-custom-project/tests/basic.toml").exists());
        
        // Verify test file content has custom name
        let test_content = fs::read_to_string("my-custom-project/tests/basic.toml")
            .map_err(|e| CleanroomError::internal_error("Failed to read test file")
                .with_source(e.to_string()))?;
        assert!(test_content.contains("name = \"my-custom-project\""));
        
        // Verify README content has custom name
        let readme_content = fs::read_to_string("my-custom-project/README.md")
            .map_err(|e| CleanroomError::internal_error("Failed to read README file")
                .with_source(e.to_string()))?;
        assert!(readme_content.contains("# my-custom-project - Cleanroom Test Project"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_directory_already_exists() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Create existing directory
        std::fs::create_dir_all("existing-project")
            .map_err(|e| CleanroomError::internal_error("Failed to create existing directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(Some("existing-project"), "default");
        
        // Assert
        assert!(result.is_err());
        assert!(result.unwrap_err().message.contains("Project directory already exists"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_different_templates() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Test different template names (currently all use same template)
        let templates = vec!["default", "basic", "advanced", "minimal"];
        
        for (i, template) in templates.iter().enumerate() {
            let project_name = format!("test-project-{}", i);
            
            // Act
            let result = init_project(Some(&project_name), template);
            
            // Assert
            assert!(result.is_ok(), "Template '{}' should work", template);
            
            // Verify project was created
            assert!(Path::new(&project_name).exists());
            assert!(Path::new(&format!("{}/tests/basic.toml", project_name)).exists());
        }
        
        Ok(())
    }

    #[test]
    fn test_init_project_creates_correct_directory_structure() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(Some("structure-test"), "default");
        
        // Assert
        assert!(result.is_ok());
        
        // Verify all expected directories exist
        let expected_dirs = vec![
            "structure-test",
            "structure-test/tests",
            "structure-test/scenarios",
        ];
        
        for dir in expected_dirs {
            assert!(Path::new(dir).exists(), "Directory '{}' should exist", dir);
            assert!(Path::new(dir).is_dir(), "Path '{}' should be a directory", dir);
        }
        
        // Verify all expected files exist
        let expected_files = vec![
            "structure-test/README.md",
            "structure-test/tests/basic.toml",
        ];
        
        for file in expected_files {
            assert!(Path::new(file).exists(), "File '{}' should exist", file);
            assert!(Path::new(file).is_file(), "Path '{}' should be a file", file);
        }
        
        Ok(())
    }

    #[test]
    fn test_init_project_test_file_content() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(Some("content-test"), "default");
        
        // Assert
        assert!(result.is_ok());
        
        // Read and verify test file content
        let test_content = fs::read_to_string("content-test/tests/basic.toml")
            .map_err(|e| CleanroomError::internal_error("Failed to read test file")
                .with_source(e.to_string()))?;
        
        // Verify key content elements
        assert!(test_content.contains("name = \"content-test\""));
        assert!(test_content.contains("basic_test"));
        assert!(test_content.contains("setup"));
        assert!(test_content.contains("test"));
        assert!(test_content.contains("cleanup"));
        assert!(test_content.contains("security_level = \"medium\""));
        assert!(test_content.contains("max_execution_time = 300"));
        assert!(test_content.contains("# Generated by clnrm init"));
        
        Ok(())
    }

    #[test]
    fn test_init_project_readme_content() -> Result<()> {
        // Arrange
        let temp_dir = TempDir::new()
            .map_err(|e| CleanroomError::internal_error("Failed to create temp dir")
                .with_source(e.to_string()))?;
        
        std::env::set_current_dir(temp_dir.path())
            .map_err(|e| CleanroomError::internal_error("Failed to change directory")
                .with_source(e.to_string()))?;
        
        // Act
        let result = init_project(Some("readme-test"), "default");
        
        // Assert
        assert!(result.is_ok());
        
        // Read and verify README content
        let readme_content = fs::read_to_string("readme-test/README.md")
            .map_err(|e| CleanroomError::internal_error("Failed to read README file")
                .with_source(e.to_string()))?;
        
        // Verify key content elements
        assert!(readme_content.contains("# readme-test - Cleanroom Test Project"));
        assert!(readme_content.contains("clnrm run tests/"));
        assert!(readme_content.contains("clnrm validate tests/"));
        assert!(readme_content.contains("clnrm plugins"));
        assert!(readme_content.contains("tests/"));
        assert!(readme_content.contains("scenarios/"));
        assert!(readme_content.contains("eat your own dog food"));
        
        Ok(())
    }
}
