//! Template command implementation
//!
//! Handles project generation from templates with various configurations.

use crate::error::{CleanroomError, Result};
use tracing::{debug, info};

/// Generate project from template
pub fn generate_from_template(template: &str, name: Option<&str>) -> Result<()> {
    let project_name = name.unwrap_or("cleanroom-project");

    info!(
        "Generating project from template: {} -> {}",
        template, project_name
    );
    debug!("Template: {}", template);

    // Check if template exists
    let available_templates = ["default", "advanced", "minimal", "database", "api"];
    if !available_templates.contains(&template) {
        return Err(CleanroomError::validation_error(format!(
            "Unknown template '{}'. Available templates: {}",
            template,
            available_templates.join(", ")
        )));
    }

    // Self-test: Create project structure
    let project_dir = std::path::Path::new(project_name);

    if project_dir.exists() {
        return Err(
            CleanroomError::validation_error("Project directory already exists")
                .with_context(format!("Directory: {}", project_name)),
        );
    }

    // Create directory structure
    std::fs::create_dir_all(project_dir)?;
    std::fs::create_dir_all(project_dir.join("tests"))?;
    std::fs::create_dir_all(project_dir.join("scenarios"))?;

    // Generate template-specific content
    match template {
        "default" => generate_default_template(project_dir, project_name)?,
        "advanced" => generate_advanced_template(project_dir, project_name)?,
        "minimal" => generate_minimal_template(project_dir, project_name)?,
        "database" => generate_database_template(project_dir, project_name)?,
        "api" => generate_api_template(project_dir, project_name)?,
        _ => unreachable!(), // Already validated above
    }

    info!("Project generated successfully: {}", project_name);
    Ok(())
}

fn generate_default_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create basic test file
    let test_content = format!(
        r#"# Cleanroom Test Configuration
# Generated by clnrm template default

[test.metadata]
name = "{}"
description = "Default template test"
timeout = "120s"

[services.test_container]
type = "generic_container"
plugin = "alpine"
image = "alpine:latest"

[[steps]]
name = "setup"
command = ["echo", "Setting up test environment"]
expected_output_regex = "Setting up test environment"

[[steps]]
name = "test"
command = ["echo", "Running test"]
expected_output_regex = "Running test"

[[steps]]
name = "cleanup"
command = ["echo", "Cleaning up"]
expected_output_regex = "Cleaning up"
"#,
        project_name
    );

    std::fs::write(
        project_dir.join("tests").join("basic.clnrm.toml"),
        test_content,
    )?;

    // Create README
    let readme_content = format!(
        r#"# {} - Cleanroom Test Project

This project uses the cleanroom testing framework for hermetic integration testing.

## Quick Start

```bash
# Run tests
clnrm run

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Project Structure

- `tests/` - Test configuration files
- `scenarios/` - Test scenario definitions
- `README.md` - This file

## Framework Self-Testing

This project demonstrates the cleanroom framework testing itself through the "eat your own dog food" principle.
"#,
        project_name
    );

    std::fs::write(project_dir.join("README.md"), readme_content)?;

    Ok(())
}

fn generate_advanced_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create advanced test file with multiple scenarios
    let test_content = format!(
        r#"# Advanced Cleanroom Test Configuration
# Generated by clnrm template advanced

[test.metadata]
name = "{}"
description = "Advanced integration test with multiple services"
timeout = "300s"

[services.database]
type = "database"
plugin = "postgres"
image = "postgres:15"
env = {{ POSTGRES_PASSWORD = "testpass", POSTGRES_DB = "testdb" }}

[services.api_server]
type = "api"
plugin = "nginx"
image = "nginx:alpine"

[[steps]]
name = "setup_database"
command = ["echo", "Setting up database"]
expected_output_regex = "Setting up database"

[[steps]]
name = "setup_api"
command = ["echo", "Setting up API server"]
expected_output_regex = "Setting up API server"

[[steps]]
name = "run_integration_tests"
command = ["echo", "Running integration tests"]
expected_output_regex = "Running integration tests"

[[steps]]
name = "load_test"
command = ["echo", "Running load tests"]
expected_output_regex = "Running load tests"

[[steps]]
name = "benchmark"
command = ["echo", "Running benchmarks"]
expected_output_regex = "Running benchmarks"

[[steps]]
name = "cleanup"
command = ["echo", "Cleaning up"]
expected_output_regex = "Cleaning up"
"#,
        project_name
    );

    std::fs::write(
        project_dir.join("tests").join("advanced.clnrm.toml"),
        test_content,
    )?;

    // Create README
    let readme_content = format!(
        r#"# {} - Advanced Cleanroom Test Project

This project demonstrates advanced cleanroom testing patterns including:
- Multi-scenario testing
- Concurrent execution
- Service integration
- Performance testing

## Quick Start

```bash
# Run all tests
clnrm run

# Run specific test
clnrm run tests/advanced.toml

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Project Structure

- `tests/` - Test configuration files
- `scenarios/` - Test scenario definitions
- `README.md` - This file

## Advanced Features

- **Concurrent Testing**: Multiple scenarios run in parallel
- **Service Integration**: Database and API server services
- **Performance Testing**: Load testing and benchmarking
- **Policy Enforcement**: High security level with resource limits
"#,
        project_name
    );

    std::fs::write(project_dir.join("README.md"), readme_content)?;

    Ok(())
}

fn generate_minimal_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create minimal test file
    let test_content = format!(
        r#"# Minimal Cleanroom Test Configuration
# Generated by clnrm template minimal

[test.metadata]
name = "{}"
description = "Minimal test"
timeout = "60s"

[services.test_container]
type = "generic_container"
plugin = "alpine"
image = "alpine:latest"

[[steps]]
name = "simple_test"
command = ["echo", "Hello from cleanroom!"]
expected_output_regex = "Hello from cleanroom!"
"#,
        project_name
    );

    std::fs::write(
        project_dir.join("tests").join("minimal.clnrm.toml"),
        test_content,
    )?;

    // Create minimal README
    let readme_content = format!(
        r#"# {} - Minimal Cleanroom Test

Simple cleanroom test project.

```bash
clnrm run
```
"#,
        project_name
    );

    std::fs::write(project_dir.join("README.md"), readme_content)?;

    Ok(())
}

fn generate_database_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create database-focused test file
    let test_content = format!(
        r#"# Database Integration Test Configuration
# Generated by clnrm template database

[test.metadata]
name = "{}"
description = "Database integration test"
timeout = "300s"

[services.postgres]
type = "database"
plugin = "postgres"
image = "postgres:15"
env = {{ 
    POSTGRES_PASSWORD = "testpass",
    POSTGRES_DB = "testdb",
    POSTGRES_USER = "testuser"
}}

[services.redis]
type = "cache"
plugin = "redis"
image = "redis:7-alpine"

[[steps]]
name = "setup_database"
command = ["echo", "Setting up database"]
expected_output_regex = "Setting up database"

[[steps]]
name = "create_tables"
command = ["echo", "Creating tables"]
expected_output_regex = "Creating tables"

[[steps]]
name = "insert_data"
command = ["echo", "Inserting test data"]
expected_output_regex = "Inserting test data"

[[steps]]
name = "run_queries"
command = ["echo", "Running test queries"]
expected_output_regex = "Running test queries"

[[steps]]
name = "cleanup"
command = ["echo", "Cleaning up database"]
expected_output_regex = "Cleaning up database"
"#,
        project_name
    );

    std::fs::write(
        project_dir.join("tests").join("database.clnrm.toml"),
        test_content,
    )?;

    // Create README
    let readme_content = format!(
        r#"# {} - Database Integration Test Project

This project focuses on database integration testing with cleanroom.

## Quick Start

```bash
# Run database tests
clnrm run

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Services

- **PostgreSQL**: Main database service
- **Redis**: Caching service

## Test Scenarios

- Database setup and teardown
- Table creation and data insertion
- Query testing and validation
- Cleanup procedures
"#,
        project_name
    );

    std::fs::write(project_dir.join("README.md"), readme_content)?;

    Ok(())
}

fn generate_api_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create API-focused test file
    let test_content = format!(
        r#"# API Integration Test Configuration
# Generated by clnrm template api

[test.metadata]
name = "{}"
description = "API integration test"
timeout = "300s"

[services.api_server]
type = "api"
plugin = "nginx"
image = "nginx:alpine"
env = {{ 
    NGINX_HOST = "0.0.0.0",
    NGINX_PORT = "8080"
}}

[services.database]
type = "database"
plugin = "postgres"
image = "postgres:15"
env = {{ 
    POSTGRES_PASSWORD = "testpass",
    POSTGRES_DB = "apidb"
}}

[[steps]]
name = "start_api"
command = ["echo", "Starting API server"]
expected_output_regex = "Starting API server"

[[steps]]
name = "health_check"
command = ["echo", "Checking API health"]
expected_output_regex = "Checking API health"

[[steps]]
name = "test_endpoints"
command = ["echo", "Testing API endpoints"]
expected_output_regex = "Testing API endpoints"

[[steps]]
name = "load_test"
command = ["echo", "Running load tests"]
expected_output_regex = "Running load tests"

[[steps]]
name = "cleanup"
command = ["echo", "Stopping API server"]
expected_output_regex = "Stopping API server"
"#,
        project_name
    );

    std::fs::write(
        project_dir.join("tests").join("api.clnrm.toml"),
        test_content,
    )?;

    // Create README
    let readme_content = format!(
        r#"# {} - API Integration Test Project

This project focuses on API integration testing with cleanroom.

## Quick Start

```bash
# Run API tests
clnrm run

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Services

- **API Server**: Nginx-based API server
- **Database**: PostgreSQL backend

## Test Scenarios

- API server startup and health checks
- Endpoint testing and validation
- Load testing and performance validation
- Cleanup and teardown procedures
"#,
        project_name
    );

    std::fs::write(project_dir.join("README.md"), readme_content)?;

    Ok(())
}
