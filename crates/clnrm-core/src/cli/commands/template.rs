//! Template command implementation
//!
//! Handles project generation from templates with various configurations.

use crate::error::{CleanroomError, Result};
use tracing::{info, debug};

/// Generate project from template
pub fn generate_from_template(template: &str, name: Option<&str>) -> Result<()> {
    let project_name = name.unwrap_or("cleanroom-project");
    
    info!("Generating project from template: {} -> {}", template, project_name);
    debug!("Template: {}", template);
    
    // Check if template exists
    let available_templates = vec!["default", "advanced", "minimal", "database", "api"];
    if !available_templates.contains(&template) {
        return Err(CleanroomError::validation_error(&format!(
            "Unknown template '{}'. Available templates: {}", 
            template, 
            available_templates.join(", ")
        )));
    }
    
    // Self-test: Create project structure
    let project_dir = std::path::Path::new(project_name);
    
    if project_dir.exists() {
        return Err(CleanroomError::validation_error("Project directory already exists")
            .with_context(format!("Directory: {}", project_name)));
    }
    
    // Create directory structure
    std::fs::create_dir_all(project_dir)?;
    std::fs::create_dir_all(project_dir.join("tests"))?;
    std::fs::create_dir_all(project_dir.join("scenarios"))?;
    
    // Generate template-specific content
    match template {
        "default" => generate_default_template(project_dir, project_name)?,
        "advanced" => generate_advanced_template(project_dir, project_name)?,
        "minimal" => generate_minimal_template(project_dir, project_name)?,
        "database" => generate_database_template(project_dir, project_name)?,
        "api" => generate_api_template(project_dir, project_name)?,
        _ => unreachable!(), // Already validated above
    }
    
    info!("Project generated successfully: {}", project_name);
    Ok(())
}

fn generate_default_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create basic test file
    let test_content = format!(
        r#"# Cleanroom Test Configuration
# Generated by clnrm template default

name = "{}"

[[scenarios]]
name = "basic_test"
steps = [
    {{ name = "setup", cmd = ["echo", "Setting up test environment"] }},
    {{ name = "test", cmd = ["echo", "Running test"] }},
    {{ name = "cleanup", cmd = ["echo", "Cleaning up"] }}
]

[policy]
security_level = "medium"
max_execution_time = 300

# Optional: Add services
# [[services]]
# name = "database"
# service_type = "database"
# image = "postgres:15"
# env = {{ POSTGRES_PASSWORD = "testpass" }}
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("tests").join("basic.toml"), test_content)?;
    
    // Create README
    let readme_content = format!(
        r#"# {} - Cleanroom Test Project

This project uses the cleanroom testing framework for hermetic integration testing.

## Quick Start

```bash
# Run tests
clnrm run

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Project Structure

- `tests/` - Test configuration files
- `scenarios/` - Test scenario definitions
- `README.md` - This file

## Framework Self-Testing

This project demonstrates the cleanroom framework testing itself through the "eat your own dog food" principle.
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("README.md"), readme_content)?;
    
    Ok(())
}

fn generate_advanced_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create advanced test file with multiple scenarios
    let test_content = format!(
        r#"# Advanced Cleanroom Test Configuration
# Generated by clnrm template advanced

name = "{}"

[[scenarios]]
name = "integration_test"
concurrent = true
steps = [
    {{ name = "setup_db", cmd = ["echo", "Setting up database"] }},
    {{ name = "setup_api", cmd = ["echo", "Setting up API server"] }},
    {{ name = "run_tests", cmd = ["echo", "Running integration tests"] }},
    {{ name = "cleanup", cmd = ["echo", "Cleaning up"] }}
]

[[scenarios]]
name = "performance_test"
timeout_ms = 60000
steps = [
    {{ name = "load_test", cmd = ["echo", "Running load tests"] }},
    {{ name = "benchmark", cmd = ["echo", "Running benchmarks"] }}
]

[policy]
security_level = "high"
max_execution_time = 600
max_memory_mb = 1024

[[services]]
name = "database"
service_type = "database"
image = "postgres:15"
env = {{ POSTGRES_PASSWORD = "testpass", POSTGRES_DB = "testdb" }}

[[services]]
name = "api_server"
service_type = "api"
image = "nginx:alpine"
ports = [8080]
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("tests").join("advanced.toml"), test_content)?;
    
    // Create README
    let readme_content = format!(
        r#"# {} - Advanced Cleanroom Test Project

This project demonstrates advanced cleanroom testing patterns including:
- Multi-scenario testing
- Concurrent execution
- Service integration
- Performance testing

## Quick Start

```bash
# Run all tests
clnrm run

# Run specific test
clnrm run tests/advanced.toml

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Project Structure

- `tests/` - Test configuration files
- `scenarios/` - Test scenario definitions
- `README.md` - This file

## Advanced Features

- **Concurrent Testing**: Multiple scenarios run in parallel
- **Service Integration**: Database and API server services
- **Performance Testing**: Load testing and benchmarking
- **Policy Enforcement**: High security level with resource limits
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("README.md"), readme_content)?;
    
    Ok(())
}

fn generate_minimal_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create minimal test file
    let test_content = format!(
        r#"# Minimal Cleanroom Test Configuration
# Generated by clnrm template minimal

name = "{}"

[[scenarios]]
name = "simple_test"
steps = [
    {{ name = "test", cmd = ["echo", "Hello from cleanroom!"] }}
]
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("tests").join("minimal.toml"), test_content)?;
    
    // Create minimal README
    let readme_content = format!(
        r#"# {} - Minimal Cleanroom Test

Simple cleanroom test project.

```bash
clnrm run
```
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("README.md"), readme_content)?;
    
    Ok(())
}

fn generate_database_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create database-focused test file
    let test_content = format!(
        r#"# Database Integration Test Configuration
# Generated by clnrm template database

name = "{}"

[[scenarios]]
name = "database_test"
steps = [
    {{ name = "setup_db", cmd = ["echo", "Setting up database"] }},
    {{ name = "create_tables", cmd = ["echo", "Creating tables"] }},
    {{ name = "insert_data", cmd = ["echo", "Inserting test data"] }},
    {{ name = "run_queries", cmd = ["echo", "Running test queries"] }},
    {{ name = "cleanup", cmd = ["echo", "Cleaning up database"] }}
]

[policy]
security_level = "high"
max_execution_time = 300

[[services]]
name = "postgres"
service_type = "database"
image = "postgres:15"
env = {{ 
    POSTGRES_PASSWORD = "testpass",
    POSTGRES_DB = "testdb",
    POSTGRES_USER = "testuser"
}}

[[services]]
name = "redis"
service_type = "cache"
image = "redis:7-alpine"
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("tests").join("database.toml"), test_content)?;
    
    // Create README
    let readme_content = format!(
        r#"# {} - Database Integration Test Project

This project focuses on database integration testing with cleanroom.

## Quick Start

```bash
# Run database tests
clnrm run

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Services

- **PostgreSQL**: Main database service
- **Redis**: Caching service

## Test Scenarios

- Database setup and teardown
- Table creation and data insertion
- Query testing and validation
- Cleanup procedures
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("README.md"), readme_content)?;
    
    Ok(())
}

fn generate_api_template(project_dir: &std::path::Path, project_name: &str) -> Result<()> {
    // Create API-focused test file
    let test_content = format!(
        r#"# API Integration Test Configuration
# Generated by clnrm template api

name = "{}"

[[scenarios]]
name = "api_test"
steps = [
    {{ name = "start_api", cmd = ["echo", "Starting API server"] }},
    {{ name = "health_check", cmd = ["echo", "Checking API health"] }},
    {{ name = "test_endpoints", cmd = ["echo", "Testing API endpoints"] }},
    {{ name = "load_test", cmd = ["echo", "Running load tests"] }},
    {{ name = "cleanup", cmd = ["echo", "Stopping API server"] }}
]

[policy]
security_level = "medium"
max_execution_time = 300

[[services]]
name = "api_server"
service_type = "api"
image = "nginx:alpine"
ports = [8080]
env = {{ 
    NGINX_HOST = "0.0.0.0",
    NGINX_PORT = "8080"
}}

[[services]]
name = "database"
service_type = "database"
image = "postgres:15"
env = {{ 
    POSTGRES_PASSWORD = "testpass",
    POSTGRES_DB = "apidb"
}}
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("tests").join("api.toml"), test_content)?;
    
    // Create README
    let readme_content = format!(
        r#"# {} - API Integration Test Project

This project focuses on API integration testing with cleanroom.

## Quick Start

```bash
# Run API tests
clnrm run

# Validate configuration
clnrm validate tests/

# Show available plugins
clnrm plugins
```

## Services

- **API Server**: Nginx-based API server
- **Database**: PostgreSQL backend

## Test Scenarios

- API server startup and health checks
- Endpoint testing and validation
- Load testing and performance validation
- Cleanup and teardown procedures
"#,
        project_name
    );
    
    std::fs::write(project_dir.join("README.md"), readme_content)?;
    
    Ok(())
}
