# CLNRM v0.6.0 System Architecture Design

**Document Type**: System Architecture Design
**Version**: 0.6.0
**Date**: 2025-10-16
**Status**: DESIGN PHASE - PARTIAL IMPLEMENTATION
**Architect**: System Designer (Architecture Sub-Coordinator)

## Executive Summary

This document defines the complete system architecture for v0.6.0, focusing on the Tera templating integration that enables property-based testing and dynamic test generation. The architecture builds upon existing partial implementation and extends it with production-ready features.

**Current State**: Template system is partially implemented with basic Tera functions.
**Target State**: Complete templating system with fake data generators, property-based testing support, and seamless TOML integration.

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture Principles](#architecture-principles)
3. [Module Structure](#module-structure)
4. [Component Architecture](#component-architecture)
5. [Integration Points](#integration-points)
6. [Plugin Interfaces](#plugin-interfaces)
7. [Error Handling Strategy](#error-handling-strategy)
8. [Data Flow](#data-flow)
9. [Security Architecture](#security-architecture)
10. [Performance Considerations](#performance-considerations)
11. [Testing Strategy](#testing-strategy)
12. [Implementation Roadmap](#implementation-roadmap)

---

## System Overview

### Goals

1. **Property-Based Testing**: Generate hundreds/thousands of test scenarios with parameterized templates
2. **Fake Data Generation**: Built-in generators for UUIDs, names, emails, timestamps, IP addresses
3. **Template Detection**: Automatic detection and rendering of `.tera` and `.toml.tera` files
4. **Backward Compatibility**: All existing `.clnrm.toml` files work unchanged
5. **Clean Integration**: Minimal changes to existing config pipeline

### Non-Goals

- Runtime template rendering (templates render at config load time only)
- Dynamic variables from test execution results
- GUI template builder (CLI only for v0.6.0)
- Template inheritance beyond Tera's built-in features

### Quality Attributes

| Attribute | Target | Measurement |
|-----------|--------|-------------|
| **Performance** | < 100ms for 1000-step template | Benchmark tests |
| **Reliability** | 100% deterministic with seeds | Property tests |
| **Maintainability** | Files < 500 lines | Clippy + metrics |
| **Compatibility** | Zero breaking changes | Integration tests |
| **Security** | No template injection | Security audit |

---

## Architecture Principles

### 1. Modular Design (Files < 500 Lines)

```
template/
├── mod.rs           (147 lines) ✅
├── context.rs       (170 lines) ✅
├── determinism.rs   (178 lines) ✅
├── functions.rs     (382 lines) ✅
└── generators.rs    (NEW - fake data generators)
```

### 2. dyn-Compatible Traits (No Async Methods)

All trait methods MUST be synchronous to maintain `dyn` compatibility:

```rust
// ✅ CORRECT - dyn compatible
pub trait TemplateFunction {
    fn call(&self, args: &HashMap<String, Value>) -> Result<Value>;
}

// ❌ WRONG - breaks dyn compatibility
pub trait TemplateFunction {
    async fn call(&self, args: &HashMap<String, Value>) -> Result<Value>;
}
```

### 3. Clean Separation of Concerns

```
┌────────────────────────────────────────┐
│  Config Layer (config.rs)              │
│  - File loading                        │
│  - Template detection                  │
│  - TOML parsing                        │
└────────┬───────────────────────────────┘
         │
         ▼
┌────────────────────────────────────────┐
│  Template Layer (template/)            │
│  - Tera engine management              │
│  - Function registration               │
│  - Context management                  │
└────────┬───────────────────────────────┘
         │
         ▼
┌────────────────────────────────────────┐
│  Generator Layer (template/generators) │
│  - Fake data generation                │
│  - Random value generation             │
│  - Deterministic seeding               │
└────────────────────────────────────────┘
```

### 4. Environment Safety (No Hardcoded Secrets)

```rust
// ✅ CORRECT - Environment variable
{{ env(name="DB_PASSWORD") }}

// ❌ WRONG - Hardcoded secret
password = "mysecret123"
```

### 5. Fail Fast with Clear Errors

```rust
// All errors must be CleanroomError with context
.map_err(|e| CleanroomError::template_error(
    format!("Template rendering failed: {}", e)
).with_context(format!("File: {}, Line: {}", path, line_num)))
```

---

## Module Structure

### Current Implementation (Existing)

```
crates/clnrm-core/src/
├── template/
│   ├── mod.rs              ✅ IMPLEMENTED (147 lines)
│   │   └── TemplateRenderer, is_template()
│   ├── context.rs          ✅ IMPLEMENTED (170 lines)
│   │   └── TemplateContext (vars, matrix, otel namespaces)
│   ├── determinism.rs      ✅ IMPLEMENTED (178 lines)
│   │   └── DeterminismConfig (seed, freeze_clock)
│   └── functions.rs        ✅ IMPLEMENTED (382 lines)
│       └── env(), now_rfc3339(), sha256(), toml_encode()
```

### Required Extensions (New)

```
crates/clnrm-core/src/
├── template/
│   ├── generators.rs       🔴 NEW (fake data generators)
│   │   ├── fake_uuid()
│   │   ├── fake_uuid_seeded(seed)
│   │   ├── fake_name()
│   │   ├── fake_email()
│   │   ├── fake_timestamp()
│   │   ├── fake_ipv4()
│   │   ├── random_int(min, max)
│   │   ├── random_string(length)
│   │   ├── random_bool()
│   │   └── random_choice(items)
│   └── registry.rs         🔴 NEW (function registry)
│       └── register_all_functions(tera)
├── config.rs               🟡 MODIFY (add template detection)
│   └── load_config_from_file() - add template rendering step
└── error.rs                ✅ READY (TemplateError already exists)
```

### File Size Budget

| File | Current | Target | Status |
|------|---------|--------|--------|
| template/mod.rs | 147 | < 200 | ✅ Good |
| template/context.rs | 170 | < 200 | ✅ Good |
| template/determinism.rs | 178 | < 200 | ✅ Good |
| template/functions.rs | 382 | < 500 | ✅ Good |
| template/generators.rs | 0 | < 400 | 🔴 New |
| template/registry.rs | 0 | < 150 | 🔴 New |

---

## Component Architecture

### 1. Template Renderer (`template/mod.rs`)

**Responsibilities**:
- Initialize Tera engine
- Manage template context
- Render template strings to TOML
- Handle rendering errors

**Public API**:
```rust
pub struct TemplateRenderer {
    tera: Tera,
    context: TemplateContext,
}

impl TemplateRenderer {
    pub fn new() -> Result<Self>;
    pub fn with_context(self, context: TemplateContext) -> Self;
    pub fn render_file(&mut self, path: &Path) -> Result<String>;
    pub fn render_str(&mut self, template: &str, name: &str) -> Result<String>;
}

pub fn is_template(content: &str) -> bool;
```

**Dependencies**:
- `tera`: Template engine
- `template::context`: Context management
- `template::registry`: Function registration

### 2. Template Context (`template/context.rs`)

**Responsibilities**:
- Manage template variables (vars, matrix, otel namespaces)
- Convert to Tera context for rendering
- Provide builder pattern for context construction

**Public API**:
```rust
pub struct TemplateContext {
    pub vars: HashMap<String, Value>,
    pub matrix: HashMap<String, Value>,
    pub otel: HashMap<String, Value>,
}

impl TemplateContext {
    pub fn new() -> Self;
    pub fn with_vars(self, vars: HashMap<String, Value>) -> Self;
    pub fn with_matrix(self, matrix: HashMap<String, Value>) -> Self;
    pub fn with_otel(self, otel: HashMap<String, Value>) -> Self;
    pub fn to_tera_context(&self) -> Result<Context>;
    pub fn add_var(&mut self, key: String, value: Value);
    pub fn add_matrix_param(&mut self, key: String, value: Value);
    pub fn add_otel_config(&mut self, key: String, value: Value);
}
```

### 3. Determinism Config (`template/determinism.rs`)

**Responsibilities**:
- Provide deterministic test execution configuration
- Support fixed random seeds
- Support frozen timestamps

**Public API**:
```rust
pub struct DeterminismConfig {
    pub seed: Option<u64>,
    pub freeze_clock: Option<String>,
}

impl DeterminismConfig {
    pub fn new() -> Self;
    pub fn with_seed(self, seed: u64) -> Self;
    pub fn with_freeze_clock(self, timestamp: String) -> Self;
    pub fn is_deterministic(&self) -> bool;
    pub fn has_seed(&self) -> bool;
    pub fn has_frozen_clock(&self) -> bool;
    pub fn get_seed(&self) -> Option<u64>;
    pub fn get_freeze_clock(&self) -> Option<&str>;
}
```

### 4. Template Functions (`template/functions.rs`)

**Current Functions** (Implemented):
- `env(name)` - Get environment variable
- `now_rfc3339()` - Current timestamp (respects freeze_clock)
- `sha256(s)` - SHA-256 hex digest
- `toml_encode(value)` - Encode as TOML literal

**Architecture**:
```rust
pub fn register_functions(tera: &mut Tera) -> Result<()>;

struct EnvFunction;
impl Function for EnvFunction {
    fn call(&self, args: &HashMap<String, Value>) -> tera::Result<Value>;
}

struct NowRfc3339Function {
    frozen: Arc<Mutex<Option<String>>>,
}
impl Function for NowRfc3339Function {
    fn call(&self, args: &HashMap<String, Value>) -> tera::Result<Value>;
}
```

### 5. Fake Data Generators (`template/generators.rs`) 🔴 NEW

**Responsibilities**:
- Generate fake UUIDs, names, emails, timestamps, IPs
- Generate random integers, strings, booleans
- Support deterministic generation with seeds
- Provide property test helpers

**Public API**:
```rust
// UUID Generators
pub fn fake_uuid() -> String;
pub fn fake_uuid_seeded(seed: u64) -> String;

// Person Data Generators
pub fn fake_name() -> String;
pub fn fake_name_seeded(seed: u64) -> String;
pub fn fake_email() -> String;
pub fn fake_email_seeded(seed: u64) -> String;

// Time Generators
pub fn fake_timestamp() -> i64;
pub fn fake_timestamp_ms() -> i64;

// Network Generators
pub fn fake_ipv4() -> String;
pub fn fake_ipv4_seeded(seed: u64) -> String;

// Random Value Generators
pub fn random_int(min: i64, max: i64) -> i64;
pub fn random_int_seeded(seed: u64, min: i64, max: i64) -> i64;
pub fn random_string(length: usize) -> String;
pub fn random_string_seeded(seed: u64, length: usize) -> String;
pub fn random_bool() -> bool;
pub fn random_bool_seeded(seed: u64) -> bool;
pub fn random_choice(items: Vec<String>) -> String;
pub fn random_choice_seeded(seed: u64, items: Vec<String>) -> String;

// Property Test Helpers
pub fn property_range(start: i64, end: i64) -> Vec<i64>;
```

**Implementation Strategy**:
```rust
use rand::{Rng, SeedableRng};
use uuid::Uuid;

// Non-deterministic (uses thread_rng)
pub fn fake_uuid() -> String {
    Uuid::new_v4().to_string()
}

// Deterministic (uses seeded RNG)
pub fn fake_uuid_seeded(seed: u64) -> String {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let bytes: [u8; 16] = rng.gen();
    Uuid::from_bytes(bytes).to_string()
}

const FIRST_NAMES: &[&str] = &[
    "Alice", "Bob", "Charlie", "Diana", "Emma", "Frank",
    "Grace", "Henry", "Iris", "Jack", "Kate", "Leo"
];

const LAST_NAMES: &[&str] = &[
    "Smith", "Johnson", "Williams", "Brown", "Jones",
    "Garcia", "Miller", "Davis", "Rodriguez", "Martinez"
];

pub fn fake_name() -> String {
    let mut rng = rand::thread_rng();
    let first = FIRST_NAMES[rng.gen_range(0..FIRST_NAMES.len())];
    let last = LAST_NAMES[rng.gen_range(0..LAST_NAMES.len())];
    format!("{} {}", first, last)
}

pub fn fake_name_seeded(seed: u64) -> String {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let first = FIRST_NAMES[rng.gen_range(0..FIRST_NAMES.len())];
    let last = LAST_NAMES[rng.gen_range(0..LAST_NAMES.len())];
    format!("{} {}", first, last)
}
```

### 6. Function Registry (`template/registry.rs`) 🔴 NEW

**Responsibilities**:
- Register all template functions with Tera
- Organize function registration in logical groups
- Handle registration errors

**Public API**:
```rust
pub fn register_all_functions(tera: &mut Tera) -> Result<()>;

// Private helper functions
fn register_env_functions(tera: &mut Tera) -> Result<()>;
fn register_time_functions(tera: &mut Tera) -> Result<()>;
fn register_crypto_functions(tera: &mut Tera) -> Result<()>;
fn register_fake_data_functions(tera: &mut Tera) -> Result<()>;
fn register_random_functions(tera: &mut Tera) -> Result<()>;
fn register_property_test_functions(tera: &mut Tera) -> Result<()>;
```

**Implementation**:
```rust
pub fn register_all_functions(tera: &mut Tera) -> Result<()> {
    // Existing functions (from functions.rs)
    functions::register_functions(tera)?;

    // Fake data generators
    register_fake_data_functions(tera)?;

    // Random value generators
    register_random_functions(tera)?;

    // Property test helpers
    register_property_test_functions(tera)?;

    Ok(())
}

fn register_fake_data_functions(tera: &mut Tera) -> Result<()> {
    use tera::Function;
    use generators::*;

    // fake_uuid()
    tera.register_function("fake_uuid", Box::new(|_args| {
        Ok(Value::String(fake_uuid()))
    }));

    // fake_uuid_seeded(seed)
    tera.register_function("fake_uuid_seeded", Box::new(|args| {
        let seed = args.get("seed")
            .and_then(|v| v.as_u64())
            .ok_or_else(|| tera::Error::msg("fake_uuid_seeded requires 'seed' parameter"))?;
        Ok(Value::String(fake_uuid_seeded(seed)))
    }));

    // fake_name()
    tera.register_function("fake_name", Box::new(|_args| {
        Ok(Value::String(fake_name()))
    }));

    // ... more registrations

    Ok(())
}
```

---

## Integration Points

### 1. Config Loading Pipeline Modification

**Current Implementation** (`config.rs:681-689`):
```rust
pub fn load_config_from_file(path: &std::path::Path) -> Result<TestConfig> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| CleanroomError::config_error(format!("Failed to read config file: {}", e)))?;

    let config = parse_toml_config(&content)?;
    config.validate()?;

    Ok(config)
}
```

**Proposed Implementation** 🟡 MODIFY:
```rust
pub fn load_config_from_file(path: &std::path::Path) -> Result<TestConfig> {
    // Read raw file contents
    let content = std::fs::read_to_string(path)
        .map_err(|e| CleanroomError::config_error(
            format!("Failed to read config file '{}': {}", path.display(), e)
        ))?;

    // Check if template rendering is needed
    let rendered_content = if is_template_file(path, &content) {
        // Render template before parsing
        let mut renderer = TemplateRenderer::new()
            .map_err(|e| CleanroomError::config_error(
                format!("Failed to initialize template renderer: {}", e)
            ))?;

        renderer.render_str(&content, path.to_str().unwrap_or("unknown"))
            .map_err(|e| CleanroomError::template_error(
                format!("Template rendering failed for '{}': {}", path.display(), e)
            ))?
    } else {
        // No template rendering needed
        content
    };

    // Parse TOML (unchanged)
    let config = parse_toml_config(&rendered_content)?;

    // Validate (unchanged)
    config.validate()?;

    Ok(config)
}

/// Check if file should be treated as a template
fn is_template_file(path: &std::path::Path, content: &str) -> bool {
    // Check file extension first
    if let Some(ext) = path.extension() {
        if ext == "tera" {
            return true;
        }
    }

    // Check for .toml.tera double extension
    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
        if name.ends_with(".toml.tera") {
            return true;
        }
    }

    // Check content for template syntax
    template::is_template(content)
}
```

**Changes Required**:
1. Add `is_template_file()` helper function
2. Add template rendering step before TOML parsing
3. Preserve existing error handling patterns
4. No changes to `parse_toml_config()` or `validate()`

### 2. TemplateRenderer Initialization

**Modification to `template/mod.rs`**:
```rust
impl TemplateRenderer {
    pub fn new() -> Result<Self> {
        let mut tera = Tera::default();

        // Register ALL functions (existing + new)
        registry::register_all_functions(&mut tera)?;

        Ok(Self {
            tera,
            context: TemplateContext::new(),
        })
    }
}
```

---

## Plugin Interfaces

### Template Function Plugin Trait

All template functions implement Tera's `Function` trait:

```rust
use tera::Function;
use std::collections::HashMap;

pub trait Function {
    fn call(&self, args: &HashMap<String, Value>) -> tera::Result<Value>;
}
```

### Custom Filter Plugin Trait

Filters implement Tera's `Filter` trait:

```rust
use tera::Filter;

pub trait Filter {
    fn filter(&self, value: &Value, args: &HashMap<String, Value>) -> tera::Result<Value>;
}
```

### Adding New Template Functions

**Steps to add a new function**:

1. **Implement the function** in `template/generators.rs`:
```rust
pub fn fake_port() -> u16 {
    let mut rng = rand::thread_rng();
    rng.gen_range(1024..65535)
}
```

2. **Register in `template/registry.rs`**:
```rust
tera.register_function("fake_port", Box::new(|_args| {
    Ok(Value::Number(generators::fake_port().into()))
}));
```

3. **Add tests** in `template/generators.rs`:
```rust
#[test]
fn test_fake_port() {
    let port = fake_port();
    assert!(port >= 1024 && port < 65535);
}
```

4. **Document** in function registry table

### Extension Points

```
┌────────────────────────────────────────────┐
│  Template Function Extension Point         │
│                                            │
│  1. Implement generator function           │
│  2. Register with Tera via registry        │
│  3. Add unit tests                         │
│  4. Update documentation                   │
└────────────────────────────────────────────┘
```

---

## Error Handling Strategy

### Error Taxonomy

```
CleanroomError::TemplateError
├── Template Syntax Error
│   ├── Unclosed {{ }} or {% %}
│   ├── Unknown function call
│   └── Invalid control structure
├── Function Execution Error
│   ├── Missing required parameter
│   ├── Invalid parameter type
│   ├── Environment variable not found
│   └── File not found
├── Rendering Error
│   ├── Context missing required variable
│   ├── Type mismatch in template
│   └── Infinite loop detected
└── Post-Rendering Error
    ├── Generated invalid TOML syntax
    ├── TOML parsing failed
    └── Validation failed after rendering
```

### Error Handling Patterns

**1. Template Syntax Errors**:
```rust
self.tera.render_str(template, &tera_ctx)
    .map_err(|e| CleanroomError::template_error(
        format!("Template rendering failed in '{}': {}", name, e)
    ))
```

**2. Function Parameter Errors**:
```rust
let seed = args.get("seed")
    .and_then(|v| v.as_u64())
    .ok_or_else(|| tera::Error::msg(
        "fake_uuid_seeded() requires 'seed' parameter of type u64"
    ))?;
```

**3. Environment Variable Errors**:
```rust
std::env::var(name)
    .map(Value::String)
    .map_err(|_| tera::Error::msg(
        format!("Environment variable '{}' not found. Use env(name=\"{}\") in template.", name, name)
    ))
```

**4. Chain Context**:
```rust
renderer.render_str(&content, path.to_str().unwrap_or("unknown"))
    .map_err(|e| e.with_context(
        format!("File: {}, Line: {}", path.display(), line_num)
    ))
```

### Error Message Examples

**Good Error Message**:
```
Error: Template rendering failed
  ┌─ tests/load-test.clnrm.toml.tera:15:20
  │
15│ name = "{{ fake_person() }}"
  │             ^^^^^^^^^^^ unknown function
  │
  = help: Did you mean 'fake_name()'?
  = note: Available functions: fake_uuid, fake_name, fake_email, random_int
  = note: Use `clnrm template list-functions` to see all available functions
```

**Bad Error Message**:
```
Error: TemplateError: unknown function
```

### Error Recovery

**No recovery for template errors** - fail fast:
- Template syntax errors → abort config loading
- Function errors → abort rendering
- TOML parsing errors after rendering → abort with rendered output for debugging

---

## Data Flow

### Template Rendering Pipeline

```
┌─────────────────────────────────────────────────────────────────┐
│                     1. File Detection                            │
│  load_config_from_file(path)                                    │
│  ├─ Read file contents                                          │
│  ├─ Check extension (.tera, .toml.tera)                        │
│  └─ Check content for template syntax ({{, {%, {#)            │
└────────────────────┬─────────────────────────────────────────────┘
                     │
        ┌────────────┴──────────────┐
        │ Is Template?              │
        └────────────┬──────────────┘
                     │
        ┌────────────┼───────────────┐
        │ NO         │ YES           │
        ▼            ▼               │
   ┌─────────┐  ┌──────────────────────────────────────┐
   │ TOML    │  │ 2. Template Rendering                │
   │ Text    │  │  TemplateRenderer::render_str()       │
   │         │  │  ├─ Initialize Tera with functions   │
   │         │  │  ├─ Build context (vars, matrix, otel)│
   │         │  │  ├─ Render template → String          │
   │         │  │  └─ Handle errors                     │
   └────┬────┘  └──────────────┬───────────────────────┘
        │                      │
        │                      ▼
        │            ┌──────────────────┐
        │            │ Rendered TOML    │
        │            │ Text             │
        │            └────────┬─────────┘
        │                     │
        └─────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────┐
│ 3. TOML Parsing (UNCHANGED)                           │
│  parse_toml_config(content)                           │
│  ├─ Parse with toml crate                             │
│  ├─ Deserialize to TestConfig                         │
│  └─ Return TestConfig or CleanroomError               │
└────────────────────┬───────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────┐
│ 4. Validation (UNCHANGED)                             │
│  config.validate()                                     │
│  ├─ Validate metadata                                  │
│  ├─ Validate services                                  │
│  ├─ Validate steps                                     │
│  └─ Return Ok(()) or CleanroomError                   │
└────────────────────┬───────────────────────────────────┘
                     │
                     ▼
              ┌──────────────┐
              │ TestConfig   │
              │ (Ready)      │
              └──────────────┘
```

### Function Call Flow

```
Template: {{ fake_uuid() }}
         │
         ▼
┌────────────────────────┐
│ Tera::render_str()     │
│ - Parse template       │
│ - Identify function    │
└────────┬───────────────┘
         │
         ▼
┌────────────────────────────────┐
│ Function Registry Lookup       │
│ - Find "fake_uuid" function    │
│ - Check parameters (none)      │
└────────┬───────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ generators::fake_uuid()         │
│ - Generate UUID v4              │
│ - Return String                 │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ Value::String("550e8400-...")   │
│ - Convert to Tera Value         │
└────────┬────────────────────────┘
         │
         ▼
Rendered: 550e8400-e29b-41d4-a716-446655440000
```

---

## Security Architecture

### Threat Model

| Threat | Mitigation | Status |
|--------|------------|--------|
| **Template Injection** | No file inclusion, sandboxed functions | ✅ Design |
| **Secrets in Templates** | Lint warnings, env_var() function | ✅ Design |
| **Arbitrary Code Execution** | Pure functions only, no I/O | ✅ Design |
| **DoS via Infinite Loops** | Tera default timeouts | ✅ Tera Built-in |
| **Path Traversal** | No file system access in functions | ✅ Design |

### Security Controls

**1. Sandboxed Template Functions**:
```rust
// ✅ SAFE - Pure function, no I/O
pub fn fake_uuid() -> String {
    Uuid::new_v4().to_string()
}

// ❌ FORBIDDEN - I/O operations
pub fn read_file(path: &str) -> String {
    std::fs::read_to_string(path).unwrap() // NEVER DO THIS
}
```

**2. Environment Variable Access**:
```rust
// Only allowed through env() function with explicit naming
{{ env(name="DB_PASSWORD") }}

// Environment variable names must be literal strings (no computed names)
```

**3. No Template Inheritance**:
```rust
// ❌ DISABLED - File inclusion disabled
{% include "other_template.tera" %}

// ✅ ALLOWED - Inline macros only
{% macro test_step(name) %}
[[steps]]
name = "{{ name }}"
{% endmacro %}
```

**4. Secret Detection**:
```rust
// Lint rule: Warn on common secret patterns
password = "..."      // ⚠️ WARNING: Hardcoded secret detected
api_key = "..."       // ⚠️ WARNING: Hardcoded secret detected
token = "..."         // ⚠️ WARNING: Hardcoded secret detected

// ✅ RECOMMENDED
password = "{{ env(name='DB_PASSWORD') }}"
```

---

## Performance Considerations

### Rendering Performance

**Baseline Measurements** (Target):
- Empty template: < 1ms
- Simple template (10 variables): < 5ms
- Medium template (100 steps): < 50ms
- Large template (1000 steps): < 100ms

### Optimization Strategies

**1. Function Registration Caching**:
```rust
// Tera engine initialized once, reused for multiple renders
lazy_static! {
    static ref TERA_ENGINE: Mutex<Tera> = {
        let mut tera = Tera::default();
        registry::register_all_functions(&mut tera).unwrap();
        Mutex::new(tera)
    };
}
```

**2. Random Seed Optimization**:
```rust
// Seeded RNG reused within same template render
pub struct SeededRngCache {
    rng: StdRng,
}

impl SeededRngCache {
    pub fn new(seed: u64) -> Self {
        Self {
            rng: StdRng::seed_from_u64(seed),
        }
    }
}
```

**3. Memory Management**:
```rust
// Large templates: Stream rendering for massive outputs (future)
// Current: Entire template rendered to String (acceptable for v0.6.0)
```

### Performance Metrics

```rust
#[cfg(feature = "otel-metrics")]
{
    use clnrm_core::telemetry::metrics;

    let start = std::time::Instant::now();
    let rendered = renderer.render_str(template, name)?;
    let duration_ms = start.elapsed().as_millis() as f64;

    metrics::record_test_duration("template_render", duration_ms, true);
}
```

---

## Testing Strategy

### Unit Tests (Per Module)

**template/generators.rs**:
```rust
#[test]
fn test_fake_uuid_is_valid() {
    let uuid = fake_uuid();
    assert!(Uuid::parse_str(&uuid).is_ok());
}

#[test]
fn test_fake_uuid_seeded_deterministic() {
    let uuid1 = fake_uuid_seeded(42);
    let uuid2 = fake_uuid_seeded(42);
    assert_eq!(uuid1, uuid2);
}

#[test]
fn test_random_int_bounds() {
    for _ in 0..1000 {
        let val = random_int(10, 20);
        assert!(val >= 10 && val <= 20);
    }
}
```

**template/registry.rs**:
```rust
#[test]
fn test_all_functions_registered() {
    let mut tera = Tera::default();
    let result = register_all_functions(&mut tera);
    assert!(result.is_ok());

    // Verify functions are callable
    let template = "{{ fake_uuid() }}";
    let rendered = tera.render_str(template, &Context::new());
    assert!(rendered.is_ok());
}
```

### Integration Tests

**tests/template_integration.rs**:
```rust
#[test]
fn test_load_template_toml_file() {
    let template = r#"
[test.metadata]
name = "{{ fake_name() }}"

[[steps]]
name = "step_1"
command = ["echo", "{{ fake_uuid() }}"]
"#;

    let temp_file = NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), template).unwrap();

    let config = load_config_from_file(temp_file.path()).unwrap();
    assert!(!config.test.metadata.name.is_empty());
    assert_eq!(config.steps.len(), 1);
}

#[test]
fn test_property_based_template_100_steps() {
    let template = r#"
[test.metadata]
name = "property_test"

{% for i in range(end=100) %}
[[steps]]
name = "step_{{ i }}"
command = ["echo", "{{ i }}"]
{% endfor %}
"#;

    let temp_file = NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), template).unwrap();

    let config = load_config_from_file(temp_file.path()).unwrap();
    assert_eq!(config.steps.len(), 100);
}
```

### Property-Based Tests

```rust
#[cfg(feature = "proptest")]
mod property_tests {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn random_int_never_panics(min in -1000i64..1000, max in -1000i64..1000) {
            if min <= max {
                let val = random_int(min, max);
                assert!(val >= min && val <= max);
            }
        }

        #[test]
        fn random_string_correct_length(len in 0usize..1000) {
            let s = random_string(len);
            assert_eq!(s.len(), len);
        }

        #[test]
        fn fake_uuid_seeded_always_valid(seed in any::<u64>()) {
            let uuid_str = fake_uuid_seeded(seed);
            assert!(Uuid::parse_str(&uuid_str).is_ok());
        }
    }
}
```

### Test Coverage Targets

| Module | Unit Tests | Integration Tests | Property Tests | Target Coverage |
|--------|-----------|-------------------|----------------|-----------------|
| template/mod.rs | ✅ 100% | ✅ Yes | N/A | 100% |
| template/context.rs | ✅ 100% | ✅ Yes | N/A | 100% |
| template/determinism.rs | ✅ 100% | N/A | N/A | 100% |
| template/functions.rs | ✅ 100% | ✅ Yes | N/A | 100% |
| template/generators.rs | 🔴 NEW | 🔴 NEW | 🔴 NEW | > 90% |
| template/registry.rs | 🔴 NEW | 🔴 NEW | N/A | > 90% |
| config.rs (modified) | ✅ Existing | ✅ Existing | N/A | Maintain |

---

## Implementation Roadmap

### Phase 1: Fake Data Generators (3-4 days)

**Tasks**:
1. Create `template/generators.rs` module
2. Implement UUID generators (fake_uuid, fake_uuid_seeded)
3. Implement person data (fake_name, fake_email)
4. Implement time functions (fake_timestamp)
5. Implement network functions (fake_ipv4)
6. Add comprehensive unit tests (100+ test cases)
7. Add deterministic seeded variants

**Deliverables**:
- [ ] `template/generators.rs` (< 400 lines)
- [ ] All generators with seeded variants
- [ ] Unit tests (> 90% coverage)
- [ ] Documentation comments

### Phase 2: Random Value Generators (2-3 days)

**Tasks**:
1. Implement random_int(min, max)
2. Implement random_string(length)
3. Implement random_bool()
4. Implement random_choice(items)
5. Add seeded variants for all
6. Add property-based tests
7. Add bounds checking tests

**Deliverables**:
- [ ] Random generators in `template/generators.rs`
- [ ] Property-based tests (160K+ generated test cases)
- [ ] Bounds validation tests

### Phase 3: Function Registry (1-2 days)

**Tasks**:
1. Create `template/registry.rs` module
2. Implement `register_all_functions()`
3. Organize registration by category
4. Add Tera function wrappers for all generators
5. Add integration tests
6. Document function registry

**Deliverables**:
- [ ] `template/registry.rs` (< 150 lines)
- [ ] All functions registered
- [ ] Integration tests

### Phase 4: Config Integration (2-3 days)

**Tasks**:
1. Modify `config.rs::load_config_from_file()`
2. Implement `is_template_file()` helper
3. Add template rendering step
4. Update error messages
5. Add integration tests with full pipeline
6. Test backward compatibility

**Deliverables**:
- [ ] Modified `config.rs`
- [ ] `is_template_file()` function
- [ ] Integration tests
- [ ] Backward compatibility verification

### Phase 5: Documentation & Examples (2-3 days)

**Tasks**:
1. Create `docs/TEMPLATE_GUIDE.md`
2. Update `docs/TOML_REFERENCE.md`
3. Create example templates in `examples/templating/`
4. Add CLI help for template commands
5. Create function reference table
6. Add migration guide

**Deliverables**:
- [ ] Complete documentation
- [ ] 5+ example templates
- [ ] Function reference
- [ ] Migration guide

### Phase 6: Testing & Validation (2-3 days)

**Tasks**:
1. Run full test suite
2. Run property-based tests (160K+ cases)
3. Performance benchmarking
4. Security audit (template injection testing)
5. Backward compatibility verification
6. Framework self-test update

**Deliverables**:
- [ ] All tests passing
- [ ] Performance benchmarks
- [ ] Security audit report
- [ ] Self-test validation

### Total Timeline: 12-18 days (2.5-3.5 weeks)

---

## Acceptance Criteria

### Definition of Done

- [ ] All fake data generators implemented (UUID, name, email, timestamp, IP)
- [ ] All random generators implemented (int, string, bool, choice)
- [ ] Function registry complete with all functions
- [ ] `config.rs` modified to support template rendering
- [ ] File extension detection (.tera, .toml.tera) working
- [ ] All error scenarios handled with helpful messages
- [ ] Unit tests for all functions (> 90% coverage)
- [ ] Integration tests with full TOML templates
- [ ] Property-based tests for random generators (160K+ cases)
- [ ] End-to-end test with 100+ generated scenarios
- [ ] Documentation complete (TEMPLATE_GUIDE.md, examples)
- [ ] No breaking changes to existing TOML files
- [ ] `cargo clippy -- -D warnings` passes with zero warnings
- [ ] `cargo test` passes all tests
- [ ] Framework self-test validates templating feature
- [ ] Performance: < 100ms for 1000-step template
- [ ] Security: No template injection vulnerabilities
- [ ] All files < 500 lines (modular design)
- [ ] No `.unwrap()` or `.expect()` in production code

---

## Appendix A: Complete Function Registry

### Existing Functions (Implemented)

| Function | Parameters | Returns | Example |
|----------|------------|---------|---------|
| `env(name)` | `name: String` | String | `{{ env(name="HOME") }}` |
| `now_rfc3339()` | None | String | `{{ now_rfc3339() }}` → `"2025-10-16T00:00:00Z"` |
| `sha256(s)` | `s: String` | String | `{{ sha256(s="hello") }}` → `"2cf24dba..."` |
| `toml_encode(value)` | `value: Any` | String | `{{ toml_encode(value="test") }}` → `"test"` |

### New Functions (To Implement)

| Function | Parameters | Returns | Example |
|----------|------------|---------|---------|
| `fake_uuid()` | None | String | `"550e8400-e29b-41d4-a716-446655440000"` |
| `fake_uuid_seeded(seed)` | `seed: u64` | String | `fake_uuid_seeded(seed=42)` |
| `fake_name()` | None | String | `"Alice Smith"` |
| `fake_name_seeded(seed)` | `seed: u64` | String | `fake_name_seeded(seed=42)` |
| `fake_email()` | None | String | `"test_123@example.com"` |
| `fake_email_seeded(seed)` | `seed: u64` | String | `fake_email_seeded(seed=42)` |
| `fake_timestamp()` | None | i64 | `1729123456` (seconds) |
| `fake_timestamp_ms()` | None | i64 | `1729123456789` (milliseconds) |
| `fake_ipv4()` | None | String | `"192.168.1.42"` |
| `fake_ipv4_seeded(seed)` | `seed: u64` | String | `fake_ipv4_seeded(seed=42)` |
| `random_int(min, max)` | `min: i64, max: i64` | i64 | `random_int(min=1, max=100)` → `42` |
| `random_int_seeded(seed, min, max)` | `seed: u64, min: i64, max: i64` | i64 | Deterministic |
| `random_string(length)` | `length: usize` | String | `random_string(length=10)` → `"a3kJ9zX2mP"` |
| `random_string_seeded(seed, length)` | `seed: u64, length: usize` | String | Deterministic |
| `random_bool()` | None | bool | `true` or `false` |
| `random_bool_seeded(seed)` | `seed: u64` | bool | Deterministic |
| `random_choice(items)` | `items: Vec<String>` | String | `random_choice(items=["a","b"])` |
| `random_choice_seeded(seed, items)` | `seed: u64, items: Vec<String>` | String | Deterministic |
| `property_range(start, end)` | `start: i64, end: i64` | Vec<i64> | `property_range(start=0, end=5)` → `[0,1,2,3,4,5]` |

---

## Appendix B: Dependencies

### New Cargo Dependencies

```toml
[dependencies]
# Existing (already in Cargo.toml)
tera = "1.19"           # ✅ Already added
sha2 = "0.10"           # ✅ Already added
chrono = "0.4"          # ✅ Already added

# New (to add)
uuid = { version = "1.10", features = ["v4", "serde"] }  # 🔴 NEW
rand = "0.8"                                              # 🔴 NEW

[dev-dependencies]
# Existing
proptest = "1.0"        # ✅ Already added for property tests
tempfile = "3.8"        # ✅ Already added for test files
```

---

## Appendix C: File Structure After Implementation

```
crates/clnrm-core/
├── src/
│   ├── template/
│   │   ├── mod.rs              ✅ EXISTING (147 lines)
│   │   ├── context.rs          ✅ EXISTING (170 lines)
│   │   ├── determinism.rs      ✅ EXISTING (178 lines)
│   │   ├── functions.rs        ✅ EXISTING (382 lines)
│   │   ├── generators.rs       🔴 NEW (< 400 lines)
│   │   └── registry.rs         🔴 NEW (< 150 lines)
│   ├── config.rs               🟡 MODIFY (+50 lines)
│   ├── error.rs                ✅ READY (TemplateError exists)
│   └── lib.rs                  ✅ READY (exports template module)
├── tests/
│   ├── template_integration.rs 🔴 NEW
│   └── property_tests.rs       🟡 MODIFY (add template tests)
└── Cargo.toml                  🟡 MODIFY (add uuid, rand)

examples/
└── templating/                 🔴 NEW
    ├── load-test.clnrm.toml.tera
    ├── chaos-random.clnrm.toml.tera
    ├── db-property-test.clnrm.toml.tera
    └── deterministic-property.clnrm.toml.tera

docs/
├── TEMPLATE_GUIDE.md           🔴 NEW
└── TOML_REFERENCE.md           🟡 MODIFY (add templating section)
```

---

## Conclusion

This architecture provides a complete, production-ready design for v0.6.0 Tera templating features. The design:

1. **Builds on existing implementation** - Extends current template system
2. **Maintains backward compatibility** - All existing TOML files work unchanged
3. **Follows CLNRM principles** - Modular design, dyn-compatible traits, no unwrap()
4. **Provides powerful features** - Property-based testing, fake data, deterministic generation
5. **Handles errors gracefully** - Clear, actionable error messages
6. **Thoroughly tested** - Unit, integration, property-based, and E2E tests

**Next Steps**:
1. Review and approve this architecture
2. Begin Phase 1 implementation (Fake Data Generators)
3. Iterate based on testing feedback
4. Deploy v0.6.0 with complete templating support

**Estimated Completion**: 2.5-3.5 weeks for full implementation and testing.

---

**Document Status**: ✅ READY FOR REVIEW
**Implementation Status**: 🟡 PARTIALLY IMPLEMENTED (40% complete)
**Approval**: Pending Architecture Sub-Coordinator

