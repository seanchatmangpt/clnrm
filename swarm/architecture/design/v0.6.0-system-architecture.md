# CLNRM v0.6.0 System Architecture Design

**Document Type**: System Architecture Design
**Version**: 0.6.0
**Date**: 2025-10-16
**Status**: DESIGN PHASE - PARTIAL IMPLEMENTATION
**Architect**: System Designer (Architecture Sub-Coordinator)

## Executive Summary

This document defines the complete system architecture for v0.6.0, focusing on the Tera templating integration that enables property-based testing and dynamic test generation. The architecture builds upon existing partial implementation and extends it with production-ready features.

**Current State**: Template system is partially implemented with basic Tera functions.
**Target State**: Complete templating system with fake data generators, property-based testing support, and seamless TOML integration.

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture Principles](#architecture-principles)
3. [Module Structure](#module-structure)
4. [Component Architecture](#component-architecture)
5. [Integration Points](#integration-points)
6. [Plugin Interfaces](#plugin-interfaces)
7. [Error Handling Strategy](#error-handling-strategy)
8. [Data Flow](#data-flow)
9. [Security Architecture](#security-architecture)
10. [Performance Considerations](#performance-considerations)
11. [Testing Strategy](#testing-strategy)
12. [Implementation Roadmap](#implementation-roadmap)

---

## System Overview

### Goals

1. **Property-Based Testing**: Generate hundreds/thousands of test scenarios with parameterized templates
2. **Fake Data Generation**: Built-in generators for UUIDs, names, emails, timestamps, IP addresses
3. **Template Detection**: Automatic detection and rendering of `.tera` and `.toml.tera` files
4. **Backward Compatibility**: All existing `.clnrm.toml` files work unchanged
5. **Clean Integration**: Minimal changes to existing config pipeline

### Non-Goals

- Runtime template rendering (templates render at config load time only)
- Dynamic variables from test execution results
- GUI template builder (CLI only for v0.6.0)
- Template inheritance beyond Tera's built-in features

### Quality Attributes

| Attribute | Target | Measurement |
|-----------|--------|-------------|
| **Performance** | < 100ms for 1000-step template | Benchmark tests |
| **Reliability** | 100% deterministic with seeds | Property tests |
| **Maintainability** | Files < 500 lines | Clippy + metrics |
| **Compatibility** | Zero breaking changes | Integration tests |
| **Security** | No template injection | Security audit |

---

## Architecture Principles

### 1. Modular Design (Files < 500 Lines)

```
template/
â”œâ”€â”€ mod.rs           (147 lines) âœ…
â”œâ”€â”€ context.rs       (170 lines) âœ…
â”œâ”€â”€ determinism.rs   (178 lines) âœ…
â”œâ”€â”€ functions.rs     (382 lines) âœ…
â””â”€â”€ generators.rs    (NEW - fake data generators)
```

### 2. dyn-Compatible Traits (No Async Methods)

All trait methods MUST be synchronous to maintain `dyn` compatibility:

```rust
// âœ… CORRECT - dyn compatible
pub trait TemplateFunction {
    fn call(&self, args: &HashMap<String, Value>) -> Result<Value>;
}

// âŒ WRONG - breaks dyn compatibility
pub trait TemplateFunction {
    async fn call(&self, args: &HashMap<String, Value>) -> Result<Value>;
}
```

### 3. Clean Separation of Concerns

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Config Layer (config.rs)              â”‚
â”‚  - File loading                        â”‚
â”‚  - Template detection                  â”‚
â”‚  - TOML parsing                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Template Layer (template/)            â”‚
â”‚  - Tera engine management              â”‚
â”‚  - Function registration               â”‚
â”‚  - Context management                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Generator Layer (template/generators) â”‚
â”‚  - Fake data generation                â”‚
â”‚  - Random value generation             â”‚
â”‚  - Deterministic seeding               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Environment Safety (No Hardcoded Secrets)

```rust
// âœ… CORRECT - Environment variable
{{ env(name="DB_PASSWORD") }}

// âŒ WRONG - Hardcoded secret
password = "mysecret123"
```

### 5. Fail Fast with Clear Errors

```rust
// All errors must be CleanroomError with context
.map_err(|e| CleanroomError::template_error(
    format!("Template rendering failed: {}", e)
).with_context(format!("File: {}, Line: {}", path, line_num)))
```

---

## Module Structure

### Current Implementation (Existing)

```
crates/clnrm-core/src/
â”œâ”€â”€ template/
â”‚   â”œâ”€â”€ mod.rs              âœ… IMPLEMENTED (147 lines)
â”‚   â”‚   â””â”€â”€ TemplateRenderer, is_template()
â”‚   â”œâ”€â”€ context.rs          âœ… IMPLEMENTED (170 lines)
â”‚   â”‚   â””â”€â”€ TemplateContext (vars, matrix, otel namespaces)
â”‚   â”œâ”€â”€ determinism.rs      âœ… IMPLEMENTED (178 lines)
â”‚   â”‚   â””â”€â”€ DeterminismConfig (seed, freeze_clock)
â”‚   â””â”€â”€ functions.rs        âœ… IMPLEMENTED (382 lines)
â”‚       â””â”€â”€ env(), now_rfc3339(), sha256(), toml_encode()
```

### Required Extensions (New)

```
crates/clnrm-core/src/
â”œâ”€â”€ template/
â”‚   â”œâ”€â”€ generators.rs       ğŸ”´ NEW (fake data generators)
â”‚   â”‚   â”œâ”€â”€ fake_uuid()
â”‚   â”‚   â”œâ”€â”€ fake_uuid_seeded(seed)
â”‚   â”‚   â”œâ”€â”€ fake_name()
â”‚   â”‚   â”œâ”€â”€ fake_email()
â”‚   â”‚   â”œâ”€â”€ fake_timestamp()
â”‚   â”‚   â”œâ”€â”€ fake_ipv4()
â”‚   â”‚   â”œâ”€â”€ random_int(min, max)
â”‚   â”‚   â”œâ”€â”€ random_string(length)
â”‚   â”‚   â”œâ”€â”€ random_bool()
â”‚   â”‚   â””â”€â”€ random_choice(items)
â”‚   â””â”€â”€ registry.rs         ğŸ”´ NEW (function registry)
â”‚       â””â”€â”€ register_all_functions(tera)
â”œâ”€â”€ config.rs               ğŸŸ¡ MODIFY (add template detection)
â”‚   â””â”€â”€ load_config_from_file() - add template rendering step
â””â”€â”€ error.rs                âœ… READY (TemplateError already exists)
```

### File Size Budget

| File | Current | Target | Status |
|------|---------|--------|--------|
| template/mod.rs | 147 | < 200 | âœ… Good |
| template/context.rs | 170 | < 200 | âœ… Good |
| template/determinism.rs | 178 | < 200 | âœ… Good |
| template/functions.rs | 382 | < 500 | âœ… Good |
| template/generators.rs | 0 | < 400 | ğŸ”´ New |
| template/registry.rs | 0 | < 150 | ğŸ”´ New |

---

## Component Architecture

### 1. Template Renderer (`template/mod.rs`)

**Responsibilities**:
- Initialize Tera engine
- Manage template context
- Render template strings to TOML
- Handle rendering errors

**Public API**:
```rust
pub struct TemplateRenderer {
    tera: Tera,
    context: TemplateContext,
}

impl TemplateRenderer {
    pub fn new() -> Result<Self>;
    pub fn with_context(self, context: TemplateContext) -> Self;
    pub fn render_file(&mut self, path: &Path) -> Result<String>;
    pub fn render_str(&mut self, template: &str, name: &str) -> Result<String>;
}

pub fn is_template(content: &str) -> bool;
```

**Dependencies**:
- `tera`: Template engine
- `template::context`: Context management
- `template::registry`: Function registration

### 2. Template Context (`template/context.rs`)

**Responsibilities**:
- Manage template variables (vars, matrix, otel namespaces)
- Convert to Tera context for rendering
- Provide builder pattern for context construction

**Public API**:
```rust
pub struct TemplateContext {
    pub vars: HashMap<String, Value>,
    pub matrix: HashMap<String, Value>,
    pub otel: HashMap<String, Value>,
}

impl TemplateContext {
    pub fn new() -> Self;
    pub fn with_vars(self, vars: HashMap<String, Value>) -> Self;
    pub fn with_matrix(self, matrix: HashMap<String, Value>) -> Self;
    pub fn with_otel(self, otel: HashMap<String, Value>) -> Self;
    pub fn to_tera_context(&self) -> Result<Context>;
    pub fn add_var(&mut self, key: String, value: Value);
    pub fn add_matrix_param(&mut self, key: String, value: Value);
    pub fn add_otel_config(&mut self, key: String, value: Value);
}
```

### 3. Determinism Config (`template/determinism.rs`)

**Responsibilities**:
- Provide deterministic test execution configuration
- Support fixed random seeds
- Support frozen timestamps

**Public API**:
```rust
pub struct DeterminismConfig {
    pub seed: Option<u64>,
    pub freeze_clock: Option<String>,
}

impl DeterminismConfig {
    pub fn new() -> Self;
    pub fn with_seed(self, seed: u64) -> Self;
    pub fn with_freeze_clock(self, timestamp: String) -> Self;
    pub fn is_deterministic(&self) -> bool;
    pub fn has_seed(&self) -> bool;
    pub fn has_frozen_clock(&self) -> bool;
    pub fn get_seed(&self) -> Option<u64>;
    pub fn get_freeze_clock(&self) -> Option<&str>;
}
```

### 4. Template Functions (`template/functions.rs`)

**Current Functions** (Implemented):
- `env(name)` - Get environment variable
- `now_rfc3339()` - Current timestamp (respects freeze_clock)
- `sha256(s)` - SHA-256 hex digest
- `toml_encode(value)` - Encode as TOML literal

**Architecture**:
```rust
pub fn register_functions(tera: &mut Tera) -> Result<()>;

struct EnvFunction;
impl Function for EnvFunction {
    fn call(&self, args: &HashMap<String, Value>) -> tera::Result<Value>;
}

struct NowRfc3339Function {
    frozen: Arc<Mutex<Option<String>>>,
}
impl Function for NowRfc3339Function {
    fn call(&self, args: &HashMap<String, Value>) -> tera::Result<Value>;
}
```

### 5. Fake Data Generators (`template/generators.rs`) ğŸ”´ NEW

**Responsibilities**:
- Generate fake UUIDs, names, emails, timestamps, IPs
- Generate random integers, strings, booleans
- Support deterministic generation with seeds
- Provide property test helpers

**Public API**:
```rust
// UUID Generators
pub fn fake_uuid() -> String;
pub fn fake_uuid_seeded(seed: u64) -> String;

// Person Data Generators
pub fn fake_name() -> String;
pub fn fake_name_seeded(seed: u64) -> String;
pub fn fake_email() -> String;
pub fn fake_email_seeded(seed: u64) -> String;

// Time Generators
pub fn fake_timestamp() -> i64;
pub fn fake_timestamp_ms() -> i64;

// Network Generators
pub fn fake_ipv4() -> String;
pub fn fake_ipv4_seeded(seed: u64) -> String;

// Random Value Generators
pub fn random_int(min: i64, max: i64) -> i64;
pub fn random_int_seeded(seed: u64, min: i64, max: i64) -> i64;
pub fn random_string(length: usize) -> String;
pub fn random_string_seeded(seed: u64, length: usize) -> String;
pub fn random_bool() -> bool;
pub fn random_bool_seeded(seed: u64) -> bool;
pub fn random_choice(items: Vec<String>) -> String;
pub fn random_choice_seeded(seed: u64, items: Vec<String>) -> String;

// Property Test Helpers
pub fn property_range(start: i64, end: i64) -> Vec<i64>;
```

**Implementation Strategy**:
```rust
use rand::{Rng, SeedableRng};
use uuid::Uuid;

// Non-deterministic (uses thread_rng)
pub fn fake_uuid() -> String {
    Uuid::new_v4().to_string()
}

// Deterministic (uses seeded RNG)
pub fn fake_uuid_seeded(seed: u64) -> String {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let bytes: [u8; 16] = rng.gen();
    Uuid::from_bytes(bytes).to_string()
}

const FIRST_NAMES: &[&str] = &[
    "Alice", "Bob", "Charlie", "Diana", "Emma", "Frank",
    "Grace", "Henry", "Iris", "Jack", "Kate", "Leo"
];

const LAST_NAMES: &[&str] = &[
    "Smith", "Johnson", "Williams", "Brown", "Jones",
    "Garcia", "Miller", "Davis", "Rodriguez", "Martinez"
];

pub fn fake_name() -> String {
    let mut rng = rand::thread_rng();
    let first = FIRST_NAMES[rng.gen_range(0..FIRST_NAMES.len())];
    let last = LAST_NAMES[rng.gen_range(0..LAST_NAMES.len())];
    format!("{} {}", first, last)
}

pub fn fake_name_seeded(seed: u64) -> String {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let first = FIRST_NAMES[rng.gen_range(0..FIRST_NAMES.len())];
    let last = LAST_NAMES[rng.gen_range(0..LAST_NAMES.len())];
    format!("{} {}", first, last)
}
```

### 6. Function Registry (`template/registry.rs`) ğŸ”´ NEW

**Responsibilities**:
- Register all template functions with Tera
- Organize function registration in logical groups
- Handle registration errors

**Public API**:
```rust
pub fn register_all_functions(tera: &mut Tera) -> Result<()>;

// Private helper functions
fn register_env_functions(tera: &mut Tera) -> Result<()>;
fn register_time_functions(tera: &mut Tera) -> Result<()>;
fn register_crypto_functions(tera: &mut Tera) -> Result<()>;
fn register_fake_data_functions(tera: &mut Tera) -> Result<()>;
fn register_random_functions(tera: &mut Tera) -> Result<()>;
fn register_property_test_functions(tera: &mut Tera) -> Result<()>;
```

**Implementation**:
```rust
pub fn register_all_functions(tera: &mut Tera) -> Result<()> {
    // Existing functions (from functions.rs)
    functions::register_functions(tera)?;

    // Fake data generators
    register_fake_data_functions(tera)?;

    // Random value generators
    register_random_functions(tera)?;

    // Property test helpers
    register_property_test_functions(tera)?;

    Ok(())
}

fn register_fake_data_functions(tera: &mut Tera) -> Result<()> {
    use tera::Function;
    use generators::*;

    // fake_uuid()
    tera.register_function("fake_uuid", Box::new(|_args| {
        Ok(Value::String(fake_uuid()))
    }));

    // fake_uuid_seeded(seed)
    tera.register_function("fake_uuid_seeded", Box::new(|args| {
        let seed = args.get("seed")
            .and_then(|v| v.as_u64())
            .ok_or_else(|| tera::Error::msg("fake_uuid_seeded requires 'seed' parameter"))?;
        Ok(Value::String(fake_uuid_seeded(seed)))
    }));

    // fake_name()
    tera.register_function("fake_name", Box::new(|_args| {
        Ok(Value::String(fake_name()))
    }));

    // ... more registrations

    Ok(())
}
```

---

## Integration Points

### 1. Config Loading Pipeline Modification

**Current Implementation** (`config.rs:681-689`):
```rust
pub fn load_config_from_file(path: &std::path::Path) -> Result<TestConfig> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| CleanroomError::config_error(format!("Failed to read config file: {}", e)))?;

    let config = parse_toml_config(&content)?;
    config.validate()?;

    Ok(config)
}
```

**Proposed Implementation** ğŸŸ¡ MODIFY:
```rust
pub fn load_config_from_file(path: &std::path::Path) -> Result<TestConfig> {
    // Read raw file contents
    let content = std::fs::read_to_string(path)
        .map_err(|e| CleanroomError::config_error(
            format!("Failed to read config file '{}': {}", path.display(), e)
        ))?;

    // Check if template rendering is needed
    let rendered_content = if is_template_file(path, &content) {
        // Render template before parsing
        let mut renderer = TemplateRenderer::new()
            .map_err(|e| CleanroomError::config_error(
                format!("Failed to initialize template renderer: {}", e)
            ))?;

        renderer.render_str(&content, path.to_str().unwrap_or("unknown"))
            .map_err(|e| CleanroomError::template_error(
                format!("Template rendering failed for '{}': {}", path.display(), e)
            ))?
    } else {
        // No template rendering needed
        content
    };

    // Parse TOML (unchanged)
    let config = parse_toml_config(&rendered_content)?;

    // Validate (unchanged)
    config.validate()?;

    Ok(config)
}

/// Check if file should be treated as a template
fn is_template_file(path: &std::path::Path, content: &str) -> bool {
    // Check file extension first
    if let Some(ext) = path.extension() {
        if ext == "tera" {
            return true;
        }
    }

    // Check for .toml.tera double extension
    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
        if name.ends_with(".toml.tera") {
            return true;
        }
    }

    // Check content for template syntax
    template::is_template(content)
}
```

**Changes Required**:
1. Add `is_template_file()` helper function
2. Add template rendering step before TOML parsing
3. Preserve existing error handling patterns
4. No changes to `parse_toml_config()` or `validate()`

### 2. TemplateRenderer Initialization

**Modification to `template/mod.rs`**:
```rust
impl TemplateRenderer {
    pub fn new() -> Result<Self> {
        let mut tera = Tera::default();

        // Register ALL functions (existing + new)
        registry::register_all_functions(&mut tera)?;

        Ok(Self {
            tera,
            context: TemplateContext::new(),
        })
    }
}
```

---

## Plugin Interfaces

### Template Function Plugin Trait

All template functions implement Tera's `Function` trait:

```rust
use tera::Function;
use std::collections::HashMap;

pub trait Function {
    fn call(&self, args: &HashMap<String, Value>) -> tera::Result<Value>;
}
```

### Custom Filter Plugin Trait

Filters implement Tera's `Filter` trait:

```rust
use tera::Filter;

pub trait Filter {
    fn filter(&self, value: &Value, args: &HashMap<String, Value>) -> tera::Result<Value>;
}
```

### Adding New Template Functions

**Steps to add a new function**:

1. **Implement the function** in `template/generators.rs`:
```rust
pub fn fake_port() -> u16 {
    let mut rng = rand::thread_rng();
    rng.gen_range(1024..65535)
}
```

2. **Register in `template/registry.rs`**:
```rust
tera.register_function("fake_port", Box::new(|_args| {
    Ok(Value::Number(generators::fake_port().into()))
}));
```

3. **Add tests** in `template/generators.rs`:
```rust
#[test]
fn test_fake_port() {
    let port = fake_port();
    assert!(port >= 1024 && port < 65535);
}
```

4. **Document** in function registry table

### Extension Points

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Template Function Extension Point         â”‚
â”‚                                            â”‚
â”‚  1. Implement generator function           â”‚
â”‚  2. Register with Tera via registry        â”‚
â”‚  3. Add unit tests                         â”‚
â”‚  4. Update documentation                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Error Handling Strategy

### Error Taxonomy

```
CleanroomError::TemplateError
â”œâ”€â”€ Template Syntax Error
â”‚   â”œâ”€â”€ Unclosed {{ }} or {% %}
â”‚   â”œâ”€â”€ Unknown function call
â”‚   â””â”€â”€ Invalid control structure
â”œâ”€â”€ Function Execution Error
â”‚   â”œâ”€â”€ Missing required parameter
â”‚   â”œâ”€â”€ Invalid parameter type
â”‚   â”œâ”€â”€ Environment variable not found
â”‚   â””â”€â”€ File not found
â”œâ”€â”€ Rendering Error
â”‚   â”œâ”€â”€ Context missing required variable
â”‚   â”œâ”€â”€ Type mismatch in template
â”‚   â””â”€â”€ Infinite loop detected
â””â”€â”€ Post-Rendering Error
    â”œâ”€â”€ Generated invalid TOML syntax
    â”œâ”€â”€ TOML parsing failed
    â””â”€â”€ Validation failed after rendering
```

### Error Handling Patterns

**1. Template Syntax Errors**:
```rust
self.tera.render_str(template, &tera_ctx)
    .map_err(|e| CleanroomError::template_error(
        format!("Template rendering failed in '{}': {}", name, e)
    ))
```

**2. Function Parameter Errors**:
```rust
let seed = args.get("seed")
    .and_then(|v| v.as_u64())
    .ok_or_else(|| tera::Error::msg(
        "fake_uuid_seeded() requires 'seed' parameter of type u64"
    ))?;
```

**3. Environment Variable Errors**:
```rust
std::env::var(name)
    .map(Value::String)
    .map_err(|_| tera::Error::msg(
        format!("Environment variable '{}' not found. Use env(name=\"{}\") in template.", name, name)
    ))
```

**4. Chain Context**:
```rust
renderer.render_str(&content, path.to_str().unwrap_or("unknown"))
    .map_err(|e| e.with_context(
        format!("File: {}, Line: {}", path.display(), line_num)
    ))
```

### Error Message Examples

**Good Error Message**:
```
Error: Template rendering failed
  â”Œâ”€ tests/load-test.clnrm.toml.tera:15:20
  â”‚
15â”‚ name = "{{ fake_person() }}"
  â”‚             ^^^^^^^^^^^ unknown function
  â”‚
  = help: Did you mean 'fake_name()'?
  = note: Available functions: fake_uuid, fake_name, fake_email, random_int
  = note: Use `clnrm template list-functions` to see all available functions
```

**Bad Error Message**:
```
Error: TemplateError: unknown function
```

### Error Recovery

**No recovery for template errors** - fail fast:
- Template syntax errors â†’ abort config loading
- Function errors â†’ abort rendering
- TOML parsing errors after rendering â†’ abort with rendered output for debugging

---

## Data Flow

### Template Rendering Pipeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     1. File Detection                            â”‚
â”‚  load_config_from_file(path)                                    â”‚
â”‚  â”œâ”€ Read file contents                                          â”‚
â”‚  â”œâ”€ Check extension (.tera, .toml.tera)                        â”‚
â”‚  â””â”€ Check content for template syntax ({{, {%, {#)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Is Template?              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ NO         â”‚ YES           â”‚
        â–¼            â–¼               â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ TOML    â”‚  â”‚ 2. Template Rendering                â”‚
   â”‚ Text    â”‚  â”‚  TemplateRenderer::render_str()       â”‚
   â”‚         â”‚  â”‚  â”œâ”€ Initialize Tera with functions   â”‚
   â”‚         â”‚  â”‚  â”œâ”€ Build context (vars, matrix, otel)â”‚
   â”‚         â”‚  â”‚  â”œâ”€ Render template â†’ String          â”‚
   â”‚         â”‚  â”‚  â””â”€ Handle errors                     â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                      â”‚
        â”‚                      â–¼
        â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚            â”‚ Rendered TOML    â”‚
        â”‚            â”‚ Text             â”‚
        â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. TOML Parsing (UNCHANGED)                           â”‚
â”‚  parse_toml_config(content)                           â”‚
â”‚  â”œâ”€ Parse with toml crate                             â”‚
â”‚  â”œâ”€ Deserialize to TestConfig                         â”‚
â”‚  â””â”€ Return TestConfig or CleanroomError               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Validation (UNCHANGED)                             â”‚
â”‚  config.validate()                                     â”‚
â”‚  â”œâ”€ Validate metadata                                  â”‚
â”‚  â”œâ”€ Validate services                                  â”‚
â”‚  â”œâ”€ Validate steps                                     â”‚
â”‚  â””â”€ Return Ok(()) or CleanroomError                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ TestConfig   â”‚
              â”‚ (Ready)      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Function Call Flow

```
Template: {{ fake_uuid() }}
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tera::render_str()     â”‚
â”‚ - Parse template       â”‚
â”‚ - Identify function    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function Registry Lookup       â”‚
â”‚ - Find "fake_uuid" function    â”‚
â”‚ - Check parameters (none)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ generators::fake_uuid()         â”‚
â”‚ - Generate UUID v4              â”‚
â”‚ - Return String                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Value::String("550e8400-...")   â”‚
â”‚ - Convert to Tera Value         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
Rendered: 550e8400-e29b-41d4-a716-446655440000
```

---

## Security Architecture

### Threat Model

| Threat | Mitigation | Status |
|--------|------------|--------|
| **Template Injection** | No file inclusion, sandboxed functions | âœ… Design |
| **Secrets in Templates** | Lint warnings, env_var() function | âœ… Design |
| **Arbitrary Code Execution** | Pure functions only, no I/O | âœ… Design |
| **DoS via Infinite Loops** | Tera default timeouts | âœ… Tera Built-in |
| **Path Traversal** | No file system access in functions | âœ… Design |

### Security Controls

**1. Sandboxed Template Functions**:
```rust
// âœ… SAFE - Pure function, no I/O
pub fn fake_uuid() -> String {
    Uuid::new_v4().to_string()
}

// âŒ FORBIDDEN - I/O operations
pub fn read_file(path: &str) -> String {
    std::fs::read_to_string(path).unwrap() // NEVER DO THIS
}
```

**2. Environment Variable Access**:
```rust
// Only allowed through env() function with explicit naming
{{ env(name="DB_PASSWORD") }}

// Environment variable names must be literal strings (no computed names)
```

**3. No Template Inheritance**:
```rust
// âŒ DISABLED - File inclusion disabled
{% include "other_template.tera" %}

// âœ… ALLOWED - Inline macros only
{% macro test_step(name) %}
[[steps]]
name = "{{ name }}"
{% endmacro %}
```

**4. Secret Detection**:
```rust
// Lint rule: Warn on common secret patterns
password = "..."      // âš ï¸ WARNING: Hardcoded secret detected
api_key = "..."       // âš ï¸ WARNING: Hardcoded secret detected
token = "..."         // âš ï¸ WARNING: Hardcoded secret detected

// âœ… RECOMMENDED
password = "{{ env(name='DB_PASSWORD') }}"
```

---

## Performance Considerations

### Rendering Performance

**Baseline Measurements** (Target):
- Empty template: < 1ms
- Simple template (10 variables): < 5ms
- Medium template (100 steps): < 50ms
- Large template (1000 steps): < 100ms

### Optimization Strategies

**1. Function Registration Caching**:
```rust
// Tera engine initialized once, reused for multiple renders
lazy_static! {
    static ref TERA_ENGINE: Mutex<Tera> = {
        let mut tera = Tera::default();
        registry::register_all_functions(&mut tera).unwrap();
        Mutex::new(tera)
    };
}
```

**2. Random Seed Optimization**:
```rust
// Seeded RNG reused within same template render
pub struct SeededRngCache {
    rng: StdRng,
}

impl SeededRngCache {
    pub fn new(seed: u64) -> Self {
        Self {
            rng: StdRng::seed_from_u64(seed),
        }
    }
}
```

**3. Memory Management**:
```rust
// Large templates: Stream rendering for massive outputs (future)
// Current: Entire template rendered to String (acceptable for v0.6.0)
```

### Performance Metrics

```rust
#[cfg(feature = "otel-metrics")]
{
    use clnrm_core::telemetry::metrics;

    let start = std::time::Instant::now();
    let rendered = renderer.render_str(template, name)?;
    let duration_ms = start.elapsed().as_millis() as f64;

    metrics::record_test_duration("template_render", duration_ms, true);
}
```

---

## Testing Strategy

### Unit Tests (Per Module)

**template/generators.rs**:
```rust
#[test]
fn test_fake_uuid_is_valid() {
    let uuid = fake_uuid();
    assert!(Uuid::parse_str(&uuid).is_ok());
}

#[test]
fn test_fake_uuid_seeded_deterministic() {
    let uuid1 = fake_uuid_seeded(42);
    let uuid2 = fake_uuid_seeded(42);
    assert_eq!(uuid1, uuid2);
}

#[test]
fn test_random_int_bounds() {
    for _ in 0..1000 {
        let val = random_int(10, 20);
        assert!(val >= 10 && val <= 20);
    }
}
```

**template/registry.rs**:
```rust
#[test]
fn test_all_functions_registered() {
    let mut tera = Tera::default();
    let result = register_all_functions(&mut tera);
    assert!(result.is_ok());

    // Verify functions are callable
    let template = "{{ fake_uuid() }}";
    let rendered = tera.render_str(template, &Context::new());
    assert!(rendered.is_ok());
}
```

### Integration Tests

**tests/template_integration.rs**:
```rust
#[test]
fn test_load_template_toml_file() {
    let template = r#"
[test.metadata]
name = "{{ fake_name() }}"

[[steps]]
name = "step_1"
command = ["echo", "{{ fake_uuid() }}"]
"#;

    let temp_file = NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), template).unwrap();

    let config = load_config_from_file(temp_file.path()).unwrap();
    assert!(!config.test.metadata.name.is_empty());
    assert_eq!(config.steps.len(), 1);
}

#[test]
fn test_property_based_template_100_steps() {
    let template = r#"
[test.metadata]
name = "property_test"

{% for i in range(end=100) %}
[[steps]]
name = "step_{{ i }}"
command = ["echo", "{{ i }}"]
{% endfor %}
"#;

    let temp_file = NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), template).unwrap();

    let config = load_config_from_file(temp_file.path()).unwrap();
    assert_eq!(config.steps.len(), 100);
}
```

### Property-Based Tests

```rust
#[cfg(feature = "proptest")]
mod property_tests {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn random_int_never_panics(min in -1000i64..1000, max in -1000i64..1000) {
            if min <= max {
                let val = random_int(min, max);
                assert!(val >= min && val <= max);
            }
        }

        #[test]
        fn random_string_correct_length(len in 0usize..1000) {
            let s = random_string(len);
            assert_eq!(s.len(), len);
        }

        #[test]
        fn fake_uuid_seeded_always_valid(seed in any::<u64>()) {
            let uuid_str = fake_uuid_seeded(seed);
            assert!(Uuid::parse_str(&uuid_str).is_ok());
        }
    }
}
```

### Test Coverage Targets

| Module | Unit Tests | Integration Tests | Property Tests | Target Coverage |
|--------|-----------|-------------------|----------------|-----------------|
| template/mod.rs | âœ… 100% | âœ… Yes | N/A | 100% |
| template/context.rs | âœ… 100% | âœ… Yes | N/A | 100% |
| template/determinism.rs | âœ… 100% | N/A | N/A | 100% |
| template/functions.rs | âœ… 100% | âœ… Yes | N/A | 100% |
| template/generators.rs | ğŸ”´ NEW | ğŸ”´ NEW | ğŸ”´ NEW | > 90% |
| template/registry.rs | ğŸ”´ NEW | ğŸ”´ NEW | N/A | > 90% |
| config.rs (modified) | âœ… Existing | âœ… Existing | N/A | Maintain |

---

## Implementation Roadmap

### Phase 1: Fake Data Generators (3-4 days)

**Tasks**:
1. Create `template/generators.rs` module
2. Implement UUID generators (fake_uuid, fake_uuid_seeded)
3. Implement person data (fake_name, fake_email)
4. Implement time functions (fake_timestamp)
5. Implement network functions (fake_ipv4)
6. Add comprehensive unit tests (100+ test cases)
7. Add deterministic seeded variants

**Deliverables**:
- [ ] `template/generators.rs` (< 400 lines)
- [ ] All generators with seeded variants
- [ ] Unit tests (> 90% coverage)
- [ ] Documentation comments

### Phase 2: Random Value Generators (2-3 days)

**Tasks**:
1. Implement random_int(min, max)
2. Implement random_string(length)
3. Implement random_bool()
4. Implement random_choice(items)
5. Add seeded variants for all
6. Add property-based tests
7. Add bounds checking tests

**Deliverables**:
- [ ] Random generators in `template/generators.rs`
- [ ] Property-based tests (160K+ generated test cases)
- [ ] Bounds validation tests

### Phase 3: Function Registry (1-2 days)

**Tasks**:
1. Create `template/registry.rs` module
2. Implement `register_all_functions()`
3. Organize registration by category
4. Add Tera function wrappers for all generators
5. Add integration tests
6. Document function registry

**Deliverables**:
- [ ] `template/registry.rs` (< 150 lines)
- [ ] All functions registered
- [ ] Integration tests

### Phase 4: Config Integration (2-3 days)

**Tasks**:
1. Modify `config.rs::load_config_from_file()`
2. Implement `is_template_file()` helper
3. Add template rendering step
4. Update error messages
5. Add integration tests with full pipeline
6. Test backward compatibility

**Deliverables**:
- [ ] Modified `config.rs`
- [ ] `is_template_file()` function
- [ ] Integration tests
- [ ] Backward compatibility verification

### Phase 5: Documentation & Examples (2-3 days)

**Tasks**:
1. Create `docs/TEMPLATE_GUIDE.md`
2. Update `docs/TOML_REFERENCE.md`
3. Create example templates in `examples/templating/`
4. Add CLI help for template commands
5. Create function reference table
6. Add migration guide

**Deliverables**:
- [ ] Complete documentation
- [ ] 5+ example templates
- [ ] Function reference
- [ ] Migration guide

### Phase 6: Testing & Validation (2-3 days)

**Tasks**:
1. Run full test suite
2. Run property-based tests (160K+ cases)
3. Performance benchmarking
4. Security audit (template injection testing)
5. Backward compatibility verification
6. Framework self-test update

**Deliverables**:
- [ ] All tests passing
- [ ] Performance benchmarks
- [ ] Security audit report
- [ ] Self-test validation

### Total Timeline: 12-18 days (2.5-3.5 weeks)

---

## Acceptance Criteria

### Definition of Done

- [ ] All fake data generators implemented (UUID, name, email, timestamp, IP)
- [ ] All random generators implemented (int, string, bool, choice)
- [ ] Function registry complete with all functions
- [ ] `config.rs` modified to support template rendering
- [ ] File extension detection (.tera, .toml.tera) working
- [ ] All error scenarios handled with helpful messages
- [ ] Unit tests for all functions (> 90% coverage)
- [ ] Integration tests with full TOML templates
- [ ] Property-based tests for random generators (160K+ cases)
- [ ] End-to-end test with 100+ generated scenarios
- [ ] Documentation complete (TEMPLATE_GUIDE.md, examples)
- [ ] No breaking changes to existing TOML files
- [ ] `cargo clippy -- -D warnings` passes with zero warnings
- [ ] `cargo test` passes all tests
- [ ] Framework self-test validates templating feature
- [ ] Performance: < 100ms for 1000-step template
- [ ] Security: No template injection vulnerabilities
- [ ] All files < 500 lines (modular design)
- [ ] No `.unwrap()` or `.expect()` in production code

---

## Appendix A: Complete Function Registry

### Existing Functions (Implemented)

| Function | Parameters | Returns | Example |
|----------|------------|---------|---------|
| `env(name)` | `name: String` | String | `{{ env(name="HOME") }}` |
| `now_rfc3339()` | None | String | `{{ now_rfc3339() }}` â†’ `"2025-10-16T00:00:00Z"` |
| `sha256(s)` | `s: String` | String | `{{ sha256(s="hello") }}` â†’ `"2cf24dba..."` |
| `toml_encode(value)` | `value: Any` | String | `{{ toml_encode(value="test") }}` â†’ `"test"` |

### New Functions (To Implement)

| Function | Parameters | Returns | Example |
|----------|------------|---------|---------|
| `fake_uuid()` | None | String | `"550e8400-e29b-41d4-a716-446655440000"` |
| `fake_uuid_seeded(seed)` | `seed: u64` | String | `fake_uuid_seeded(seed=42)` |
| `fake_name()` | None | String | `"Alice Smith"` |
| `fake_name_seeded(seed)` | `seed: u64` | String | `fake_name_seeded(seed=42)` |
| `fake_email()` | None | String | `"test_123@example.com"` |
| `fake_email_seeded(seed)` | `seed: u64` | String | `fake_email_seeded(seed=42)` |
| `fake_timestamp()` | None | i64 | `1729123456` (seconds) |
| `fake_timestamp_ms()` | None | i64 | `1729123456789` (milliseconds) |
| `fake_ipv4()` | None | String | `"192.168.1.42"` |
| `fake_ipv4_seeded(seed)` | `seed: u64` | String | `fake_ipv4_seeded(seed=42)` |
| `random_int(min, max)` | `min: i64, max: i64` | i64 | `random_int(min=1, max=100)` â†’ `42` |
| `random_int_seeded(seed, min, max)` | `seed: u64, min: i64, max: i64` | i64 | Deterministic |
| `random_string(length)` | `length: usize` | String | `random_string(length=10)` â†’ `"a3kJ9zX2mP"` |
| `random_string_seeded(seed, length)` | `seed: u64, length: usize` | String | Deterministic |
| `random_bool()` | None | bool | `true` or `false` |
| `random_bool_seeded(seed)` | `seed: u64` | bool | Deterministic |
| `random_choice(items)` | `items: Vec<String>` | String | `random_choice(items=["a","b"])` |
| `random_choice_seeded(seed, items)` | `seed: u64, items: Vec<String>` | String | Deterministic |
| `property_range(start, end)` | `start: i64, end: i64` | Vec<i64> | `property_range(start=0, end=5)` â†’ `[0,1,2,3,4,5]` |

---

## Appendix B: Dependencies

### New Cargo Dependencies

```toml
[dependencies]
# Existing (already in Cargo.toml)
tera = "1.19"           # âœ… Already added
sha2 = "0.10"           # âœ… Already added
chrono = "0.4"          # âœ… Already added

# New (to add)
uuid = { version = "1.10", features = ["v4", "serde"] }  # ğŸ”´ NEW
rand = "0.8"                                              # ğŸ”´ NEW

[dev-dependencies]
# Existing
proptest = "1.0"        # âœ… Already added for property tests
tempfile = "3.8"        # âœ… Already added for test files
```

---

## Appendix C: File Structure After Implementation

```
crates/clnrm-core/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ template/
â”‚   â”‚   â”œâ”€â”€ mod.rs              âœ… EXISTING (147 lines)
â”‚   â”‚   â”œâ”€â”€ context.rs          âœ… EXISTING (170 lines)
â”‚   â”‚   â”œâ”€â”€ determinism.rs      âœ… EXISTING (178 lines)
â”‚   â”‚   â”œâ”€â”€ functions.rs        âœ… EXISTING (382 lines)
â”‚   â”‚   â”œâ”€â”€ generators.rs       ğŸ”´ NEW (< 400 lines)
â”‚   â”‚   â””â”€â”€ registry.rs         ğŸ”´ NEW (< 150 lines)
â”‚   â”œâ”€â”€ config.rs               ğŸŸ¡ MODIFY (+50 lines)
â”‚   â”œâ”€â”€ error.rs                âœ… READY (TemplateError exists)
â”‚   â””â”€â”€ lib.rs                  âœ… READY (exports template module)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ template_integration.rs ğŸ”´ NEW
â”‚   â””â”€â”€ property_tests.rs       ğŸŸ¡ MODIFY (add template tests)
â””â”€â”€ Cargo.toml                  ğŸŸ¡ MODIFY (add uuid, rand)

examples/
â””â”€â”€ templating/                 ğŸ”´ NEW
    â”œâ”€â”€ load-test.clnrm.toml.tera
    â”œâ”€â”€ chaos-random.clnrm.toml.tera
    â”œâ”€â”€ db-property-test.clnrm.toml.tera
    â””â”€â”€ deterministic-property.clnrm.toml.tera

docs/
â”œâ”€â”€ TEMPLATE_GUIDE.md           ğŸ”´ NEW
â””â”€â”€ TOML_REFERENCE.md           ğŸŸ¡ MODIFY (add templating section)
```

---

## Conclusion

This architecture provides a complete, production-ready design for v0.6.0 Tera templating features. The design:

1. **Builds on existing implementation** - Extends current template system
2. **Maintains backward compatibility** - All existing TOML files work unchanged
3. **Follows CLNRM principles** - Modular design, dyn-compatible traits, no unwrap()
4. **Provides powerful features** - Property-based testing, fake data, deterministic generation
5. **Handles errors gracefully** - Clear, actionable error messages
6. **Thoroughly tested** - Unit, integration, property-based, and E2E tests

**Next Steps**:
1. Review and approve this architecture
2. Begin Phase 1 implementation (Fake Data Generators)
3. Iterate based on testing feedback
4. Deploy v0.6.0 with complete templating support

**Estimated Completion**: 2.5-3.5 weeks for full implementation and testing.

---

**Document Status**: âœ… READY FOR REVIEW
**Implementation Status**: ğŸŸ¡ PARTIALLY IMPLEMENTED (40% complete)
**Approval**: Pending Architecture Sub-Coordinator

