# CLNRM v0.6.0 Test Strategy (London TDD)

**Version**: 0.6.0
**Date**: 2025-10-16
**Methodology**: London School Test-Driven Development

## Overview

This document defines the comprehensive testing strategy for CLNRM v0.6.0, following London School TDD principles:

- **Outside-in development** - Start with high-level acceptance tests
- **Heavy use of test doubles** - Mocks, stubs, and spies
- **Interaction testing** - Verify behavior through collaborator interactions
- **Fast feedback** - Isolated unit tests with minimal dependencies

## London TDD Principles

### 1. Test First, Always

```rust
// ❌ WRONG: Implementation first
pub fn fake_uuid() -> String {
    Uuid::new_v4().to_string()
}

#[test]
fn test_fake_uuid() {
    // Test after implementation
}

// ✅ CORRECT: Test first
#[test]
fn test_fake_uuid_returns_valid_uuid_v4() {
    // Arrange
    // (no setup needed)

    // Act
    let uuid = fake_uuid();

    // Assert
    assert!(Uuid::parse_str(&uuid).is_ok());
    assert_eq!(uuid.len(), 36);
    assert!(uuid.contains('-'));
}

// Now implement
pub fn fake_uuid() -> String {
    Uuid::new_v4().to_string()
}
```

### 2. AAA Pattern (Arrange, Act, Assert)

**Every test must follow**:
```rust
#[tokio::test]
async fn test_template_rendering_with_context() {
    // Arrange - Set up test conditions
    let mut renderer = TemplateRenderer::new().unwrap();
    let mut context = TemplateContext::new();
    context.vars.insert("name".to_string(), json!("World"));
    renderer = renderer.with_context(context);

    // Act - Execute the behavior under test
    let result = renderer.render_str("Hello {{ vars.name }}", "test");

    // Assert - Verify the outcome
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "Hello World");
}
```

### 3. Test Doubles (Mocking)

**Use mocks for collaborators**:
```rust
// Mock OTEL span collector
#[derive(Clone)]
struct MockSpanCollector {
    spans: Arc<Mutex<Vec<SpanData>>>,
}

impl MockSpanCollector {
    fn new() -> Self {
        Self {
            spans: Arc::new(Mutex::new(Vec::new())),
        }
    }

    fn verify_span_created(&self, name: &str) -> bool {
        let spans = self.spans.lock().unwrap();
        spans.iter().any(|s| s.name == name)
    }
}

#[test]
fn test_otel_validator_validates_span_creation() {
    // Arrange
    let mock_collector = MockSpanCollector::new();
    let validator = OtelValidator::with_collector(Arc::new(mock_collector.clone()));

    // Simulate span creation
    mock_collector.spans.lock().unwrap().push(create_test_span("test.operation"));

    // Act
    let result = validator.validate_span(&SpanAssertion {
        name: "test.operation".to_string(),
        attributes: HashMap::new(),
        required: true,
        min_duration_ms: None,
        max_duration_ms: None,
    });

    // Assert
    assert!(result.is_ok());
    assert!(result.unwrap().passed);
    assert!(mock_collector.verify_span_created("test.operation"));
}
```

## Test Pyramid for v0.6.0

```
                  ▲
                 / \
                /   \
               /  E2E \          10% - End-to-End Tests
              /  Tests \         (Full system, real containers)
             /-----------\
            /             \
           / Integration   \    20% - Integration Tests
          /     Tests       \   (Module boundaries, I/O)
         /-------------------\
        /                     \
       /      Unit Tests       \ 70% - Unit Tests
      /                         \ (Functions, methods, isolated)
     /___________________________\
```

### Test Distribution

| Test Type | Percentage | Count (estimate) | Purpose |
|-----------|-----------|------------------|---------|
| Unit | 70% | ~200 tests | Test individual functions/methods |
| Integration | 20% | ~60 tests | Test module interactions |
| E2E | 10% | ~30 tests | Test complete workflows |

## Unit Testing Strategy (70%)

### Template Functions

**Location**: `crates/clnrm-core/src/template/functions.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Test 1: Basic functionality
    #[test]
    fn test_fake_uuid_generates_valid_uuid() {
        // Arrange
        // (no setup)

        // Act
        let uuid = fake_uuid();

        // Assert
        assert!(Uuid::parse_str(&uuid).is_ok());
    }

    // Test 2: Format validation
    #[test]
    fn test_fake_uuid_has_correct_format() {
        // Arrange
        let uuid = fake_uuid();

        // Act
        let parts: Vec<&str> = uuid.split('-').collect();

        // Assert
        assert_eq!(parts.len(), 5); // UUID has 5 parts
        assert_eq!(parts[0].len(), 8);  // 8 hex chars
        assert_eq!(parts[1].len(), 4);  // 4 hex chars
        assert_eq!(parts[2].len(), 4);  // 4 hex chars
        assert_eq!(parts[3].len(), 4);  // 4 hex chars
        assert_eq!(parts[4].len(), 12); // 12 hex chars
    }

    // Test 3: Uniqueness
    #[test]
    fn test_fake_uuid_generates_unique_values() {
        // Arrange
        let mut uuids = std::collections::HashSet::new();

        // Act
        for _ in 0..1000 {
            uuids.insert(fake_uuid());
        }

        // Assert
        assert_eq!(uuids.len(), 1000); // All unique
    }

    // Test 4: Random name generation
    #[test]
    fn test_fake_name_contains_first_and_last() {
        // Arrange
        let name = fake_name();

        // Act
        let parts: Vec<&str> = name.split_whitespace().collect();

        // Assert
        assert_eq!(parts.len(), 2); // "FirstName LastName"
        assert!(!parts[0].is_empty());
        assert!(!parts[1].is_empty());
    }

    // Test 5: Email format
    #[test]
    fn test_fake_email_has_valid_format() {
        // Arrange
        let email = fake_email();

        // Act
        let contains_at = email.contains('@');
        let parts: Vec<&str> = email.split('@').collect();

        // Assert
        assert!(contains_at);
        assert_eq!(parts.len(), 2);
        assert!(parts[1].ends_with(".com"));
    }

    // Test 6: Random integer bounds
    #[test]
    fn test_fake_int_stays_within_bounds() {
        // Arrange
        let min = 10;
        let max = 20;

        // Act & Assert
        for _ in 0..1000 {
            let val = fake_int(min, max);
            assert!(val >= min);
            assert!(val <= max);
        }
    }

    // Test 7: Random string length
    #[test]
    fn test_fake_string_has_correct_length() {
        // Arrange
        let length = 32;

        // Act
        let s = fake_string(length);

        // Assert
        assert_eq!(s.len(), length);
        assert!(s.chars().all(|c| c.is_alphanumeric()));
    }

    // Test 8: Property range
    #[test]
    fn test_property_range_generates_sequence() {
        // Arrange
        let start = 0;
        let end = 5;

        // Act
        let range = property_range(start, end);

        // Assert
        assert_eq!(range, vec![0, 1, 2, 3, 4, 5]);
    }
}
```

**Coverage Target**: 95%+ for template functions

### OTEL Validation

**Location**: `crates/clnrm-core/src/validation/otel.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Test 1: Span validation with attributes
    #[test]
    fn test_validate_span_checks_attributes() {
        // Arrange
        let collector = Arc::new(InMemorySpanCollector::new());
        let validator = OtelValidator::with_collector(collector.clone());

        let mut span = create_test_span("test.op");
        span.attributes.insert("key".to_string(), "value".to_string());
        collector.collect(span).unwrap();

        let mut expected_attrs = HashMap::new();
        expected_attrs.insert("key".to_string(), "value".to_string());

        let assertion = SpanAssertion {
            name: "test.op".to_string(),
            attributes: expected_attrs,
            required: true,
            min_duration_ms: None,
            max_duration_ms: None,
        };

        // Act
        let result = validator.validate_span(&assertion).unwrap();

        // Assert
        assert!(result.passed);
        assert!(result.errors.is_empty());
    }

    // Test 2: Missing required span
    #[test]
    fn test_validate_span_fails_when_required_span_missing() {
        // Arrange
        let collector = Arc::new(InMemorySpanCollector::new());
        let validator = OtelValidator::with_collector(collector);

        let assertion = SpanAssertion {
            name: "missing.span".to_string(),
            attributes: HashMap::new(),
            required: true,
            min_duration_ms: None,
            max_duration_ms: None,
        };

        // Act
        let result = validator.validate_span(&assertion).unwrap();

        // Assert
        assert!(!result.passed);
        assert!(result.errors.iter().any(|e| e.contains("not found")));
    }

    // Test 3: Duration validation
    #[test]
    fn test_validate_span_checks_duration() {
        // Arrange
        let collector = Arc::new(InMemorySpanCollector::new());
        let validator = OtelValidator::with_collector(collector.clone());

        let mut span = create_test_span("test.op");
        span.start_time = SystemTime::now();
        span.end_time = span.start_time + Duration::from_millis(500);
        collector.collect(span).unwrap();

        let assertion = SpanAssertion {
            name: "test.op".to_string(),
            attributes: HashMap::new(),
            required: true,
            min_duration_ms: Some(100.0),
            max_duration_ms: Some(1000.0),
        };

        // Act
        let result = validator.validate_span(&assertion).unwrap();

        // Assert
        assert!(result.passed);
        assert!(result.actual_duration_ms.is_some());
        let duration = result.actual_duration_ms.unwrap();
        assert!(duration >= 100.0 && duration <= 1000.0);
    }
}
```

**Coverage Target**: 90%+ for validation logic

## Integration Testing Strategy (20%)

### Template Rendering Integration

**Location**: `crates/clnrm-core/tests/template_integration.rs`

```rust
#[tokio::test]
async fn test_template_rendering_with_all_functions() {
    // Arrange
    let template = r#"
[test.metadata]
name = "{{ env(name='TEST_NAME') }}"
created = "{{ now_rfc3339() }}"
hash = "{{ sha256(s='test') }}"

[services.app]
type = "generic_container"
image = "alpine:latest"
env = {
    USER_ID = "{{ fake_uuid() }}",
    USER_NAME = "{{ fake_name() }}",
    USER_EMAIL = "{{ fake_email() }}",
    PORT = "{{ fake_int(min=8000, max=9000) }}"
}

{% for i in property_range(start=0, end=3) %}
[[steps]]
name = "step_{{ i }}"
command = ["echo", "{{ i }}"]
{% endfor %}
    "#;

    std::env::set_var("TEST_NAME", "integration_test");

    let mut renderer = TemplateRenderer::new().unwrap();

    // Act
    let rendered = renderer.render_str(template, "integration_test").unwrap();

    // Assert
    assert!(rendered.contains("name = \"integration_test\""));
    assert!(rendered.contains("created = \""));
    assert!(rendered.contains("hash = \""));
    assert!(rendered.contains("USER_ID = \""));
    assert!(rendered.contains("USER_NAME = \""));
    assert!(rendered.contains("USER_EMAIL = \""));
    assert!(rendered.contains("PORT = \""));
    assert!(rendered.contains("step_0"));
    assert!(rendered.contains("step_1"));
    assert!(rendered.contains("step_2"));

    // Verify it parses as valid TOML
    let config = parse_toml_config(&rendered).unwrap();
    assert_eq!(config.test.metadata.name, "integration_test");
    assert_eq!(config.steps.len(), 3);
}
```

### Config Loading Integration

**Location**: `crates/clnrm-core/tests/config_integration.rs`

```rust
#[tokio::test]
async fn test_load_config_with_template_rendering() {
    // Arrange
    let template_content = r#"
[test.metadata]
name = "{{ fake_name() }}"

[[steps]]
name = "test_step"
command = ["echo", "{{ fake_uuid() }}"]
    "#;

    let temp_file = tempfile::NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), template_content).unwrap();

    // Act
    let config = load_config_from_file(temp_file.path()).unwrap();

    // Assert
    assert!(!config.test.metadata.name.is_empty());
    assert_eq!(config.steps.len(), 1);
    assert_eq!(config.steps[0].name, "test_step");
    assert!(config.steps[0].command.len() >= 2);
}

#[tokio::test]
async fn test_load_config_without_template_works() {
    // Arrange
    let static_toml = r#"
[test.metadata]
name = "static_test"

[[steps]]
name = "static_step"
command = ["echo", "hello"]
    "#;

    let temp_file = tempfile::NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), static_toml).unwrap();

    // Act
    let config = load_config_from_file(temp_file.path()).unwrap();

    // Assert
    assert_eq!(config.test.metadata.name, "static_test");
    assert_eq!(config.steps.len(), 1);
    assert_eq!(config.steps[0].command, vec!["echo", "hello"]);
}
```

### OTEL Validation Integration

**Location**: `crates/clnrm-core/tests/otel_validation_integration.rs`

```rust
#[tokio::test]
async fn test_otel_validation_with_real_spans() {
    // Arrange
    let (guard, collector) = setup_otel_for_testing().unwrap();
    let validator = OtelValidator::with_collector(collector);

    // Act - Create actual traced operation
    let span = tracing::info_span!(
        "user.login",
        user.id = "user-123",
        operation.type = "authentication"
    );
    let _enter = span.enter();

    // Some work
    tokio::time::sleep(Duration::from_millis(10)).await;

    drop(_enter); // End span

    // Assert
    let mut expected_attrs = HashMap::new();
    expected_attrs.insert("user.id".to_string(), "user-123".to_string());

    let result = validator.validate_span(&SpanAssertion {
        name: "user.login".to_string(),
        attributes: expected_attrs,
        required: true,
        min_duration_ms: Some(5.0),
        max_duration_ms: Some(100.0),
    }).unwrap();

    assert!(result.passed);
    assert!(result.errors.is_empty());
}
```

**Coverage Target**: 85%+ for integration tests

## End-to-End Testing Strategy (10%)

### Property-Based Test Generation

**Location**: `crates/clnrm-core/tests/e2e_property_testing.rs`

```rust
#[tokio::test]
async fn test_property_based_load_test_execution() {
    // Arrange
    let template = r#"
[test.metadata]
name = "property_load_test"

[services.api]
type = "generic_container"
image = "httpbin:latest"
env = { PORT = "80" }

{% for i in range(end=100) %}
[[steps]]
name = "request_{{ i }}"
service = "api"
command = ["curl", "http://localhost/uuid"]
expected_exit_code = 0
{% endfor %}
    "#;

    let temp_file = tempfile::NamedTempFile::new().unwrap();
    std::fs::write(temp_file.path(), template).unwrap();

    // Act
    let config = load_config_from_file(temp_file.path()).unwrap();
    let env = CleanroomEnvironment::new().await.unwrap();
    let results = env.execute_config(config).await.unwrap();

    // Assert
    assert_eq!(results.total_steps, 100);
    assert_eq!(results.passed_steps, 100);
    assert!(results.all_passed());
}
```

### Complete OTEL Trace Validation

**Location**: `crates/clnrm-core/tests/e2e_otel_validation.rs`

```rust
#[tokio::test]
async fn test_complete_trace_validation() {
    // Arrange
    let (guard, collector) = setup_otel_for_testing().unwrap();
    let validator = OtelValidator::with_collector(collector);

    // Act - Execute traced workflow
    traced_workflow().await; // Creates parent and child spans

    // Assert trace structure
    let trace_assertion = TraceAssertion {
        trace_id: None,
        expected_spans: vec![
            SpanAssertion {
                name: "workflow.start".to_string(),
                attributes: HashMap::new(),
                required: true,
                min_duration_ms: None,
                max_duration_ms: None,
            },
            SpanAssertion {
                name: "workflow.process".to_string(),
                attributes: HashMap::new(),
                required: true,
                min_duration_ms: None,
                max_duration_ms: None,
            },
            SpanAssertion {
                name: "workflow.complete".to_string(),
                attributes: HashMap::new(),
                required: true,
                min_duration_ms: None,
                max_duration_ms: None,
            },
        ],
        complete: true,
        parent_child_relationships: vec![
            ("workflow.start".to_string(), "workflow.process".to_string()),
            ("workflow.start".to_string(), "workflow.complete".to_string()),
        ],
    };

    let result = validator.validate_trace(&trace_assertion).unwrap();

    assert!(result.passed);
    assert_eq!(result.expected_span_count, 3);
    assert_eq!(result.actual_span_count, 3);
}

#[tracing::instrument]
async fn traced_workflow() {
    let process_span = tracing::info_span!("workflow.process");
    let _process = process_span.enter();
    tokio::time::sleep(Duration::from_millis(10)).await;
    drop(_process);

    let complete_span = tracing::info_span!("workflow.complete");
    let _complete = complete_span.enter();
    tokio::time::sleep(Duration::from_millis(10)).await;
}
```

**Coverage Target**: 80%+ for E2E scenarios

## Property-Based Testing

**Using** `proptest` **for generative testing**:

```rust
#[cfg(test)]
mod property_tests {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn fake_int_never_panics(min in -1000i64..1000, max in -1000i64..1000) {
            if min <= max {
                let val = fake_int(min, max);
                assert!(val >= min && val <= max);
            }
        }

        #[test]
        fn fake_string_correct_length(len in 0usize..1000) {
            let s = fake_string(len);
            assert_eq!(s.len(), len);
        }

        #[test]
        fn template_rendering_never_panics(
            content in ".*",
            name in "[a-z]{1,20}"
        ) {
            let mut renderer = TemplateRenderer::new().unwrap();
            // Should either succeed or return proper error
            let result = renderer.render_str(&content, &name);
            assert!(result.is_ok() || result.is_err());
        }
    }
}
```

**Coverage Target**: 1000+ generated test cases per property

## Test Organization

### Directory Structure

```
crates/clnrm-core/
├── src/
│   ├── template/
│   │   ├── mod.rs
│   │   ├── functions.rs  # Unit tests inline
│   │   └── context.rs    # Unit tests inline
│   ├── validation/
│   │   └── otel.rs       # Unit tests inline
│   └── config/
│       └── mod.rs        # Unit tests inline
├── tests/
│   ├── template_integration.rs      # Integration tests
│   ├── config_integration.rs        # Integration tests
│   ├── otel_validation_integration.rs # Integration tests
│   ├── e2e_property_testing.rs      # E2E tests
│   ├── e2e_otel_validation.rs       # E2E tests
│   └── property_tests.rs            # Property-based tests
└── examples/
    └── templating/                   # Example templates for manual testing
```

## Continuous Integration

### CI Pipeline (GitHub Actions)

```yaml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run unit tests
        run: cargo test --lib

      - name: Run integration tests
        run: cargo test --test '*'

      - name: Run property tests
        run: cargo test --features proptest

      - name: Run E2E tests
        run: cargo test --test e2e_*

      - name: Check coverage
        run: cargo tarpaulin --out Xml
        # Fail if <90%

      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

### Coverage Requirements

| Component | Minimum Coverage |
|-----------|-----------------|
| Template functions | 95% |
| OTEL validation | 90% |
| Config loading | 85% |
| Integration tests | 85% |
| E2E tests | 80% |
| **Overall** | **90%** |

## Test Execution Strategy

### Local Development

```bash
# Fast feedback loop - unit tests only
cargo test --lib

# Full test suite
cargo test --all

# With coverage
cargo tarpaulin --all

# Property tests (slow)
cargo test --features proptest -- --nocapture
```

### Pre-Commit Hook

```bash
#!/bin/bash
# .git/hooks/pre-commit

# Run unit tests
cargo test --lib --quiet || exit 1

# Check coverage
coverage=$(cargo tarpaulin --lib | grep -oP '\d+\.\d+%' | head -1 | sed 's/%//')
if (( $(echo "$coverage < 90" | bc -l) )); then
    echo "Coverage $coverage% < 90% - commit rejected"
    exit 1
fi
```

### Pull Request Requirements

- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] All E2E tests pass
- [ ] Coverage ≥90%
- [ ] No `unwrap()` or `expect()` in production code
- [ ] All new functions have tests

## Test Quality Metrics

### Assertions Per Test

- **Minimum**: 1 assertion
- **Recommended**: 3-5 assertions
- **Maximum**: 10 assertions (split if more)

### Test Execution Time

| Test Type | Max Duration |
|-----------|-------------|
| Unit test | 10ms |
| Integration test | 100ms |
| E2E test | 1000ms |

### Test Naming Convention

```rust
// Pattern: test_<unit>_<scenario>_<expected_outcome>
#[test]
fn test_fake_uuid_generates_valid_uuid_v4() { }

#[test]
fn test_validate_span_fails_when_required_span_missing() { }

#[test]
fn test_template_rendering_succeeds_with_all_functions() { }
```

## Debugging Failed Tests

### Common Patterns

```rust
// ❌ BAD: Unclear failure message
assert!(result.is_ok());

// ✅ GOOD: Descriptive failure message
assert!(
    result.is_ok(),
    "Template rendering failed: {:?}",
    result.unwrap_err()
);

// ❌ BAD: Silent test
let _ = dangerous_operation();

// ✅ GOOD: Explicit error handling
dangerous_operation().expect("Operation should succeed in test");

// ❌ BAD: No cleanup
let temp_file = create_temp_file();
// Test code
// File not cleaned up

// ✅ GOOD: Automatic cleanup
let _temp_file = tempfile::NamedTempFile::new().unwrap();
// Automatically cleaned up when dropped
```

## Test Data Management

### Test Fixtures

```rust
// tests/fixtures/mod.rs
pub fn create_test_span(name: &str) -> SpanData {
    SpanData {
        name: name.to_string(),
        span_context: SpanContext::new(/* ... */),
        parent_span_id: SpanId::INVALID,
        start_time: SystemTime::now(),
        end_time: SystemTime::now() + Duration::from_millis(100),
        attributes: HashMap::new(),
        // ...
    }
}

pub fn create_test_config() -> TestConfig {
    TestConfig {
        test: TestMetadata {
            name: "test".to_string(),
            // ...
        },
        services: HashMap::new(),
        steps: Vec::new(),
        // ...
    }
}
```

### Template Test Data

```rust
// tests/fixtures/templates.rs
pub const BASIC_TEMPLATE: &str = r#"
[test.metadata]
name = "{{ fake_name() }}"
"#;

pub const LOAD_TEST_TEMPLATE: &str = r#"
{% for i in range(end=100) %}
[[steps]]
name = "step_{{ i }}"
{% endfor %}
"#;
```

## Success Criteria

Test strategy is successful when:

- [ ] 90%+ overall test coverage
- [ ] All tests follow AAA pattern
- [ ] Zero flaky tests
- [ ] Test suite runs in <5 minutes
- [ ] All mocks/stubs documented
- [ ] Property tests generate 1000+ cases
- [ ] E2E tests validate real workflows
- [ ] CI/CD pipeline green

## Appendix: Test Template

```rust
/// Template for new tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_function_name_does_expected_behavior() {
        // Arrange - Set up test conditions
        let input = "test input";
        let expected = "expected output";

        // Act - Execute the behavior under test
        let result = function_under_test(input);

        // Assert - Verify the outcome
        assert_eq!(result, expected, "Should produce expected output");
    }

    #[tokio::test]
    async fn test_async_function_does_expected_behavior() {
        // Arrange
        let mock = create_mock_dependency();

        // Act
        let result = async_function(mock).await;

        // Assert
        assert!(result.is_ok());
    }
}
```

## Conclusion

This test strategy ensures v0.6.0 maintains CLNRM's production quality through:

- **London TDD** - Outside-in, interaction-focused testing
- **Comprehensive coverage** - 90%+ across all test types
- **Fast feedback** - Unit tests in milliseconds
- **Quality gates** - CI/CD enforcement of standards
- **Backward compatibility** - All v0.4.x tests pass
