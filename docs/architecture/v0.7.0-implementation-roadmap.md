# v0.7.0 Implementation Roadmap

**Architect**: System Architecture Agent
**Date**: 2025-10-17
**Status**: READY FOR IMPLEMENTATION

---

## Implementation Status Overview

### ‚úÖ Completed (Architecture Phase)
- [x] Cache subsystem architecture design
- [x] Watch subsystem architecture design
- [x] Formatting subsystem architecture design
- [x] Validation (shape) subsystem architecture design
- [x] Trait hierarchy documentation
- [x] Integration patterns documented
- [x] Error handling patterns established
- [x] Thread safety patterns defined
- [x] London TDD test architecture

### ‚úÖ Partially Implemented
- [x] `FileCache` - File-based cache implementation
- [x] `MemoryCache` - In-memory cache for testing
- [x] `Cache` trait - Abstraction layer
- [x] `FileDebouncer` - Event debouncing (200ms window)
- [x] `format_toml_content()` - TOML formatting
- [x] `format_toml_file()` - File formatting
- [x] `needs_formatting()` - Format checking
- [x] `verify_idempotency()` - Idempotency verification
- [x] `ShapeValidator` - Enhanced with v0.7.0 validations

### üîÑ In Progress (Implementation Phase)
- [ ] `FileWatcher` trait definition
- [ ] `NotifyWatcher` implementation
- [ ] dev --watch command integration
- [ ] dry-run command integration
- [ ] fmt command integration
- [ ] Cache integration with run command

---

## Week 1: Core Subsystems Completion

### Day 1-2: FileWatcher Implementation

**Objective**: Complete watch subsystem

**Tasks**:
1. Define `FileWatcher` trait in `crates/clnrm-core/src/watch/mod.rs`
   ```rust
   pub trait FileWatcher: Send + Sync {
       fn watch(&self, path: &Path) -> Result<WatchHandle>;
       fn unwatch(&self, handle: WatchHandle) -> Result<()>;
       fn next_event(&self, timeout: Duration) -> Result<Option<WatchEvent>>;
       fn is_healthy(&self) -> bool;
   }
   ```

2. Implement `NotifyWatcher` using `notify` crate
   ```rust
   pub struct NotifyWatcher {
       watcher: Arc<Mutex<RecommendedWatcher>>,
       events: Arc<Mutex<VecDeque<WatchEvent>>>,
   }
   ```

3. Create `MockWatcher` for testing
   ```rust
   #[cfg(test)]
   pub struct MockWatcher {
       events: Arc<Mutex<Vec<WatchEvent>>>,
   }
   ```

4. Write unit tests (London TDD):
   - `test_watch_creates_handle()`
   - `test_next_event_returns_modified()`
   - `test_unwatch_stops_events()`
   - `test_is_healthy_returns_true()`

**Files to Create**:
- `crates/clnrm-core/src/watch/mod.rs` (FileWatcher trait)
- `crates/clnrm-core/src/watch/notify_watcher.rs` (NotifyWatcher impl)
- `crates/clnrm-core/src/watch/mock.rs` (MockWatcher for tests)

**Acceptance Criteria**:
- [x] FileDebouncer exists and works
- [ ] FileWatcher trait is dyn-compatible
- [ ] NotifyWatcher implements FileWatcher
- [ ] Unit tests pass (>90% coverage)
- [ ] Zero `.unwrap()` or `.expect()` calls

### Day 3-4: Cache Integration with Run Command

**Objective**: Integrate cache with existing run command

**Tasks**:
1. Add `--force` flag to run command
   ```rust
   #[derive(Parser)]
   pub struct RunCommand {
       #[arg(long)]
       force: bool,  // Bypass cache
       // ...
   }
   ```

2. Integrate cache check in run pipeline
   ```rust
   pub async fn run_with_cache(
       config_path: &Path,
       force: bool,
   ) -> Result<()> {
       let cache = FileCache::new()?;
       let rendered = render_template(config_path)?;

       if !force && !cache.has_changed(config_path, &rendered)? {
           info!("Skipped {} (unchanged)", config_path.display());
           return Ok(());
       }

       let result = execute_test(&rendered)?;

       if result.success() {
           cache.update(config_path, &rendered)?;
           cache.save()?;
       }

       Ok(())
   }
   ```

3. Add cache statistics to run output
   ```rust
   let stats = cache.stats()?;
   info!("Cache: {} files tracked", stats.total_files);
   ```

4. Write integration tests:
   - `test_run_skips_unchanged_file()`
   - `test_run_executes_changed_file()`
   - `test_force_flag_bypasses_cache()`

**Files to Modify**:
- `crates/clnrm-core/src/cli/commands/run.rs`

**Acceptance Criteria**:
- [ ] `--force` flag bypasses cache
- [ ] Unchanged files are skipped
- [ ] Changed files execute tests
- [ ] Cache persists across runs
- [ ] Integration tests pass

### Day 5: Format Command Implementation

**Objective**: Create `clnrm fmt` command

**Tasks**:
1. Create fmt command structure
   ```rust
   #[derive(Parser)]
   pub struct FmtCommand {
       #[arg(long)]
       check: bool,  // Check mode for CI
       path: Option<PathBuf>,
   }
   ```

2. Implement command logic
   ```rust
   pub async fn fmt_command(args: FmtCommand) -> Result<()> {
       let search_path = args.path.unwrap_or_else(|| PathBuf::from("."));
       let files = find_toml_files(&search_path)?;

       for file in &files {
           if needs_formatting(file)? {
               if args.check {
                   error!("File needs formatting: {}", file.display());
               } else {
                   let formatted = format_toml_file(file)?;
                   fs::write(file, formatted)?;
                   info!("Formatted: {}", file.display());
               }
           }
       }

       if args.check && !unformatted_files.is_empty() {
           std::process::exit(1);
       }

       Ok(())
   }
   ```

3. Add to CLI command enum
   ```rust
   pub enum Commands {
       // ...
       Fmt(FmtCommand),
   }
   ```

4. Write integration tests:
   - `test_fmt_formats_unformatted_file()`
   - `test_fmt_check_detects_unformatted()`
   - `test_fmt_idempotent()`

**Files to Create**:
- `crates/clnrm-core/src/cli/commands/v0_7_0/fmt.rs`

**Files to Modify**:
- `crates/clnrm-core/src/cli/commands/mod.rs`
- `crates/clnrm-core/src/cli/types.rs`

**Acceptance Criteria**:
- [ ] `clnrm fmt` formats files
- [ ] `clnrm fmt --check` detects unformatted files
- [ ] Formatting is idempotent
- [ ] Integration tests pass
- [ ] CI integration documented

---

## Week 2: DX Commands

### Day 6-8: dev --watch Command

**Objective**: Implement hot reload with `clnrm dev --watch`

**Tasks**:
1. Create dev command structure
   ```rust
   #[derive(Parser)]
   pub struct DevCommand {
       #[arg(long)]
       watch: bool,
       path: Option<PathBuf>,
   }
   ```

2. Implement watch loop
   ```rust
   pub async fn dev_watch_loop(path: PathBuf) -> Result<()> {
       let watcher = NotifyWatcher::new()?;
       let mut debouncer = FileDebouncer::new(Duration::from_millis(200));

       watcher.watch(&path)?;

       loop {
           match watcher.next_event(Duration::from_millis(100))? {
               Some(event) => {
                   debug!("File event: {:?}", event);
                   debouncer.record_event();
               }
               None => {
                   if debouncer.should_trigger() {
                       debouncer.reset();

                       // Clear screen
                       print!("\x1B[2J\x1B[1;1H");

                       // Run tests
                       info!("Running tests...");
                       match run_tests(&path).await {
                           Ok(_) => info!("‚úÖ Tests passed"),
                           Err(e) => error!("‚ùå Tests failed: {}", e),
                       }
                   }
               }
           }
       }
   }
   ```

3. Add graceful shutdown (Ctrl+C)
   ```rust
   use tokio::signal;

   tokio::select! {
       _ = dev_watch_loop(path) => {},
       _ = signal::ctrl_c() => {
           info!("Shutting down...");
       }
   }
   ```

4. Write integration tests:
   - `test_dev_watch_detects_file_change()`
   - `test_dev_watch_debounces_rapid_changes()`
   - `test_dev_watch_continues_on_error()`

**Files to Create**:
- `crates/clnrm-core/src/cli/commands/v0_7_0/dev.rs`

**Acceptance Criteria**:
- [ ] File changes trigger test runs
- [ ] Debouncing works (<3s latency)
- [ ] Errors don't crash watcher
- [ ] Ctrl+C exits cleanly
- [ ] Integration tests pass

### Day 9-10: dry-run Command

**Objective**: Implement fast validation with `clnrm dry-run`

**Tasks**:
1. Create dry-run command
   ```rust
   #[derive(Parser)]
   pub struct DryRunCommand {
       path: Option<PathBuf>,
   }
   ```

2. Implement validation pipeline
   ```rust
   pub async fn dry_run_command(args: DryRunCommand) -> Result<()> {
       let search_path = args.path.unwrap_or_else(|| PathBuf::from("."));
       let files = find_test_files(&search_path)?;

       let mut all_passed = true;
       let mut validator = ShapeValidator::new();

       for file in &files {
           let result = validator.validate_file(file)?;

           if result.passed {
               info!("‚úÖ {} - PASSED", file.display());
           } else {
               error!("‚ùå {} - FAILED", file.display());
               for error in &result.errors {
                   error!("  {:?}: {}", error.category, error.message);
               }
               all_passed = false;
           }
       }

       if !all_passed {
           std::process::exit(1);
       }

       Ok(())
   }
   ```

3. Add colorized output
   ```rust
   use colored::Colorize;

   info!("{}", "‚úÖ PASSED".green());
   error!("{}", "‚ùå FAILED".red());
   ```

4. Write integration tests:
   - `test_dry_run_validates_valid_config()`
   - `test_dry_run_detects_orphan_service()`
   - `test_dry_run_detects_circular_ordering()`

**Files to Create**:
- `crates/clnrm-core/src/cli/commands/v0_7_0/dry_run.rs`

**Acceptance Criteria**:
- [ ] Validates without containers (<1s)
- [ ] Detects all shape errors
- [ ] Colorized output
- [ ] Exit code 1 on failure
- [ ] Integration tests pass

---

## Week 3: Polish & Testing

### Day 11-12: Integration Testing

**Objective**: End-to-end workflow validation

**Tasks**:
1. Create full DX loop test
   ```rust
   #[tokio::test]
   async fn test_full_dx_loop() -> Result<()> {
       // Arrange
       let temp_dir = TempDir::new()?;
       let test_file = temp_dir.path().join("test.clnrm.toml");
       write_test_file(&test_file, VALID_CONFIG)?;

       // Act & Assert

       // 1. Dry-run validates
       let result = dry_run_command(test_file.parent().unwrap()).await?;
       assert!(result.passed);

       // 2. Format formats
       fmt_command(test_file.parent().unwrap(), false).await?;
       assert!(!needs_formatting(&test_file)?);

       // 3. Run executes (with cache)
       let run_result = run_with_cache(&test_file, false).await?;
       assert!(run_result.success());

       // 4. Run skips (cache hit)
       let run_result2 = run_with_cache(&test_file, false).await?;
       assert!(run_result2.skipped);

       // 5. dev --watch detects changes
       // (integration test with MockWatcher)

       Ok(())
   }
   ```

2. Create performance benchmarks
   ```rust
   #[bench]
   fn bench_cache_check(b: &mut Bencher) {
       let cache = FileCache::new().unwrap();
       let content = "version = \"0.7.0\"";

       b.iter(|| {
           cache.has_changed(Path::new("test.toml"), content).unwrap()
       });
   }

   #[bench]
   fn bench_dry_run_validation(b: &mut Bencher) {
       let config = load_test_config();

       b.iter(|| {
           let mut validator = ShapeValidator::new();
           validator.validate_config(&config).unwrap()
       });
   }
   ```

3. Measure performance targets
   - Cache check: <10ms ‚úÖ
   - Dry-run: <200ms ‚úÖ
   - Hot reload: <3s p95 ‚úÖ

**Files to Create**:
- `crates/clnrm-core/tests/integration/full_dx_loop.rs`
- `crates/clnrm-core/benches/subsystems.rs`

**Acceptance Criteria**:
- [ ] Full DX loop test passes
- [ ] All performance targets met
- [ ] Benchmarks run successfully
- [ ] Coverage >90%

### Day 13-14: Documentation

**Objective**: Complete user-facing documentation

**Tasks**:
1. Update CLI guide
   ```markdown
   ## DX Commands (v0.7.0)

   ### Hot Reload
   ```bash
   clnrm dev --watch
   ```
   Watches for file changes and reruns tests automatically.

   ### Fast Validation
   ```bash
   clnrm dry-run
   ```
   Validates configuration without spinning up containers.

   ### Format Files
   ```bash
   clnrm fmt            # Format all files
   clnrm fmt --check    # Check if files are formatted (CI)
   ```
   ```

2. Create migration guide
   ```markdown
   # v0.6.0 ‚Üí v0.7.0 Migration Guide

   ## Breaking Changes
   **NONE** - All v0.6.0 configurations work unchanged.

   ## New Features (Opt-In)

   ### 1. Hot Reload (dev --watch)
   - Run `clnrm dev --watch` for automatic test reruns
   - Default debounce window: 200ms

   ### 2. Cache (Automatic)
   - Skips unchanged tests automatically
   - Cache location: `~/.clnrm/cache/hashes.json`
   - Bypass with `--force` flag

   ### 3. Formatting (fmt)
   - Format all TOML files: `clnrm fmt`
   - CI check: `clnrm fmt --check`

   ### 4. Fast Validation (dry-run)
   - Validate without containers: `clnrm dry-run`
   - <1s validation time
   ```

3. Update architecture docs
   - Link to subsystem architecture
   - Link to trait hierarchy
   - Link to implementation roadmap

**Files to Create/Update**:
- `docs/CLI_GUIDE.md` (update with v0.7.0 commands)
- `docs/MIGRATION_0.6_to_0.7.md` (new)
- `README.md` (update with v0.7.0 features)

**Acceptance Criteria**:
- [ ] CLI guide updated
- [ ] Migration guide complete
- [ ] README reflects v0.7.0
- [ ] Architecture docs linked

### Day 15: Final Testing & Release Prep

**Objective**: Validate release readiness

**Tasks**:
1. Run full test suite
   ```bash
   cargo test --all-features
   cargo test --release
   cargo clippy -- -D warnings
   cargo fmt -- --check
   ```

2. Run framework self-test
   ```bash
   cargo run -- self-test
   ```

3. Performance validation
   ```bash
   cargo bench --bench subsystems
   ```

4. Create release checklist
   - [ ] All tests pass
   - [ ] Clippy: zero warnings
   - [ ] Benchmarks meet targets
   - [ ] Documentation complete
   - [ ] CHANGELOG updated
   - [ ] Version bumped to 0.7.0

5. Create release PR
   ```bash
   git checkout -b release/v0.7.0
   git add .
   git commit -m "Release v0.7.0 - DX-First Features

   - Hot reload with dev --watch (<3s latency)
   - Cache-based incremental execution
   - TOML formatting (idempotent)
   - Fast dry-run validation
   - Enhanced shape validator

   ü§ñ Generated with Claude Code"
   git push -u origin release/v0.7.0
   gh pr create --title "Release v0.7.0" --body "..."
   ```

**Acceptance Criteria**:
- [ ] All tests pass (100%)
- [ ] Zero clippy warnings
- [ ] Performance targets met
- [ ] Documentation complete
- [ ] Release PR created

---

## Critical Path Summary

### Must-Have for v0.7.0 Release
1. ‚úÖ Cache subsystem (FileCache, MemoryCache, trait)
2. ‚úÖ FileDebouncer (watch subsystem component)
3. ‚úÖ TOML formatting (format_toml_content, etc.)
4. ‚úÖ Enhanced ShapeValidator
5. **TODO**: FileWatcher trait + NotifyWatcher
6. **TODO**: dev --watch command
7. **TODO**: dry-run command
8. **TODO**: fmt command
9. **TODO**: Cache integration with run command

### Nice-to-Have (Can Defer to v0.7.1)
- Parallel test execution
- Warm container cache
- ASCII DAG visualization
- Trace jump to failure
- Custom lint rules

---

## Risk Mitigation

### Risk 1: Hot Reload Latency >3s

**Mitigation**:
- Profile early (Day 6)
- Optimize template rendering (cache Tera engine)
- Parallel validation steps
- Skip unchanged files (cache integration)

**Contingency**:
- If <3s unachievable, document <5s as acceptable
- Create optimization issue for v0.7.1

### Risk 2: Platform-Specific Watch Issues

**Mitigation**:
- Use `notify` crate (cross-platform)
- Test on macOS, Linux, Windows
- Document platform quirks

**Contingency**:
- Fallback to polling mode if native watcher fails
- Graceful degradation with warning

### Risk 3: Test Coverage <90%

**Mitigation**:
- London TDD from Day 1
- Mock all external dependencies
- Property-based tests for edge cases

**Contingency**:
- Identify untestable code paths
- Document coverage gaps
- Plan for v0.7.1

---

## Success Metrics

### Code Quality Metrics
- [ ] Zero `.unwrap()` or `.expect()` in production
- [ ] `cargo clippy -- -D warnings` passes
- [ ] All traits are dyn-compatible
- [ ] Files under 500 lines
- [ ] Test coverage >90%

### Performance Metrics
- [ ] Cache check: <10ms
- [ ] Dry-run: <200ms
- [ ] Hot reload: <3s p95
- [ ] Format: <100ms per 100 lines

### DX Metrics
- [ ] New user to green: <60s
- [ ] Edit ‚Üí rerun latency: <3s
- [ ] Validation without containers: <1s
- [ ] Format entire project: <5s

---

## Implementation Team Assignments

### Backend Team (Week 1)
- **FileWatcher Implementation**: 2 engineers
- **Cache Integration**: 1 engineer
- **Format Command**: 1 engineer

### CLI Team (Week 2)
- **dev --watch Command**: 2 engineers
- **dry-run Command**: 1 engineer

### QA Team (Week 3)
- **Integration Testing**: 2 engineers
- **Performance Benchmarking**: 1 engineer
- **Documentation**: 1 tech writer

---

## Post-Release Plan (v0.7.1+)

### v0.7.1 (Optimization Release)
- Parallel test workers
- Warm container cache
- Advanced caching strategies
- Performance tuning

### v0.8.0 (Visualization Release)
- ASCII DAG visualization
- Interactive test explorer
- Trace jump to failure
- Timeline view

### v0.9.0 (AI Release)
- AI-powered test generation
- Smart error suggestions
- Automated fixes

---

## Conclusion

The v0.7.0 architecture is **complete and implementation-ready**. This roadmap provides:

1. **Clear milestones**: 3-week implementation schedule
2. **Defined tasks**: Specific work items with acceptance criteria
3. **Risk mitigation**: Contingency plans for potential issues
4. **Success metrics**: Measurable targets for quality and performance

**Next Steps**:
1. Assign teams to Week 1 tasks
2. Begin FileWatcher implementation (Day 1-2)
3. Daily standups to track progress
4. Weekly retrospectives for course correction

**Status**: ‚úÖ READY FOR IMPLEMENTATION
