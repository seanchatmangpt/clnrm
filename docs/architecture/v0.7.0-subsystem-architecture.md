# v0.7.0 Subsystem Architecture Design

**Version**: 0.7.0
**Date**: 2025-10-17
**Architect**: System Architecture Agent
**Status**: DESIGN COMPLETE

---

## Executive Summary

This document provides comprehensive architectural design for v0.7.0 subsystems:
- **Cache** - Change detection and incremental execution
- **Watch** - File system monitoring with debouncing
- **Formatting** - Deterministic TOML formatting
- **Validation (Shape)** - Fast structural validation

All designs follow **Core Team Standards**:
- ✅ No `.unwrap()` or `.expect()` in production code
- ✅ Traits are dyn-compatible (no async trait methods)
- ✅ Proper `Result<T, CleanroomError>` error handling
- ✅ Files under 500 lines
- ✅ Observable patterns (tracing integration)

---

## 1. Cache Subsystem Architecture

### 1.1 Module Structure

```
crates/clnrm-core/src/cache/
├── mod.rs          # Public API and CacheManager
└── hash.rs         # Content hashing utilities
```

### 1.2 Core Abstractions

#### CacheManager (mod.rs)

```rust
/// Thread-safe cache manager for file hash tracking
///
/// Responsibilities:
/// - Track rendered TOML content hashes
/// - Detect changes between runs
/// - Persist cache to disk (JSON format)
/// - Thread-safe concurrent access
#[derive(Debug, Clone)]
pub struct CacheManager {
    cache_path: PathBuf,
    cache: Arc<Mutex<CacheFile>>,
}

impl CacheManager {
    /// Create with default path (~/.clnrm/cache/hashes.json)
    pub fn new() -> Result<Self>;

    /// Create with custom cache file path
    pub fn with_path(cache_path: PathBuf) -> Result<Self>;

    /// Check if file has changed (compare hash)
    /// Returns Ok(true) if changed/new, Ok(false) if unchanged
    pub fn has_changed(&self, file_path: &Path, rendered_content: &str) -> Result<bool>;

    /// Update cache with new file hash
    pub fn update(&self, file_path: &Path, rendered_content: &str) -> Result<()>;

    /// Remove file from cache (e.g., when deleted)
    pub fn remove(&self, file_path: &Path) -> Result<()>;

    /// Save cache to disk (thread-safe)
    pub fn save(&self) -> Result<()>;

    /// Get cache statistics
    pub fn stats(&self) -> Result<CacheStats>;

    /// Clear all cache entries
    pub fn clear(&self) -> Result<()>;
}
```

#### CacheFile (mod.rs)

```rust
/// Cache file format (persisted as JSON)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheFile {
    /// Version for cache invalidation
    pub version: String,
    /// File path → SHA-256 hash mapping
    pub hashes: HashMap<String, String>,
    /// Last update timestamp
    pub last_updated: DateTime<Utc>,
}

impl CacheFile {
    /// Check version compatibility
    pub fn is_compatible(&self) -> bool {
        self.version == CACHE_VERSION
    }
}
```

#### Hash Module (hash.rs)

```rust
/// Compute SHA-256 hash of content
pub fn hash_content(content: &str) -> Result<String> {
    use sha2::{Digest, Sha256};

    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    let result = hasher.finalize();

    Ok(format!("{:x}", result))
}

/// Compute hash of file (reads and hashes content)
pub fn hash_file(path: &Path) -> Result<String> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| CleanroomError::io_error(format!("Failed to read {}: {}", path.display(), e)))?;
    hash_content(&content)
}
```

### 1.3 Error Handling

```rust
// Cache errors use existing CleanroomError types:
// - IoError: File system operations
// - SerializationError: JSON parse/write
// - InternalError: Lock acquisition failures
// - ConfigurationError: Invalid cache configuration

// Example:
match cache_manager.has_changed(path, content) {
    Ok(true) => { /* run tests */ },
    Ok(false) => { /* skip */ },
    Err(e) => {
        tracing::warn!("Cache check failed: {}, running test anyway", e);
        // Fallback: run test on cache error
    }
}
```

### 1.4 Thread Safety

- **Arc<Mutex<CacheFile>>**: Thread-safe shared state
- **Clone**: CacheManager is cheaply clonable (Arc is shallow copy)
- **Lock acquisition**: Always use `?` operator, never `unwrap()`

```rust
// CORRECT: Proper lock handling
let cache = self.cache.lock()
    .map_err(|e| CleanroomError::internal_error(format!("Lock failed: {}", e)))?;

// WRONG: Would panic on poisoned lock
let cache = self.cache.lock().unwrap();  // ❌ FORBIDDEN
```

### 1.5 Integration Points

```rust
// Integration with run command
pub async fn run_with_cache(
    config_path: &Path,
    force: bool,
) -> Result<()> {
    let cache = CacheManager::new()?;

    // Render template
    let rendered = render_template(config_path)?;

    // Check cache (skip if --force flag)
    if !force && !cache.has_changed(config_path, &rendered)? {
        tracing::info!("Skipping {} (unchanged)", config_path.display());
        return Ok(());
    }

    // Run test
    let result = execute_test(&rendered)?;

    // Update cache on success
    if result.success() {
        cache.update(config_path, &rendered)?;
        cache.save()?;
    }

    Ok(())
}
```

### 1.6 Cache File Format

```json
{
  "version": "1.0.0",
  "hashes": {
    "tests/api.clnrm.toml": "a3f5...",
    "tests/db.clnrm.toml": "b7e2...",
    "scenarios/load.clnrm.toml": "c9d1..."
  },
  "last_updated": "2025-10-17T12:34:56Z"
}
```

---

## 2. Watch Subsystem Architecture

### 2.1 Module Structure

```
crates/clnrm-core/src/watch/
├── mod.rs          # Public API (FileWatcher trait - PLANNED)
└── debouncer.rs    # Event debouncing (IMPLEMENTED)
```

### 2.2 Core Abstractions

#### FileDebouncer (debouncer.rs) ✅ IMPLEMENTED

```rust
/// File event debouncer for batching rapid changes
///
/// Prevents excessive test runs when multiple save events occur
/// (e.g., auto-save, formatters, refactoring tools)
#[derive(Debug)]
pub struct FileDebouncer {
    window: Duration,
    last_event: Option<Instant>,
    event_count: usize,
}

impl FileDebouncer {
    /// Create debouncer with time window (typically 200ms)
    pub fn new(window: Duration) -> Self;

    /// Record a file change event
    pub fn record_event(&mut self);

    /// Check if debounced events should trigger action
    /// Returns true if window elapsed since last event
    pub fn should_trigger(&self) -> bool;

    /// Reset state after processing events
    pub fn reset(&mut self);

    /// Get current event count in window
    pub fn event_count(&self) -> usize;

    /// Get time since last event
    pub fn time_since_last_event(&self) -> Option<Duration>;
}

impl Default for FileDebouncer {
    fn default() -> Self {
        Self::new(Duration::from_millis(200))
    }
}
```

#### FileWatcher (mod.rs) - PLANNED

```rust
/// File system watcher trait (dyn-compatible)
///
/// CRITICAL: All methods are SYNC (no async) for dyn compatibility
pub trait FileWatcher: Send + Sync {
    /// Start watching a path
    /// Uses tokio::task::block_in_place internally for async operations
    fn watch(&self, path: &Path) -> Result<WatchHandle>;

    /// Stop watching a handle
    fn unwatch(&self, handle: WatchHandle) -> Result<()>;

    /// Get next file event (blocking with timeout)
    fn next_event(&self, timeout: Duration) -> Result<Option<WatchEvent>>;

    /// Check watcher health
    fn is_healthy(&self) -> bool;
}

/// Watch event types
#[derive(Debug, Clone)]
pub enum WatchEvent {
    /// File created
    Created(PathBuf),
    /// File modified
    Modified(PathBuf),
    /// File deleted
    Deleted(PathBuf),
    /// File renamed
    Renamed { from: PathBuf, to: PathBuf },
}

/// Watch handle for managing watchers
#[derive(Debug, Clone)]
pub struct WatchHandle {
    pub id: String,
    pub path: PathBuf,
}
```

#### NotifyWatcher (mod.rs) - PLANNED

```rust
/// Implementation using notify crate
pub struct NotifyWatcher {
    watcher: Arc<Mutex<RecommendedWatcher>>,
    events: Arc<Mutex<VecDeque<WatchEvent>>>,
}

impl NotifyWatcher {
    pub fn new() -> Result<Self> {
        let events = Arc::new(Mutex::new(VecDeque::new()));
        let events_clone = events.clone();

        let watcher = notify::recommended_watcher(move |res| {
            match res {
                Ok(event) => {
                    // Convert notify event to WatchEvent
                    if let Ok(mut queue) = events_clone.lock() {
                        queue.push_back(convert_event(event));
                    }
                }
                Err(e) => {
                    tracing::error!("Watch error: {}", e);
                }
            }
        })
        .map_err(|e| CleanroomError::internal_error(format!("Failed to create watcher: {}", e)))?;

        Ok(Self {
            watcher: Arc::new(Mutex::new(watcher)),
            events,
        })
    }
}

impl FileWatcher for NotifyWatcher {
    fn watch(&self, path: &Path) -> Result<WatchHandle> {
        let watcher = self.watcher.lock()
            .map_err(|e| CleanroomError::internal_error(format!("Lock failed: {}", e)))?;

        watcher.watch(path, RecursiveMode::Recursive)
            .map_err(|e| CleanroomError::internal_error(format!("Watch failed: {}", e)))?;

        Ok(WatchHandle {
            id: Uuid::new_v4().to_string(),
            path: path.to_path_buf(),
        })
    }

    fn next_event(&self, timeout: Duration) -> Result<Option<WatchEvent>> {
        let start = Instant::now();

        loop {
            {
                let mut queue = self.events.lock()
                    .map_err(|e| CleanroomError::internal_error(format!("Lock failed: {}", e)))?;

                if let Some(event) = queue.pop_front() {
                    return Ok(Some(event));
                }
            }

            if start.elapsed() >= timeout {
                return Ok(None);
            }

            std::thread::sleep(Duration::from_millis(10));
        }
    }

    // ... other trait methods
}
```

### 2.3 Async/Sync Boundaries

**CRITICAL**: Watcher trait is SYNC for dyn compatibility

```rust
// ❌ WRONG: Async trait breaks dyn FileWatcher
pub trait FileWatcher {
    async fn watch(&self, path: &Path) -> Result<WatchHandle>;  // FORBIDDEN
}

// ✅ CORRECT: Sync trait, async internally
pub trait FileWatcher {
    fn watch(&self, path: &Path) -> Result<WatchHandle>;  // OK
}

impl FileWatcher for NotifyWatcher {
    fn watch(&self, path: &Path) -> Result<WatchHandle> {
        // Use block_in_place for async operations if needed
        tokio::task::block_in_place(|| {
            // Async work here
        });
        Ok(handle)
    }
}
```

### 2.4 Integration with Dev Command

```rust
// dev command (async context)
pub async fn dev_watch(path: PathBuf) -> Result<()> {
    let watcher = NotifyWatcher::new()?;
    let mut debouncer = FileDebouncer::new(Duration::from_millis(200));

    watcher.watch(&path)?;

    loop {
        // Poll for events with timeout
        match watcher.next_event(Duration::from_millis(100))? {
            Some(event) => {
                tracing::debug!("File event: {:?}", event);
                debouncer.record_event();
            }
            None => {
                // Check if we should trigger after debounce window
                if debouncer.should_trigger() {
                    debouncer.reset();

                    // Run tests
                    tracing::info!("Running tests...");
                    if let Err(e) = run_tests(&path).await {
                        tracing::error!("Test run failed: {}", e);
                        // Continue watching even on error
                    }
                }
            }
        }
    }
}
```

### 2.5 Error Handling

```rust
// Watch errors:
// - InternalError: Watcher creation/operation failures
// - IoError: File system access issues

// Graceful degradation:
match watcher.watch(&path) {
    Ok(handle) => { /* watch successfully */ },
    Err(e) => {
        tracing::warn!("Watch failed: {}, falling back to manual runs", e);
        // Fall back to manual test execution
    }
}
```

---

## 3. Formatting Subsystem Architecture

### 3.1 Module Structure

```
crates/clnrm-core/src/formatting/
└── mod.rs          # TOML formatting (IMPLEMENTED)
```

### 3.2 Core Abstractions

#### Public API (mod.rs) ✅ IMPLEMENTED

```rust
/// Format TOML file with deterministic rules
/// Returns formatted content as string
pub fn format_toml_file(path: &Path) -> Result<String>;

/// Format TOML content string
/// Returns formatted string
pub fn format_toml_content(content: &str) -> Result<String>;

/// Check if file needs formatting
/// Returns true if formatting would change content
pub fn needs_formatting(path: &Path) -> Result<bool>;

/// Verify idempotency: format(format(x)) == format(x)
/// Returns true if idempotent
pub fn verify_idempotency(content: &str) -> Result<bool>;
```

#### Internal Functions (mod.rs)

```rust
/// Sort all tables in document recursively
fn sort_document(doc: &mut DocumentMut) -> Result<()>;

/// Sort a table and nested tables recursively
fn sort_table_recursive(table: &mut toml_edit::Table) -> Result<()>;

/// Sort an inline table
fn sort_inline_table(table: &mut toml_edit::InlineTable) -> Result<()>;

/// Apply additional formatting rules
/// - Remove trailing whitespace
/// - Ensure spacing around '='
/// - Ensure file ends with newline
fn apply_formatting_rules(content: &str) -> Result<String>;
```

### 3.3 Formatting Rules

1. **Alphabetical sorting**: Keys sorted within each section
2. **Consistent spacing**: ` = ` around equals sign
3. **No trailing whitespace**: All lines trimmed
4. **Newline termination**: File ends with single newline
5. **Comment preservation**: Using `toml_edit` crate
6. **Idempotent**: `fmt(fmt(x)) == fmt(x)`

### 3.4 Integration with fmt Command

```rust
// fmt command implementation
pub async fn fmt_command(
    path: Option<PathBuf>,
    check: bool,
) -> Result<()> {
    let search_path = path.unwrap_or_else(|| PathBuf::from("."));

    // Find all TOML files
    let files = find_toml_files(&search_path)?;

    let mut needs_fmt = Vec::new();

    for file in &files {
        if needs_formatting(file)? {
            needs_fmt.push(file.clone());

            if !check {
                // Format and write
                let formatted = format_toml_file(file)?;
                std::fs::write(file, formatted)
                    .map_err(|e| CleanroomError::io_error(format!("Write failed: {}", e)))?;

                tracing::info!("Formatted: {}", file.display());
            }
        }
    }

    if check {
        if !needs_fmt.is_empty() {
            tracing::error!("Files need formatting: {}", needs_fmt.len());
            std::process::exit(1);
        } else {
            tracing::info!("All files formatted correctly");
        }
    }

    Ok(())
}
```

### 3.5 Error Handling

```rust
// Formatting errors:
// - IoError: File read/write failures
// - SerializationError: TOML parse failures

// Example:
match format_toml_content(content) {
    Ok(formatted) => { /* use formatted */ },
    Err(e) => {
        tracing::error!("Format failed: {}", e);
        return Err(e);
    }
}
```

---

## 4. Validation (Shape) Subsystem Architecture

### 4.1 Module Structure

```
crates/clnrm-core/src/validation/
├── mod.rs          # Validation orchestration
├── shape.rs        # Shape validator (IMPLEMENTED)
├── otel.rs         # OTEL validation
├── span_validator.rs
├── order_validator.rs
└── ... (other validators)
```

### 4.2 Core Abstractions

#### ShapeValidator (shape.rs) ✅ IMPLEMENTED

```rust
/// Configuration shape validator
///
/// Performs static validation without containers:
/// - Required blocks present
/// - Service references valid
/// - Duration constraints valid
/// - Temporal ordering acyclic
/// - Glob patterns compile
pub struct ShapeValidator {
    errors: Vec<ShapeValidationError>,
}

impl ShapeValidator {
    pub fn new() -> Self;

    /// Validate configuration file
    pub fn validate_file(&mut self, path: &Path) -> Result<ShapeValidationResult>;

    /// Validate parsed configuration
    pub fn validate_config(&mut self, config: &TestConfig) -> Result<()>;

    /// Get validation errors
    pub fn errors(&self) -> &[ShapeValidationError];

    /// Check if validation passed
    pub fn is_valid(&self) -> bool;
}
```

#### Validation Result (shape.rs)

```rust
/// Result of shape validation
#[derive(Debug, Clone)]
pub struct ShapeValidationResult {
    pub passed: bool,
    pub errors: Vec<ShapeValidationError>,
    pub file_path: String,
}

/// Shape validation error
#[derive(Debug, Clone)]
pub struct ShapeValidationError {
    pub message: String,
    pub line: Option<usize>,
    pub category: ErrorCategory,
}

/// Error categories
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ErrorCategory {
    MissingRequired,
    InvalidStructure,
    OrphanReference,
    InvalidDuration,
    CircularOrdering,
    InvalidGlob,
    OtelError,
}
```

#### Validation Rules (shape.rs)

```rust
impl ShapeValidator {
    /// 1. Validate required blocks ([meta], [[scenario]])
    fn validate_required_blocks(&mut self, config: &TestConfig);

    /// 2. Validate OTEL configuration
    fn validate_otel_config(&mut self, config: &TestConfig);

    /// 3. Validate scenarios (name, steps present)
    fn validate_scenarios(&mut self, config: &TestConfig);

    /// 4. Validate service references (no orphans)
    fn validate_service_references(&mut self, config: &TestConfig);

    /// 5. Validate duration constraints (min < max)
    fn validate_duration_constraints(&mut self, config: &TestConfig);

    /// 6. Validate temporal ordering (no cycles)
    fn validate_temporal_ordering(&mut self, config: &TestConfig);

    /// 7. Validate glob patterns compile
    fn validate_glob_patterns(&mut self, config: &TestConfig);
}
```

### 4.3 Cycle Detection Algorithm

```rust
/// Detect cycles in temporal ordering using DFS
fn check_ordering_cycles(&mut self, order: &OrderExpectationConfig) {
    // Build directed graph from ordering constraints
    let mut graph: HashMap<String, Vec<String>> = HashMap::new();

    // must_precede: A → B (A before B)
    if let Some(ref must_precede) = order.must_precede {
        for (first, second) in must_precede {
            graph.entry(first.clone()).or_default().push(second.clone());
        }
    }

    // must_follow: A follows B → B → A
    if let Some(ref must_follow) = order.must_follow {
        for (first, second) in must_follow {
            graph.entry(second.clone()).or_default().push(first.clone());
        }
    }

    // DFS cycle detection
    let mut visited = HashSet::new();
    let mut rec_stack = HashSet::new();

    for node in graph.keys() {
        if !visited.contains(node) {
            if self.has_cycle_dfs(node, &graph, &mut visited, &mut rec_stack) {
                self.errors.push(ShapeValidationError::new(
                    ErrorCategory::CircularOrdering,
                    format!("Circular ordering detected involving '{}'", node),
                ));
                break;
            }
        }
    }
}

fn has_cycle_dfs(
    &self,
    node: &str,
    graph: &HashMap<String, Vec<String>>,
    visited: &mut HashSet<String>,
    rec_stack: &mut HashSet<String>,
) -> bool {
    visited.insert(node.to_string());
    rec_stack.insert(node.to_string());

    if let Some(neighbors) = graph.get(node) {
        for neighbor in neighbors {
            if !visited.contains(neighbor) {
                if self.has_cycle_dfs(neighbor, graph, visited, rec_stack) {
                    return true;
                }
            } else if rec_stack.contains(neighbor) {
                return true;  // Back edge = cycle
            }
        }
    }

    rec_stack.remove(node);
    false
}
```

### 4.4 Integration with dry-run Command

```rust
/// Dry-run command (fast validation without containers)
pub async fn dry_run_command(path: Option<PathBuf>) -> Result<()> {
    let search_path = path.unwrap_or_else(|| PathBuf::from("."));

    // Find all test files
    let files = find_test_files(&search_path)?;

    let mut all_passed = true;
    let mut validator = ShapeValidator::new();

    for file in &files {
        let result = validator.validate_file(file)?;

        if result.passed {
            tracing::info!("✅ {} - PASSED", file.display());
        } else {
            tracing::error!("❌ {} - FAILED", file.display());
            for error in &result.errors {
                tracing::error!("  {:?}: {}", error.category, error.message);
            }
            all_passed = false;
        }
    }

    if !all_passed {
        std::process::exit(1);
    }

    Ok(())
}
```

### 4.5 Error Handling

```rust
// Shape validation errors:
// - ValidationError: Configuration structure issues
// - ConfigurationError: Invalid config values
// - IoError: File read failures

// Example:
match validator.validate_file(path) {
    Ok(result) => {
        if !result.passed {
            for error in result.errors {
                tracing::error!("{:?}: {}", error.category, error.message);
            }
        }
    }
    Err(e) => {
        tracing::error!("Validation failed: {}", e);
        return Err(e);
    }
}
```

---

## 5. Integration Architecture

### 5.1 Subsystem Dependencies

```
┌─────────────┐
│   Cache     │──┐
└─────────────┘  │
                 │
┌─────────────┐  │     ┌─────────────┐
│   Watch     │──┼────→│ Run Command │
└─────────────┘  │     └─────────────┘
                 │            ↓
┌─────────────┐  │     ┌─────────────┐
│ Formatting  │──┘     │  Template   │
└─────────────┘        │  Renderer   │
                       └─────────────┘
┌─────────────┐               ↓
│ Validation  │        ┌─────────────┐
│   (Shape)   │───────→│   Config    │
└─────────────┘        │   Parser    │
                       └─────────────┘
```

### 5.2 CLI Command Flow

#### dev --watch Command

```
User: clnrm dev --watch

1. FileWatcher.watch(path)           [watch subsystem]
2. Loop:
   a. next_event(timeout)            [watch subsystem]
   b. debouncer.record_event()       [watch subsystem]
   c. debouncer.should_trigger()?    [watch subsystem]
   d. render_template()              [template subsystem]
   e. cache.has_changed()?           [cache subsystem]
   f. run_tests()                    [execution subsystem]
   g. cache.update()                 [cache subsystem]
```

#### dry-run Command

```
User: clnrm dry-run

1. find_test_files(path)             [filesystem]
2. For each file:
   a. render_template()              [template subsystem]
   b. validator.validate_file()      [validation subsystem]
   c. Report results                 [reporting]
```

#### fmt Command

```
User: clnrm fmt [--check]

1. find_toml_files(path)             [filesystem]
2. For each file:
   a. needs_formatting()?            [formatting subsystem]
   b. format_toml_file()             [formatting subsystem]
   c. write_file()                   [filesystem]
```

### 5.3 Error Propagation Patterns

```rust
/// Pipeline error handling pattern
pub async fn execute_pipeline(config_path: &Path) -> Result<()> {
    // Step 1: Render (TemplateError)
    let rendered = render_template(config_path)
        .map_err(|e| e.with_context(format!("Template rendering failed for {}", config_path.display())))?;

    // Step 2: Validate (ValidationError)
    let mut validator = ShapeValidator::new();
    let validation_result = validator.validate_file(config_path)
        .map_err(|e| e.with_context("Shape validation failed"))?;

    if !validation_result.passed {
        return Err(CleanroomError::validation_error(
            format!("Configuration invalid: {:?}", validation_result.errors)
        ));
    }

    // Step 3: Check cache (IoError, InternalError)
    let cache = CacheManager::new()?;
    let changed = cache.has_changed(config_path, &rendered)
        .map_err(|e| {
            tracing::warn!("Cache check failed: {}, running anyway", e);
            true  // Default to running on cache error
        })
        .unwrap_or(true);

    if !changed {
        tracing::info!("Skipped (unchanged)");
        return Ok(());
    }

    // Step 4: Execute (ContainerError, ExecutionError)
    let result = execute_test(&rendered).await?;

    // Step 5: Update cache (IoError)
    if result.success() {
        cache.update(config_path, &rendered)?;
        cache.save()?;
    }

    Ok(())
}
```

---

## 6. Observable Patterns

### 6.1 Tracing Integration

All subsystems use `tracing` for observability:

```rust
use tracing::{debug, info, warn, error, instrument};

// Cache subsystem
#[instrument(skip(self, content))]
pub fn has_changed(&self, file_path: &Path, content: &str) -> Result<bool> {
    debug!("Checking cache for: {}", file_path.display());

    let hash = hash_content(content)?;
    let cache = self.cache.lock()?;

    match cache.hashes.get(&file_path.to_string_lossy().to_string()) {
        Some(cached_hash) if cached_hash == &hash => {
            debug!("Cache hit: {} (unchanged)", file_path.display());
            Ok(false)
        }
        Some(_) => {
            info!("Cache miss: {} (changed)", file_path.display());
            Ok(true)
        }
        None => {
            info!("Cache miss: {} (new file)", file_path.display());
            Ok(true)
        }
    }
}

// Watch subsystem
#[instrument]
pub fn record_event(&mut self) {
    let now = Instant::now();

    if let Some(last) = self.last_event {
        let elapsed = now.duration_since(last);
        if elapsed < self.window {
            debug!("Debouncer: Event {} within window ({:.0}ms)",
                   self.event_count + 1, elapsed.as_millis());
        }
    }

    self.event_count += 1;
    self.last_event = Some(now);
}

// Validation subsystem
#[instrument(skip(self, config))]
fn validate_service_references(&mut self, config: &TestConfig) {
    debug!("Validating service references");

    let defined_services = self.collect_defined_services(config);
    debug!("Found {} defined services", defined_services.len());

    for scenario in &config.scenario {
        self.validate_scenario_refs(scenario, &defined_services);
    }
}
```

### 6.2 OTEL Metrics (Optional)

```rust
#[cfg(feature = "otel-metrics")]
use clnrm_core::telemetry::metrics;

// Cache metrics
#[cfg(feature = "otel-metrics")]
pub fn record_cache_metrics(&self) {
    let stats = self.stats().unwrap_or_default();
    metrics::record_gauge("cache.total_files", stats.total_files as f64);
}

// Watch metrics
#[cfg(feature = "otel-metrics")]
pub fn record_watch_metrics(&self, event_count: usize, latency_ms: f64) {
    metrics::increment_counter("watch.events.total", event_count as u64);
    metrics::record_histogram("watch.debounce_latency_ms", latency_ms);
}

// Validation metrics
#[cfg(feature = "otel-metrics")]
pub fn record_validation_metrics(&self, result: &ShapeValidationResult) {
    let outcome = if result.passed { "pass" } else { "fail" };
    metrics::increment_counter_with_labels(
        "validation.shape.total",
        1,
        &[("outcome", outcome)]
    );
}
```

---

## 7. Testing Architecture (London TDD)

### 7.1 Test Patterns

All subsystems follow **London School TDD** (AAA pattern):

```rust
#[tokio::test]
async fn test_cache_detects_changed_file() -> Result<()> {
    // Arrange
    let temp_dir = TempDir::new()?;
    let cache_path = temp_dir.path().join("cache.json");
    let manager = CacheManager::with_path(cache_path)?;

    let test_path = PathBuf::from("/test/file.toml");
    let content1 = "version = \"0.6.0\"";
    let content2 = "version = \"0.7.0\"";

    // Act
    manager.update(&test_path, content1)?;
    let changed = manager.has_changed(&test_path, content2)?;

    // Assert
    assert!(changed, "Changed file should be detected");

    Ok(())
}

#[test]
fn test_debouncer_batches_rapid_events() {
    // Arrange
    let mut debouncer = FileDebouncer::new(Duration::from_millis(100));

    // Act - Simulate rapid saves
    for _ in 0..5 {
        debouncer.record_event();
        thread::sleep(Duration::from_millis(10));
    }

    // Assert
    assert_eq!(debouncer.event_count(), 5);
    assert!(!debouncer.should_trigger()); // Still within window
}

#[test]
fn test_shape_validator_detects_orphan_service() -> Result<()> {
    // Arrange
    let config = TestConfig {
        meta: Some(MetaConfig { name: "test".into(), version: "1.0.0".into(), description: None }),
        services: None,  // No services defined
        scenario: vec![ScenarioConfig {
            name: "test".into(),
            steps: vec![StepConfig {
                name: "step1".into(),
                service: Some("nonexistent".into()),  // Orphan reference
                command: vec!["echo".into()],
                ..Default::default()
            }],
            ..Default::default()
        }],
        ..Default::default()
    };

    let mut validator = ShapeValidator::new();

    // Act
    validator.validate_config(&config)?;

    // Assert
    assert!(!validator.is_valid());
    assert!(validator.errors().iter().any(|e| e.category == ErrorCategory::OrphanReference));

    Ok(())
}
```

### 7.2 Mock Strategies

```rust
// Mock FileWatcher for testing dev command
#[cfg(test)]
pub struct MockWatcher {
    events: Arc<Mutex<Vec<WatchEvent>>>,
}

#[cfg(test)]
impl MockWatcher {
    pub fn new() -> Self {
        Self {
            events: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn inject_event(&self, event: WatchEvent) {
        self.events.lock().unwrap().push(event);
    }
}

#[cfg(test)]
impl FileWatcher for MockWatcher {
    fn watch(&self, _path: &Path) -> Result<WatchHandle> {
        Ok(WatchHandle { id: "mock".into(), path: PathBuf::from("/mock") })
    }

    fn next_event(&self, _timeout: Duration) -> Result<Option<WatchEvent>> {
        let mut events = self.events.lock().unwrap();
        Ok(events.pop())
    }

    // ... other methods
}
```

---

## 8. Performance Considerations

### 8.1 Performance Targets

| Operation | Target | Subsystem |
|-----------|--------|-----------|
| Cache check | <10ms | Cache |
| Hash calculation | <50ms | Cache |
| Debounce window | 200ms | Watch |
| Watch startup | <500ms | Watch |
| Format (100 lines) | <100ms | Formatting |
| Shape validation | <200ms | Validation |

### 8.2 Optimization Strategies

#### Cache Subsystem
- **In-memory cache**: `Arc<Mutex<CacheFile>>` for fast access
- **SHA-256 streaming**: For large files
- **Lazy persistence**: Save only when changed

#### Watch Subsystem
- **Event batching**: Debouncer prevents excessive runs
- **Non-recursive watching**: Only watch specified paths
- **Event filtering**: Ignore temporary files (`.swp`, `.tmp`)

#### Formatting Subsystem
- **Single-pass sorting**: `toml_edit` preserves structure
- **Lazy formatting**: Check before format
- **Parallel formatting**: Process multiple files concurrently

#### Validation Subsystem
- **Early termination**: Stop on first fatal error
- **Lazy graph building**: Build only when needed
- **Cache regex compilation**: Compile glob patterns once

---

## 9. Security Considerations

### 9.1 File System Safety

```rust
// Prevent path traversal
fn sanitize_path(path: &Path) -> Result<PathBuf> {
    let canonical = path.canonicalize()
        .map_err(|e| CleanroomError::io_error(format!("Invalid path: {}", e)))?;

    // Ensure path is within allowed directory
    let allowed_root = std::env::current_dir()?;

    if !canonical.starts_with(&allowed_root) {
        return Err(CleanroomError::validation_error(
            "Path traversal detected"
        ));
    }

    Ok(canonical)
}
```

### 9.2 Content Validation

```rust
// Validate file size before processing
const MAX_FILE_SIZE: u64 = 10 * 1024 * 1024; // 10MB

fn validate_file_size(path: &Path) -> Result<()> {
    let metadata = std::fs::metadata(path)?;

    if metadata.len() > MAX_FILE_SIZE {
        return Err(CleanroomError::validation_error(
            format!("File too large: {} bytes", metadata.len())
        ));
    }

    Ok(())
}
```

---

## 10. Migration Path

### 10.1 Backward Compatibility

**ALL v0.6.0 configurations work unchanged in v0.7.0**

- Cache is **opt-in** (automatic, can disable with `--force`)
- Watch is **opt-in** (`clnrm dev --watch`)
- Formatting is **opt-in** (`clnrm fmt`)
- Shape validation is **additive** (existing validation still works)

### 10.2 Deprecation Strategy

No deprecations in v0.7.0. All v0.6.0 features remain.

---

## 11. Definition of Done

### 11.1 Code Quality
- [ ] Zero `.unwrap()` or `.expect()` in production code
- [ ] All traits are dyn-compatible (no async trait methods)
- [ ] Proper `Result<T, CleanroomError>` error handling
- [ ] Files under 500 lines
- [ ] `cargo clippy -- -D warnings` passes

### 11.2 Testing
- [ ] Unit tests for all public functions (London TDD)
- [ ] Integration tests for subsystem interactions
- [ ] Property tests for edge cases (where applicable)
- [ ] Coverage >90% for new code

### 11.3 Documentation
- [ ] Public API documentation with examples
- [ ] Architecture diagrams (this document)
- [ ] Integration guides for CLI commands
- [ ] Migration guide for v0.6.0 users

### 11.4 Observability
- [ ] Tracing instrumentation for all operations
- [ ] OTEL metrics (optional, feature-gated)
- [ ] Structured error messages
- [ ] Performance benchmarks

---

## 12. Future Enhancements (Post-v0.7.0)

### 12.1 Cache Subsystem
- Distributed cache (Redis/memcached)
- Content-addressed storage
- Cache warming strategies

### 12.2 Watch Subsystem
- Selective watching (glob patterns)
- Multi-watcher coordination
- Remote file watching (network filesystems)

### 12.3 Formatting Subsystem
- Custom formatting rules
- Language server protocol (LSP) integration
- Auto-fix for common issues

### 12.4 Validation Subsystem
- Static analysis rules
- Custom validation plugins
- Machine learning-based suggestions

---

## Conclusion

This architecture provides a solid foundation for v0.7.0 DX features while maintaining:
- **Core Team Standards**: No panics, dyn-compatible traits, proper error handling
- **Production Quality**: Thread-safe, observable, well-tested
- **Extensibility**: Plugin-based, modular design
- **Performance**: <3s hot reload, <1s dry-run, <2s formatting

All subsystems integrate seamlessly with existing v0.6.0 infrastructure and provide clear upgrade paths for future enhancements.

**Next Steps**: Begin implementation with TDD approach, starting with Cache subsystem (highest integration impact).
