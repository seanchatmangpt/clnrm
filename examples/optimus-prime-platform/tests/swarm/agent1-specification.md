# Agent 1: Specification Analysis - Image Upload Functionality

**Agent Role**: Specification Analyst
**Date**: October 16, 2025
**Mission**: Define EXACT requirements for vision-based image upload system
**Context**: Investigating false positive claims in report card analysis feature

---

## Executive Summary

This specification defines the **precise, testable requirements** for the report card image upload feature that integrates vision AI analysis. The system allows users to upload report card images through a browser interface, processes them via the Ollama qwen2.5-vl vision model, and returns structured analysis data via NDJSON streaming.

**Critical Finding**: Current implementation is 100% UNTESTED in real browser environments. All claims are based on code inspection, NOT execution validation.

---

## 1. Functional Requirements

### FR-1: File Selection Mechanism

#### FR-1.1: Click-to-Browse Selection
**Component**: `src/components/prompt-input-upload.tsx:227-237`
**Status**: ‚ö†Ô∏è UNTESTED

**EXACT Behavior**:
1. When user clicks the drop zone area (line 227)
2. Browser's native file picker dialog MUST open
3. File picker MUST filter to show only image types (`accept="image/*"`)
4. Upon file selection, `handleFileSelect()` MUST fire (line 43-60)
5. If selected file is NOT an image type, error message MUST display: "Please select an image file"
6. If selected file IS an image type, `selectedFile` state MUST update with File object
7. If selected file IS an image type, `previewUrl` state MUST update with data URL

**Testable Assertions**:
```typescript
ASSERT: onClick event on drop zone triggers fileInputRef.current.click()
ASSERT: file input accepts="image/*" attribute is present
ASSERT: handleFileSelect receives File object when file selected
ASSERT: file.type.startsWith('image/') check executes correctly
ASSERT: setSelectedFile(file) called with valid File object
ASSERT: FileReader.readAsDataURL() generates valid data URL
ASSERT: setPreviewUrl() receives base64 encoded image string
```

#### FR-1.2: Drag-and-Drop Selection
**Component**: `src/components/prompt-input-upload.tsx:62-73`
**Status**: ‚ö†Ô∏è UNTESTED

**EXACT Behavior**:
1. When user drags file over drop zone, `onDragOver` MUST prevent default browser behavior
2. When user drops file, `handleDrop` MUST fire (line 62)
3. File MUST be extracted from `e.dataTransfer.files[0]`
4. If file type does NOT start with 'image/', file MUST be rejected (no error shown, silent rejection)
5. If file type DOES start with 'image/', same flow as click-to-browse (steps 6-7 from FR-1.1)

**Testable Assertions**:
```typescript
ASSERT: onDragOver calls e.preventDefault()
ASSERT: onDrop extracts first file from dataTransfer.files
ASSERT: file.type.startsWith('image/') validation occurs
ASSERT: Only image files update selectedFile state
ASSERT: Non-image files are silently rejected (no state change)
```

**Critical Gap**: No visual feedback for invalid drag-drop files

---

### FR-2: FormData Construction

#### FR-2.1: FormData Assembly
**Component**: `src/components/prompt-input-upload.tsx:90-94`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. When `analyzeReportCard()` is called, new FormData object MUST be created
2. selectedFile (File object) MUST be appended with key 'image'
3. If studentName.trim() is non-empty, it MUST be appended with key 'studentName'
4. If studentName.trim() is empty, 'studentName' key MUST NOT exist in FormData

**Testable Assertions**:
```typescript
ASSERT: new FormData() creates multipart/form-data structure
ASSERT: formData.append('image', selectedFile) adds File object
ASSERT: formData.get('image') returns File object matching selectedFile
ASSERT: When studentName='John', formData.get('studentName') === 'John'
ASSERT: When studentName='  ', formData.get('studentName') === null
ASSERT: FormData boundary is auto-generated by browser
```

**Critical Assumption**: Browser FormData API works identically to Node.js implementation
**Risk**: üî¥ HIGH - Never validated in actual browser

---

### FR-3: API Request Execution

#### FR-3.1: HTTP POST Request
**Component**: `src/components/prompt-input-upload.tsx:96-103`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. Request MUST be sent to `/api/vision/analyze-report-card` endpoint
2. Request MUST use POST method
3. Request body MUST be FormData object (from FR-2.1)
4. Browser MUST automatically set `Content-Type: multipart/form-data` header with boundary
5. Browser MUST NOT manually set Content-Type (let browser handle it)
6. If response.ok is false, error MUST be thrown with message "Failed to analyze report card"

**Testable Assertions**:
```typescript
ASSERT: fetch() called with URL '/api/vision/analyze-report-card'
ASSERT: method === 'POST'
ASSERT: body is FormData instance
ASSERT: Content-Type header NOT manually set
ASSERT: Browser sets Content-Type with multipart boundary
ASSERT: response.ok check determines success/failure
```

**Critical Assumption**: Browser fetch() handles FormData correctly
**Risk**: üî¥ HIGH - FormData boundary generation never verified

---

### FR-4: API Request Handling (Server-Side)

#### FR-4.1: FormData Parsing
**Component**: `src/app/api/vision/analyze-report-card/route.ts:19-28`
**Status**: ‚ö†Ô∏è UNTESTED WITH REAL BROWSER REQUESTS

**EXACT Behavior**:
1. Server MUST receive multipart/form-data request
2. `request.formData()` MUST parse multipart boundary correctly
3. `formData.get('image')` MUST return File object
4. `formData.get('studentName')` MUST return string or null
5. If 'image' key is missing/null, response MUST be 400 with error "No image provided"
6. File object MUST have `.size`, `.type`, and `.arrayBuffer()` methods

**Testable Assertions**:
```typescript
ASSERT: request.formData() successfully parses multipart data
ASSERT: imageFile instanceof File === true
ASSERT: imageFile.type contains MIME type (e.g., 'image/jpeg')
ASSERT: imageFile.size is positive number
ASSERT: imageFile.arrayBuffer() returns ArrayBuffer
ASSERT: studentName is string or null
ASSERT: Missing image returns 400 status
```

**Critical Assumption**: Next.js App Router FormData parsing matches browser FormData
**Risk**: üî¥ HIGH - Never tested with browser-generated FormData

---

#### FR-4.2: Image Data Conversion
**Component**: `src/app/api/vision/analyze-report-card/route.ts:42-44`
**Status**: ‚ö†Ô∏è UNTESTED WITH REAL IMAGES

**EXACT Behavior**:
1. `imageFile.arrayBuffer()` MUST return binary image data
2. `Buffer.from(arrayBuffer)` MUST create Node.js Buffer
3. `.toString('base64')` MUST encode buffer as base64 string
4. Data URL MUST be formatted as: `data:${imageFile.type};base64,${base64Image}`
5. imageFile.type MUST be valid MIME type (e.g., 'image/jpeg', 'image/png')

**Testable Assertions**:
```typescript
ASSERT: arrayBuffer is ArrayBuffer instance
ASSERT: Buffer.from(arrayBuffer) creates Buffer
ASSERT: base64Image is base64-encoded string
ASSERT: imageDataUrl format matches: /^data:image\/[a-z]+;base64,[A-Za-z0-9+/=]+$/
ASSERT: base64 string decodes back to original binary data
```

**Critical Assumption**: Image binary data survives FormData transport intact
**Risk**: üî¥ CRITICAL - Never verified with real browser upload

---

### FR-5: Vision Model Processing

#### FR-5.1: Vision Model Input
**Component**: `src/app/api/vision/analyze-report-card/route.ts:58-71`
**Status**: üî¥ CRITICAL - COMPLETELY UNTESTED

**EXACT Behavior**:
1. `streamObject()` MUST be called with Ollama provider
2. Model name MUST be 'qwen2.5-vl:latest'
3. Schema MUST be `reportCardAnalysisSchema` (from `/lib/vision-schema`)
4. Messages array MUST contain exactly 2 content items:
   - Item 1: `{ type: 'text', text: analysisPrompt }`
   - Item 2: `{ type: 'image', image: imageDataUrl }`
5. Mode MUST be 'json' for structured output
6. Model MUST return object matching `reportCardAnalysisSchema`

**Testable Assertions**:
```typescript
ASSERT: ollama('qwen2.5-vl:latest') provider is instantiated
ASSERT: messages[0].content has 2 items
ASSERT: messages[0].content[0].type === 'text'
ASSERT: messages[0].content[1].type === 'image'
ASSERT: messages[0].content[1].image starts with 'data:image/'
ASSERT: mode === 'json'
ASSERT: schema matches reportCardAnalysisSchema
```

**Critical Unknown**: Does qwen2.5-vl actually process images correctly?
**Risk**: üî¥ CRITICAL - Vision model NEVER tested with real images

---

#### FR-5.2: Vision Analysis Output
**Component**: `src/app/api/vision/analyze-report-card/route.ts:74`
**Status**: üî¥ CRITICAL - UNTESTED WITH REAL IMAGES

**EXACT Expected Schema**:
```typescript
interface ReportCardAnalysis {
  studentName: string;          // Extracted from image OCR
  documentType: string;          // e.g., "report card", "progress report"
  overallPerformance: string;    // e.g., "excellent", "good", "needs improvement"
  grades: Array<{
    subject: string;
    grade: string;
  }>;
  strengths: string[];           // Teacher comments about strengths
  weaknesses: string[];          // Areas needing improvement
  achievements: string[];        // Awards, honors, special recognition
  virtuesDetected: string[];     // Character traits mentioned
}
```

**Testable Assertions**:
```typescript
ASSERT: analysis.studentName is non-empty string
ASSERT: analysis.documentType is string
ASSERT: analysis.overallPerformance is string
ASSERT: analysis.grades is array of objects with 'subject' and 'grade'
ASSERT: analysis.strengths is array of strings
ASSERT: analysis.weaknesses is array of strings
ASSERT: analysis.achievements is array of strings
ASSERT: analysis.virtuesDetected is array of strings
ASSERT: All fields match reportCardAnalysisSchema types
```

**Critical Unknown**: Can qwen2.5-vl actually extract text from report card images?
**Risk**: üî¥ CRITICAL - OCR capability completely unproven

---

### FR-6: Optimus Prime Response Generation

#### FR-6.1: Response Prompt Construction
**Component**: `src/app/api/vision/analyze-report-card/route.ts:83-101`
**Status**: ‚ö†Ô∏è TESTED WITH MOCK DATA ONLY

**EXACT Behavior**:
1. Response prompt MUST include student name from analysis
2. Prompt MUST include all analysis fields (performance, grades, strengths, etc.)
3. Prompt MUST request personalized, inspiring response
4. Model MUST be 'qwen3-coder:30b' (NOT vision model)
5. Schema MUST be `optimusResponseSchema`

**Testable Assertions**:
```typescript
ASSERT: responsePrompt includes analysis.studentName
ASSERT: responsePrompt includes analysis.overallPerformance
ASSERT: responsePrompt includes all grades formatted as "subject: grade"
ASSERT: ollama('qwen3-coder:30b') is used
ASSERT: schema matches optimusResponseSchema
ASSERT: mode === 'json'
```

---

#### FR-6.2: Optimus Response Schema
**Component**: `/lib/vision-schema` (imported at line 3)
**Status**: ‚ö†Ô∏è SCHEMA DEFINED, OUTPUT UNTESTED

**EXACT Expected Schema**:
```typescript
interface OptimusResponse {
  greeting: string;              // Personalized greeting
  message: string;               // Main inspirational message
  actionableAdvice: string[];    // 3-5 specific pieces of advice
}
```

**Testable Assertions**:
```typescript
ASSERT: optimusResponse.greeting is non-empty string
ASSERT: optimusResponse.message is non-empty string
ASSERT: optimusResponse.actionableAdvice is array with length >= 3 && <= 5
ASSERT: All advice items are non-empty strings
ASSERT: Response matches optimusResponseSchema
```

---

### FR-7: NDJSON Streaming Response

#### FR-7.1: Stream Construction (Server)
**Component**: `src/app/api/vision/analyze-report-card/route.ts:118-148`
**Status**: ‚ö†Ô∏è UNTESTED END-TO-END

**EXACT Behavior**:
1. Response MUST be ReadableStream
2. Stream MUST encode data with TextEncoder
3. First chunk MUST be analysis: `{"type":"analysis","data":{...}}\n`
4. Subsequent chunks MUST be response partials: `{"type":"response","data":{...}}\n`
5. Each chunk MUST end with newline character `\n`
6. Content-Type header MUST be 'application/x-ndjson'
7. X-Student-Name header MUST contain student name or 'unknown'
8. Stream MUST close after all data sent

**Testable Assertions**:
```typescript
ASSERT: Response body is ReadableStream
ASSERT: Content-Type === 'application/x-ndjson'
ASSERT: X-Student-Name header exists
ASSERT: First chunk has type='analysis'
ASSERT: Subsequent chunks have type='response'
ASSERT: All chunks end with '\n'
ASSERT: Each line is valid JSON
ASSERT: Stream closes after optimusResult completes
```

---

#### FR-7.2: Stream Consumption (Client)
**Component**: `src/components/prompt-input-upload.tsx:106-133`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. `response.body.getReader()` MUST return ReadableStreamDefaultReader
2. TextDecoder MUST decode Uint8Array chunks
3. Chunks MUST be split on newline: `chunk.split('\n')`
4. Empty lines MUST be filtered out: `.filter(line => line.trim())`
5. Each line MUST be parsed as JSON
6. Lines with `type: 'analysis'` MUST update `analysis` state
7. Lines with `type: 'response'` MUST update `optimusResponse` state
8. Invalid JSON MUST be caught and logged (not throw)
9. When stream is done, loop MUST break

**Testable Assertions**:
```typescript
ASSERT: reader is ReadableStreamDefaultReader
ASSERT: decoder is TextDecoder instance
ASSERT: chunk.split('\n') creates array of lines
ASSERT: Empty lines are filtered out
ASSERT: JSON.parse() called for each line
ASSERT: parsed.type === 'analysis' triggers setAnalysis()
ASSERT: parsed.type === 'response' triggers setOptimusResponse()
ASSERT: JSON parse errors are caught and logged
ASSERT: done === true exits loop
```

**Critical Assumption**: Browser ReadableStream API works identically to Node.js
**Risk**: üü° MEDIUM - Stream parsing never validated in browser

---

### FR-8: UI State Management

#### FR-8.1: Analysis State Flow
**Component**: `src/components/prompt-input-upload.tsx:32-41`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT State Transitions**:
```
Initial State:
  selectedFile: null
  previewUrl: null
  isAnalyzing: false
  analysis: null
  optimusResponse: null
  evaluation: null
  error: null
  processingStage: ''

After File Selection:
  selectedFile: File
  previewUrl: string (data URL)
  error: null

During Analysis:
  isAnalyzing: true
  processingStage: 'üîç Analyzing report card with vision AI...'

After Vision Analysis:
  analysis: ReportCardAnalysis
  processingStage: 'üìä Vision analysis complete! Generating Optimus response...'

After Optimus Response:
  optimusResponse: OptimusResponse
  processingStage: 'ü§ñ Optimus Prime response ready!'

After Evaluation:
  evaluation: ChainOfThoughtEvaluation
  processingStage: '‚≠ê Evaluation complete with detailed reasoning!'
  isAnalyzing: false

On Error:
  error: string
  isAnalyzing: false
```

**Testable Assertions**:
```typescript
ASSERT: Initial state matches expected values
ASSERT: handleFileSelect updates selectedFile and previewUrl
ASSERT: analyzeReportCard sets isAnalyzing=true
ASSERT: Stream analysis chunk updates analysis state
ASSERT: Stream response chunk updates optimusResponse state
ASSERT: processingStage updates match expected messages
ASSERT: Error sets isAnalyzing=false and error message
ASSERT: Reset clears all state back to initial
```

---

#### FR-8.2: Button State Management
**Component**: `src/components/prompt-input-upload.tsx:279-294`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. "Analyze with Vision AI" button:
   - Disabled when: `!selectedFile || isAnalyzing`
   - Enabled when: `selectedFile && !isAnalyzing`
   - Text when analyzing: "üîç Analyzing..."
   - Text when idle: "üöÄ Analyze with Vision AI"
   - onClick triggers: `analyzeReportCard()`

2. "Reset" button:
   - Visible when: `selectedFile || analysis`
   - Hidden when: `!selectedFile && !analysis`
   - Disabled when: `isAnalyzing`
   - Enabled when: `!isAnalyzing`
   - onClick triggers: `reset()`

**Testable Assertions**:
```typescript
ASSERT: Analyze button disabled when selectedFile === null
ASSERT: Analyze button enabled when selectedFile !== null && !isAnalyzing
ASSERT: Analyze button disabled when isAnalyzing === true
ASSERT: Analyze button text changes during analysis
ASSERT: Reset button renders when selectedFile or analysis exists
ASSERT: Reset button disabled when isAnalyzing === true
ASSERT: Reset button onClick calls reset()
```

---

### FR-9: Chain-of-Thought Evaluation

#### FR-9.1: Evaluation Trigger
**Component**: `src/components/prompt-input-upload.tsx:136-139`
**Status**: ‚ö†Ô∏è UNTESTED WITH REAL VISION DATA

**EXACT Behavior**:
1. Evaluation MUST trigger ONLY when `analysis` is non-null
2. Evaluation MUST call `generateEvaluation(analysis)` after stream completes
3. Processing stage MUST update to: "üß† Optimus Prime is thinking deeply about your progress..."

**Testable Assertions**:
```typescript
ASSERT: generateEvaluation called only if analysis !== null
ASSERT: generateEvaluation receives ReportCardAnalysis object
ASSERT: processingStage updates before evaluation starts
```

**Critical Gap**: Integration between vision analysis and evaluation untested

---

#### FR-9.2: Evaluation API Call
**Component**: `src/components/prompt-input-upload.tsx:154-191`
**Status**: ‚ö†Ô∏è TESTED WITH MOCK DATA ONLY

**EXACT Behavior**:
1. Request MUST POST to `/api/vision/evaluate-with-reasoning`
2. Content-Type MUST be 'application/json'
3. Body MUST be: `{"analysis": analysisData}`
4. Response MUST be NDJSON stream
5. Stream MUST be parsed identically to vision analysis stream
6. Parsed objects MUST match ChainOfThoughtEvaluation schema
7. State MUST update to: `evaluation: ChainOfThoughtEvaluation`

**Testable Assertions**:
```typescript
ASSERT: fetch URL === '/api/vision/evaluate-with-reasoning'
ASSERT: method === 'POST'
ASSERT: Content-Type === 'application/json'
ASSERT: body contains serialized analysis object
ASSERT: Response is NDJSON stream
ASSERT: Stream parsing matches vision stream logic
ASSERT: setEvaluation() called with parsed object
```

---

## 2. API Contract Specification

### API-1: POST /api/vision/analyze-report-card

**Request Format**:
```http
POST /api/vision/analyze-report-card
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...

------WebKitFormBoundary...
Content-Disposition: form-data; name="image"; filename="report.jpg"
Content-Type: image/jpeg

<binary image data>
------WebKitFormBoundary...
Content-Disposition: form-data; name="studentName"

John Doe
------WebKitFormBoundary...--
```

**Response Format**:
```http
HTTP/1.1 200 OK
Content-Type: application/x-ndjson
X-Student-Name: John Doe

{"type":"analysis","data":{"studentName":"John Doe","documentType":"report card",...}}
{"type":"response","data":{"greeting":"Greetings, John Doe...",...}}
{"type":"response","data":{"greeting":"Greetings, John Doe...","message":"partial..."}}
{"type":"response","data":{"greeting":"Greetings, John Doe...","message":"full message",...}}
```

**Error Responses**:
- 400: `{"error":"No image provided"}`
- 500: `{"error":"Failed to analyze report card"}`

**Testable Assertions**:
```typescript
ASSERT: Request has multipart/form-data Content-Type
ASSERT: Request includes boundary in Content-Type
ASSERT: Image field name is "image"
ASSERT: studentName field name is "studentName"
ASSERT: Response status is 200 for valid requests
ASSERT: Response Content-Type is application/x-ndjson
ASSERT: Response includes X-Student-Name header
ASSERT: Response body is newline-delimited JSON
ASSERT: First line has type="analysis"
ASSERT: Subsequent lines have type="response"
```

---

### API-2: POST /api/vision/evaluate-with-reasoning

**Request Format**:
```http
POST /api/vision/evaluate-with-reasoning
Content-Type: application/json

{
  "analysis": {
    "studentName": "John Doe",
    "documentType": "report card",
    "overallPerformance": "excellent",
    "grades": [...],
    "strengths": [...],
    "weaknesses": [...],
    "achievements": [...],
    "virtuesDetected": [...]
  }
}
```

**Response Format**:
```http
HTTP/1.1 200 OK
Content-Type: application/x-ndjson

{"reasoning":{"academicAnalysis":"...","characterAssessment":"...",...},"evaluation":{...}}
```

**Testable Assertions**:
```typescript
ASSERT: Request Content-Type is application/json
ASSERT: Request body has "analysis" key
ASSERT: analysis object matches ReportCardAnalysis schema
ASSERT: Response is NDJSON stream
ASSERT: Parsed object has "reasoning" and "evaluation" keys
```

---

## 3. UI Interaction Specification

### UI-1: File Preview Display

**Component**: `src/components/prompt-input-upload.tsx:262-275`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. Preview MUST render when `previewUrl !== null`
2. Preview MUST NOT render when `previewUrl === null`
3. Image src MUST be data URL from FileReader
4. Image alt text MUST be "Report card preview"
5. Preview width MUST be 256px (w-64 = 16rem = 256px)

**Testable Assertions**:
```typescript
ASSERT: Preview div renders when previewUrl exists
ASSERT: Preview div hidden when previewUrl is null
ASSERT: img src === previewUrl
ASSERT: img alt === "Report card preview"
ASSERT: Preview container has w-64 class (256px)
```

---

### UI-2: Error Display

**Component**: `src/components/prompt-input-upload.tsx:251-253`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. Error message MUST render when `error !== null`
2. Error message MUST NOT render when `error === null`
3. Error text MUST match error state value
4. Error text color MUST be red (text-red-600)

**Testable Assertions**:
```typescript
ASSERT: Error p element renders when error exists
ASSERT: Error p element hidden when error is null
ASSERT: Error text content === error
ASSERT: Error has text-red-600 class
```

---

### UI-3: Processing Stage Display

**Component**: `src/components/prompt-input-upload.tsx:255-259`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. Processing stage MUST render when `processingStage !== ''`
2. Processing stage MUST NOT render when `processingStage === ''`
3. Text MUST match processingStage value
4. Text MUST have pulse animation

**Testable Assertions**:
```typescript
ASSERT: Processing div renders when processingStage exists
ASSERT: Processing div hidden when processingStage is empty
ASSERT: Processing text === processingStage
ASSERT: Processing text has animate-pulse class
```

---

### UI-4: Analysis Results Display

**Component**: `src/components/prompt-input-upload.tsx:395-442`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. Analysis section MUST render when `analysis !== null`
2. Analysis section MUST NOT render when `analysis === null`
3. Student name MUST display: `analysis.studentName`
4. Performance MUST display: `analysis.overallPerformance` (capitalized)
5. Grades MUST render as grid of cards: `analysis.grades.map(...)`
6. Each grade card MUST show subject and grade
7. Virtues MUST render as badges: `analysis.virtuesDetected.map(...)`

**Testable Assertions**:
```typescript
ASSERT: Analysis div renders when analysis exists
ASSERT: Analysis div hidden when analysis is null
ASSERT: Student name === analysis.studentName
ASSERT: Performance === analysis.overallPerformance
ASSERT: Grade cards count === analysis.grades.length
ASSERT: Each grade shows correct subject and grade
ASSERT: Virtue badges count === analysis.virtuesDetected.length
```

---

### UI-5: Evaluation Display

**Component**: `src/components/prompt-input-upload.tsx:299-392`
**Status**: ‚ö†Ô∏è UNTESTED IN BROWSER

**EXACT Behavior**:
1. Reasoning section MUST render when `evaluation?.reasoning !== null`
2. Evaluation section MUST render when `evaluation?.evaluation !== null`
3. All reasoning fields MUST display (academic, character, growth, strengths)
4. Overall grade MUST display capitalized
5. Virtues mastered MUST render as badges
6. Encouragement MUST display
7. Actionable advice MUST render as numbered list
8. Reward MUST display type and unlock message

**Testable Assertions**:
```typescript
ASSERT: Reasoning div renders when evaluation.reasoning exists
ASSERT: Evaluation div renders when evaluation.evaluation exists
ASSERT: All 4 reasoning categories render
ASSERT: Overall grade displays capitalized
ASSERT: Virtues badges count === evaluation.evaluation.virtuesMastered.length
ASSERT: Encouragement text === evaluation.evaluation.encouragement
ASSERT: Advice list count === evaluation.evaluation.actionableAdvice.length
ASSERT: Reward displays type and unlock message
```

---

## 4. "AI Components Trigger Upload" - Exact Definition

### Requirement Clarification

**User Statement**: "Make sure upload is triggered by AI components"

**Interpretation Options**:

#### Option A: AI-Powered Upload Button (Most Likely)
**Meaning**: The upload button/action should be considered an "AI component" because it triggers AI processing (vision analysis + Optimus response)

**Current Implementation**: ‚úÖ **MATCHES**
- Button at line 279 triggers `analyzeReportCard()`
- `analyzeReportCard()` calls vision AI and Optimus AI
- Button text emphasizes AI: "üöÄ Analyze with Vision AI"

**Testable Assertion**:
```typescript
ASSERT: Clicking "Analyze with Vision AI" button triggers analyzeReportCard()
ASSERT: analyzeReportCard() calls /api/vision/analyze-report-card
ASSERT: API calls vision model (qwen2.5-vl)
ASSERT: API calls language model (qwen3-coder:30b)
ASSERT: Results display in UI with AI-generated content
```

#### Option B: AI Decides When to Upload (Alternative)
**Meaning**: An AI agent analyzes user behavior and automatically triggers upload when appropriate

**Current Implementation**: ‚ùå **NOT IMPLEMENTED**
- Upload is manually triggered by user clicking button
- No AI-driven auto-trigger logic exists

**If This Is Required**: Major feature addition needed

---

#### Option C: AI Validates Before Upload (Alternative)
**Meaning**: AI pre-checks file before allowing upload (e.g., "is this a report card?")

**Current Implementation**: ‚ö†Ô∏è **PARTIAL**
- File type validation exists (must be image)
- NO AI validation before upload
- AI validation happens AFTER upload on server

**If This Is Required**: Add client-side AI validation step

---

### Recommended Interpretation

**Based on context**: Option A is most likely correct.

**Rationale**:
1. Button explicitly mentions "Vision AI"
2. Upload immediately triggers AI processing
3. No indication of automated triggering in requirements
4. False positive scan focuses on upload functionality, not AI-driven automation

**Action**: Validate with user that "AI components trigger upload" means "upload button initiates AI processing"

---

## 5. Assumptions Requiring Testing

### Assumption 1: Browser FormData Compatibility
**Assumption**: Browser FormData API creates multipart/form-data identical to Node.js
**Status**: ‚ö†Ô∏è UNTESTED
**Risk**: üî¥ HIGH
**Test**: Playwright test capturing actual browser FormData boundary and content
**Validation Method**: Intercept network request, inspect raw HTTP body

---

### Assumption 2: Vision Model Image Processing
**Assumption**: qwen2.5-vl can extract text from report card images
**Status**: üî¥ COMPLETELY UNTESTED
**Risk**: üî¥ CRITICAL
**Test**: Call vision API with real report card image, verify OCR accuracy
**Validation Method**: Compare extracted text to known image content

---

### Assumption 3: ReadableStream Browser Support
**Assumption**: Browser ReadableStream API works identically to Node.js
**Status**: ‚ö†Ô∏è UNTESTED
**Risk**: üü° MEDIUM
**Test**: Playwright test consuming NDJSON stream in browser
**Validation Method**: Verify all stream chunks received and parsed

---

### Assumption 4: Image Data Integrity
**Assumption**: Image binary data survives client ‚Üí server ‚Üí vision model pipeline intact
**Status**: üî¥ UNTESTED
**Risk**: üî¥ HIGH
**Test**: Upload image, verify base64 decoding produces original binary
**Validation Method**: Hash comparison (original vs decoded)

---

### Assumption 5: File Size Limits
**Assumption**: UI shows "up to 10MB" but NO validation enforces this
**Status**: ‚ö†Ô∏è MISSING IMPLEMENTATION
**Risk**: üü° MEDIUM
**Test**: Upload 15MB image, verify behavior (should fail?)
**Validation Method**: Test with oversized file

---

### Assumption 6: CORS/CSP Compatibility
**Assumption**: No CORS or CSP issues with FormData upload to same-origin API
**Status**: ‚ö†Ô∏è UNTESTED
**Risk**: üü° MEDIUM
**Test**: Playwright test in production-like environment
**Validation Method**: Check for CORS/CSP errors in console

---

### Assumption 7: Error Boundary Handling
**Assumption**: React error boundaries catch streaming errors gracefully
**Status**: ‚ö†Ô∏è NOT VERIFIED
**Risk**: üü° MEDIUM
**Test**: Inject stream error, verify UI doesn't crash
**Validation Method**: Simulate network failure during stream

---

## 6. Acceptance Criteria

### AC-1: File Selection
**GIVEN**: User is on upload page
**WHEN**: User clicks drop zone OR drags image onto drop zone
**THEN**: File input opens OR file is selected from drag
**AND**: Preview displays image
**AND**: "Analyze" button becomes enabled

**Test Method**: Playwright test with real file selection

---

### AC-2: Image Upload via FormData
**GIVEN**: User has selected an image file
**WHEN**: User clicks "Analyze with Vision AI"
**THEN**: FormData is constructed with 'image' field
**AND**: POST request is sent to /api/vision/analyze-report-card
**AND**: Request Content-Type is multipart/form-data with boundary

**Test Method**: Playwright test with network interception

---

### AC-3: Vision Model Analysis
**GIVEN**: Server receives image via FormData
**WHEN**: Server calls qwen2.5-vl vision model
**THEN**: Model extracts student name, grades, and virtues from image
**AND**: Response matches ReportCardAnalysis schema
**AND**: Analysis accuracy >= 90% (baseline)

**Test Method**: Integration test with real report card image

---

### AC-4: NDJSON Streaming
**GIVEN**: Vision analysis completes
**WHEN**: Server streams response
**THEN**: Client receives NDJSON stream
**AND**: Stream is parsed line-by-line
**AND**: UI updates incrementally as data arrives
**AND**: No parsing errors occur

**Test Method**: Playwright test monitoring state updates

---

### AC-5: Optimus Response Generation
**GIVEN**: Vision analysis completes
**WHEN**: Server generates Optimus response
**THEN**: Response includes personalized greeting
**AND**: Response includes actionable advice (3-5 items)
**AND**: Response is encouraging and specific

**Test Method**: Integration test with analysis data

---

### AC-6: UI State Updates
**GIVEN**: Upload process is in progress
**WHEN**: Each stage completes
**THEN**: Processing stage message updates
**AND**: Analysis section renders when data available
**AND**: Evaluation section renders when complete
**AND**: "Analyzing..." button text shows during processing

**Test Method**: Playwright test monitoring UI state

---

### AC-7: Error Handling
**GIVEN**: Upload fails for any reason
**WHEN**: Error occurs
**THEN**: Error message displays in UI
**AND**: "Analyzing" state resets
**AND**: User can retry upload
**AND**: Error is logged to console

**Test Method**: Playwright test with simulated failures

---

### AC-8: Reset Functionality
**GIVEN**: Upload has completed (success or error)
**WHEN**: User clicks "Reset"
**THEN**: All state clears (file, preview, analysis, evaluation)
**AND**: File input resets
**AND**: UI returns to initial state

**Test Method**: Playwright test of reset flow

---

## 7. Critical Gaps & Unknowns

### Gap 1: No Browser Testing
**Severity**: üî¥ CRITICAL
**Impact**: 100% of browser-specific behavior is UNTESTED
**Resolution**: Deploy Playwright test suite immediately

---

### Gap 2: Vision Model Untested
**Severity**: üî¥ CRITICAL
**Impact**: Core feature (OCR) has NEVER been validated
**Resolution**: Test qwen2.5-vl with real report card images

---

### Gap 3: No File Size Validation
**Severity**: üü° MEDIUM
**Impact**: UI claims "up to 10MB" but doesn't enforce
**Resolution**: Add file size validation in handleFileSelect

---

### Gap 4: Silent Drag-Drop Rejection
**Severity**: üü° MEDIUM
**Impact**: Invalid drag-drop files fail silently (no error shown)
**Resolution**: Show error message for non-image drag-drop

---

### Gap 5: No Loading Timeout
**Severity**: üü° MEDIUM
**Impact**: If vision model hangs, UI stays in "Analyzing..." state forever
**Resolution**: Add timeout (e.g., 60 seconds) with error message

---

### Gap 6: No Retry Mechanism
**Severity**: üü° MEDIUM
**Impact**: Transient failures require full page reload
**Resolution**: Allow retry without resetting file selection

---

### Gap 7: No Progress Indication
**Severity**: üü° LOW
**Impact**: User doesn't know if large upload is progressing
**Resolution**: Add upload progress bar (if needed)

---

## 8. Test Strategy Summary

### Unit Tests (Mock All External Dependencies)
1. **handleFileSelect()**: Verify File object handling and preview generation
2. **handleDrop()**: Verify drag-drop file extraction and validation
3. **analyzeReportCard()**: Verify FormData construction and fetch call
4. **Stream parsing**: Verify NDJSON line-by-line parsing logic
5. **State management**: Verify all state transitions

**Mocking Strategy**:
- Mock FileReader API
- Mock fetch() with controlled responses
- Mock ReadableStream with test data
- Mock ollama vision model responses

---

### Integration Tests (Real Browser, Mock AI)
1. **File selection flow**: Real browser file input interaction
2. **FormData upload**: Real browser FormData to real API endpoint
3. **Stream consumption**: Real browser receiving NDJSON stream
4. **UI rendering**: Real browser DOM updates

**Mocking Strategy**:
- Mock Ollama vision model (return controlled analysis)
- Mock Ollama language model (return controlled response)
- Use real Next.js API routes
- Use real browser APIs

---

### End-to-End Tests (Real Browser, Real AI)
1. **Complete upload flow**: Real file ‚Üí Real API ‚Üí Real vision model ‚Üí Real UI
2. **Accuracy testing**: Verify vision model extracts correct data from report cards
3. **Performance testing**: Measure response times for various image sizes
4. **Error scenarios**: Test with corrupted images, oversized files, network failures

**No Mocking**: Full production-like environment

---

## 9. Success Metrics

### Functional Metrics
- **Upload Success Rate**: >= 95% of valid images process successfully
- **Vision Accuracy**: >= 90% of text extracted correctly from report cards
- **Stream Reliability**: 100% of stream chunks delivered without errors
- **UI Responsiveness**: All state updates reflect within 100ms of data arrival

### Performance Metrics
- **Time to First Byte**: <= 500ms after upload initiated
- **Total Processing Time**: <= 10 seconds for typical report card image
- **Image Upload Size**: Support images up to 10MB
- **Concurrent Users**: Support 10+ simultaneous uploads

### User Experience Metrics
- **Error Recovery**: Users can retry without page reload
- **Progress Visibility**: Users always know current processing stage
- **Result Clarity**: Analysis and evaluation are clearly displayed

---

## 10. Next Steps for Swarm

### Agent 2 (Pseudocode) - Use These Specifications
**Input**: This specification document
**Output**: Detailed pseudocode for upload flow and test scenarios

### Agent 3 (Architect) - Design Test Architecture
**Input**: This specification + Agent 2 pseudocode
**Output**: Playwright test structure, mocking strategy, test data fixtures

### Agent 4-7 (TDD Implementation) - Write Tests First
**Input**: Agent 3 architecture
**Output**: Failing tests covering all acceptance criteria

### Agent 8 (Integration) - Validate Against Specifications
**Input**: Passing tests
**Output**: Confirmation that all specifications are met

---

## Appendix A: Component Dependencies

```
prompt-input-upload.tsx (Client)
  ‚îú‚îÄ handleFileSelect() ‚Üí FileReader API
  ‚îú‚îÄ handleDrop() ‚Üí DragEvent API
  ‚îî‚îÄ analyzeReportCard()
      ‚îú‚îÄ FormData API
      ‚îú‚îÄ fetch() ‚Üí /api/vision/analyze-report-card
      ‚îÇ   ‚îî‚îÄ route.ts (Server)
      ‚îÇ       ‚îú‚îÄ request.formData()
      ‚îÇ       ‚îú‚îÄ imageFile.arrayBuffer()
      ‚îÇ       ‚îú‚îÄ Buffer.from() ‚Üí base64 encoding
      ‚îÇ       ‚îú‚îÄ streamObject(ollama('qwen2.5-vl')) ‚Üí Vision Analysis
      ‚îÇ       ‚îî‚îÄ streamObject(ollama('qwen3-coder')) ‚Üí Optimus Response
      ‚îî‚îÄ ReadableStream consumer
          ‚îú‚îÄ TextDecoder
          ‚îú‚îÄ JSON.parse()
          ‚îî‚îÄ State updates (setAnalysis, setOptimusResponse)
```

---

## Appendix B: Critical Files

1. `/src/components/prompt-input-upload.tsx` - Client-side upload component
2. `/src/app/api/vision/analyze-report-card/route.ts` - Server-side API endpoint
3. `/lib/vision-schema` - Schema definitions (not read, inferred from code)
4. `/tests/FALSE-POSITIVE-SCAN.md` - Context for false positive investigation

---

## Appendix C: Specification Confidence Levels

| Specification Section | Confidence Level | Reason |
|----------------------|------------------|--------|
| FR-1: File Selection | üü° MEDIUM | Code clear, browser testing needed |
| FR-2: FormData Construction | üü° MEDIUM | Browser FormData untested |
| FR-3: API Request | üü° MEDIUM | Fetch behavior assumed |
| FR-4: API Handling | üü° MEDIUM | Server parsing untested with real browser |
| FR-5: Vision Model | üî¥ LOW | Completely untested |
| FR-6: Optimus Response | üü¢ HIGH | Tested with mock data |
| FR-7: NDJSON Streaming | üü° MEDIUM | Server code clear, client untested |
| FR-8: UI State | üü° MEDIUM | Code clear, browser rendering untested |
| FR-9: Evaluation | üü¢ HIGH | Tested separately |

**Overall Confidence**: üü° **40%** - Significant testing required

---

**End of Specification Document**

**Agent 1 Status**: ‚úÖ COMPLETE
**Next Agent**: Agent 2 (Pseudocode)
**Document Version**: 1.0.0
**Last Updated**: October 16, 2025
