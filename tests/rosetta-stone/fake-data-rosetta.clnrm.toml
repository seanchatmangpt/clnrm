# =============================================================================
# Fake Data Generators Rosetta Stone Test
# =============================================================================
# This test validates all fake data generation functions in the cleanroom
# testing framework. It ensures that generated data matches expected formats
# and patterns using regex validation and shell-based range checking.
#
# Test Coverage:
# 1. Name generation (fake_name)
# 2. Email generation (fake_email)
# 3. IP address generation (fake_ipv4, fake_ipv6)
# 4. Integer range generation (fake_int_range)
# 5. Date generation (fake_date)
# 6. Address generation (fake_address)
# 7. Combined data generation scenarios
# =============================================================================

[test.metadata]
name = "fake_data_rosetta"
description = "Comprehensive validation of fake data generation functions with format verification"
version = "1.0.0"
author = "Cleanroom Test Framework"
tags = ["rosetta-stone", "fake-data", "validation", "generators"]

# =============================================================================
# Service Configuration
# =============================================================================

[services.test_container]
type = "generic_container"
plugin = "generic_container"
image = "alpine:latest"
description = "Lightweight Alpine Linux container for testing fake data generators"

# =============================================================================
# Test Scenarios
# =============================================================================

# -----------------------------------------------------------------------------
# Scenario 1: Name Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_name_format"
service = "test_container"
command = ["echo", "{{ fake_name() }}"]
description = "Validate that fake_name() generates a name with at least first and last parts"
# Pattern: At least two words separated by space (e.g., "John Doe")
expected_output_regex = "^[A-Za-z]+\\s+[A-Za-z]+.*$"

[[steps]]
name = "test_fake_name_non_empty"
service = "test_container"
command = ["sh", "-c", "name='{{ fake_name() }}'; test -n \"$name\" && echo 'NAME_GENERATED'"]
description = "Verify that fake_name() produces non-empty output"
expected_output_regex = "NAME_GENERATED"

[[steps]]
name = "test_fake_name_multiple_calls"
service = "test_container"
command = ["sh", "-c", "echo '{{ fake_name() }}' '{{ fake_name() }}' '{{ fake_name() }}'"]
description = "Verify multiple name generations in single command"
# Pattern: Three name patterns separated by spaces
expected_output_regex = "^[A-Za-z]+\\s+[A-Za-z]+.*\\s+[A-Za-z]+\\s+[A-Za-z]+.*\\s+[A-Za-z]+\\s+[A-Za-z]+.*$"

# -----------------------------------------------------------------------------
# Scenario 2: Email Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_email_format"
service = "test_container"
command = ["echo", "{{ fake_email() }}"]
description = "Validate email format: localpart@domain.tld"
# RFC 5322 simplified: something@something.something
expected_output_regex = "^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$"

[[steps]]
name = "test_fake_email_has_at_symbol"
service = "test_container"
command = ["sh", "-c", "email='{{ fake_email() }}'; echo \"$email\" | grep -q '@' && echo 'VALID_EMAIL'"]
description = "Verify email contains @ symbol"
expected_output_regex = "VALID_EMAIL"

[[steps]]
name = "test_fake_email_has_domain"
service = "test_container"
command = ["sh", "-c", "email='{{ fake_email() }}'; echo \"$email\" | grep -qE '\\.[a-z]{2,}$' && echo 'HAS_TLD'"]
description = "Verify email has valid top-level domain"
expected_output_regex = "HAS_TLD"

[[steps]]
name = "test_fake_email_uniqueness"
service = "test_container"
command = ["sh", "-c", "e1='{{ fake_email() }}'; e2='{{ fake_email() }}'; e3='{{ fake_email() }}'; echo \"$e1\" \"$e2\" \"$e3\""]
description = "Generate multiple emails (typically unique but not guaranteed)"
# Pattern: Three email addresses
expected_output_regex = "^[^@\\s]+@[^@\\s]+\\.[^@\\s]+\\s+[^@\\s]+@[^@\\s]+\\.[^@\\s]+\\s+[^@\\s]+@[^@\\s]+\\.[^@\\s]+$"

# -----------------------------------------------------------------------------
# Scenario 3: IPv4 Address Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_ipv4_format"
service = "test_container"
command = ["echo", "{{ fake_ipv4() }}"]
description = "Validate IPv4 address format: X.X.X.X where X is 0-255"
# Pattern: Four octets separated by dots
expected_output_regex = "^([0-9]{1,3}\\.){3}[0-9]{1,3}$"

[[steps]]
name = "test_fake_ipv4_octet_range"
service = "test_container"
command = ["sh", "-c", "ip='{{ fake_ipv4() }}'; octet=$(echo \"$ip\" | cut -d. -f1); test $octet -ge 0 -a $octet -le 255 && echo 'VALID_OCTET'"]
description = "Verify first octet is in valid range (0-255)"
expected_output_regex = "VALID_OCTET"

[[steps]]
name = "test_fake_ipv4_has_four_octets"
service = "test_container"
command = ["sh", "-c", "ip='{{ fake_ipv4() }}'; count=$(echo \"$ip\" | tr -cd '.' | wc -c); test $count -eq 3 && echo 'FOUR_OCTETS'"]
description = "Verify IPv4 has exactly 4 octets (3 dots)"
expected_output_regex = "FOUR_OCTETS"

# -----------------------------------------------------------------------------
# Scenario 4: IPv6 Address Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_ipv6_format"
service = "test_container"
command = ["echo", "{{ fake_ipv6() }}"]
description = "Validate IPv6 address format contains hexadecimal and colons"
# Pattern: Hex digits and colons (simplified, allows various IPv6 forms)
expected_output_regex = "^[0-9a-fA-F:]+$"

[[steps]]
name = "test_fake_ipv6_has_colons"
service = "test_container"
command = ["sh", "-c", "ip='{{ fake_ipv6() }}'; echo \"$ip\" | grep -q ':' && echo 'HAS_COLONS'"]
description = "Verify IPv6 contains colon separators"
expected_output_regex = "HAS_COLONS"

[[steps]]
name = "test_fake_ipv6_non_empty"
service = "test_container"
command = ["sh", "-c", "ip='{{ fake_ipv6() }}'; test -n \"$ip\" && echo 'IPV6_GENERATED'"]
description = "Verify IPv6 is non-empty"
expected_output_regex = "IPV6_GENERATED"

# -----------------------------------------------------------------------------
# Scenario 5: Integer Range Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_int_range_10_20"
service = "test_container"
command = ["sh", "-c", "val='{{ fake_int_range(min=10, max=20) }}'; test $val -ge 10 -a $val -le 20 && echo 'VALID_RANGE_10_20'"]
description = "Verify integer is within range [10, 20]"
expected_output_regex = "VALID_RANGE_10_20"

[[steps]]
name = "test_fake_int_range_0_100"
service = "test_container"
command = ["sh", "-c", "val='{{ fake_int_range(min=0, max=100) }}'; test $val -ge 0 -a $val -le 100 && echo 'VALID_RANGE_0_100'"]
description = "Verify integer is within range [0, 100]"
expected_output_regex = "VALID_RANGE_0_100"

[[steps]]
name = "test_fake_int_range_negative"
service = "test_container"
command = ["sh", "-c", "val='{{ fake_int_range(min=-50, max=-10) }}'; test $val -ge -50 -a $val -le -10 && echo 'VALID_NEGATIVE_RANGE'"]
description = "Verify negative integer range [-50, -10]"
expected_output_regex = "VALID_NEGATIVE_RANGE"

[[steps]]
name = "test_fake_int_range_is_integer"
service = "test_container"
command = ["sh", "-c", "val='{{ fake_int_range(min=1, max=1000) }}'; echo \"$val\" | grep -qE '^-?[0-9]+$' && echo 'IS_INTEGER'"]
description = "Verify output is a valid integer (no decimals)"
expected_output_regex = "IS_INTEGER"

[[steps]]
name = "test_fake_int_range_multiple"
service = "test_container"
command = ["sh", "-c", "v1='{{ fake_int_range(min=1, max=10) }}'; v2='{{ fake_int_range(min=1, max=10) }}'; v3='{{ fake_int_range(min=1, max=10) }}'; echo \"$v1\" \"$v2\" \"$v3\""]
description = "Generate multiple random integers in range"
# Pattern: Three integers separated by spaces
expected_output_regex = "^[0-9]+\\s+[0-9]+\\s+[0-9]+$"

# -----------------------------------------------------------------------------
# Scenario 6: Date Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_date_format"
service = "test_container"
command = ["echo", "{{ fake_date() }}"]
description = "Validate date format (ISO 8601 or common date format)"
# Pattern: YYYY-MM-DD or MM/DD/YYYY or DD-MM-YYYY
expected_output_regex = "^[0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}/[0-9]{2}/[0-9]{4}|[0-9]{2}-[0-9]{2}-[0-9]{4}$"

[[steps]]
name = "test_fake_date_non_empty"
service = "test_container"
command = ["sh", "-c", "date='{{ fake_date() }}'; test -n \"$date\" && echo 'DATE_GENERATED'"]
description = "Verify date is non-empty"
expected_output_regex = "DATE_GENERATED"

[[steps]]
name = "test_fake_date_contains_separators"
service = "test_container"
command = ["sh", "-c", "date='{{ fake_date() }}'; echo \"$date\" | grep -qE '[-/]' && echo 'HAS_SEPARATORS'"]
description = "Verify date contains separator characters (- or /)"
expected_output_regex = "HAS_SEPARATORS"

# -----------------------------------------------------------------------------
# Scenario 7: Address Generation Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_address_format"
service = "test_container"
command = ["echo", "{{ fake_address() }}"]
description = "Validate address contains text (street, city, etc.)"
# Pattern: Non-empty string with letters and possibly numbers
expected_output_regex = "^.*[A-Za-z]+.*$"

[[steps]]
name = "test_fake_address_non_empty"
service = "test_container"
command = ["sh", "-c", "addr='{{ fake_address() }}'; test -n \"$addr\" && echo 'ADDRESS_GENERATED'"]
description = "Verify address is non-empty"
expected_output_regex = "ADDRESS_GENERATED"

[[steps]]
name = "test_fake_address_has_components"
service = "test_container"
command = ["sh", "-c", "addr='{{ fake_address() }}'; test $(echo \"$addr\" | wc -w) -ge 2 && echo 'MULTI_WORD_ADDRESS'"]
description = "Verify address has multiple components (at least 2 words)"
expected_output_regex = "MULTI_WORD_ADDRESS"

# -----------------------------------------------------------------------------
# Scenario 8: Combined Data Generation (Real-World Use Case)
# -----------------------------------------------------------------------------

[[steps]]
name = "test_combined_user_profile"
service = "test_container"
command = ["sh", "-c", "echo 'Name: {{ fake_name() }}, Email: {{ fake_email() }}, IP: {{ fake_ipv4() }}'"]
description = "Generate complete user profile with name, email, and IP"
# Pattern: "Name: ..., Email: ..., IP: ..."
expected_output_regex = "^Name: [A-Za-z]+\\s+[A-Za-z]+.*, Email: [^@]+@[^@]+\\.[^@]+, IP: ([0-9]{1,3}\\.){3}[0-9]{1,3}$"

[[steps]]
name = "test_combined_multiple_users"
service = "test_container"
command = ["sh", "-c", "for i in 1 2 3; do echo \"User$i: {{ fake_name() }} - {{ fake_email() }}\"; done"]
description = "Generate data for multiple users in loop"
# Pattern: Three lines of User data
expected_output_regex = "User1:.*User2:.*User3:"

[[steps]]
name = "test_combined_structured_data"
service = "test_container"
command = ["sh", "-c", "echo '{\"name\":\"{{ fake_name() }}\",\"email\":\"{{ fake_email() }}\",\"age\":{{ fake_int_range(min=18, max=65) }}}'"]
description = "Generate JSON-like structured data"
# Pattern: JSON structure with name, email, age
expected_output_regex = '^\{"name":"[^"]+","email":"[^"]+","age":[0-9]+\}$'

# -----------------------------------------------------------------------------
# Edge Cases and Validation
# -----------------------------------------------------------------------------

[[steps]]
name = "test_fake_int_range_single_value"
service = "test_container"
command = ["sh", "-c", "val='{{ fake_int_range(min=42, max=42) }}'; test $val -eq 42 && echo 'SINGLE_VALUE_CORRECT'"]
description = "Verify range with same min/max returns that value"
expected_output_regex = "SINGLE_VALUE_CORRECT"

[[steps]]
name = "test_fake_generators_in_variable_assignment"
service = "test_container"
command = ["sh", "-c", "NAME='{{ fake_name() }}'; EMAIL='{{ fake_email() }}'; test -n \"$NAME\" -a -n \"$EMAIL\" && echo 'VARIABLES_ASSIGNED'"]
description = "Verify fake data works in shell variable assignments"
expected_output_regex = "VARIABLES_ASSIGNED"

[[steps]]
name = "test_fake_data_escaped_properly"
service = "test_container"
command = ["sh", "-c", "data='{{ fake_email() }}'; echo \"$data\" | grep -vq \"{{\" && echo 'NO_TEMPLATE_MARKERS'"]
description = "Verify template markers are replaced, not passed through"
expected_output_regex = "NO_TEMPLATE_MARKERS"

# =============================================================================
# Assertions
# =============================================================================

[assertions]
# All steps should execute successfully
all_steps_should_pass = true

# Verify hermetic execution
execution_should_be_hermetic = true

# Container should execute all commands
container_should_have_executed_commands = 35

# No failures allowed - all fake data should generate valid formats
no_failed_assertions = true
